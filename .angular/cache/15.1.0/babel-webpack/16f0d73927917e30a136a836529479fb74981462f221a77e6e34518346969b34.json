{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, EventEmitter, Directive, Inject, Input, Output, NgModule } from '@angular/core';\nimport * as i1 from '@fundamental-ngx/cdk/utils';\nimport { DestroyedService, isBlank, isStringMap, isType, isJsObject, isFunction } from '@fundamental-ngx/cdk/utils';\nimport { Subscription, BehaviorSubject, Subject, isObservable, of } from 'rxjs';\nimport { takeUntil, map } from 'rxjs/operators';\n\n/**\n * Checks whether passed value is a valid data source.\n */\nfunction isDataSource(value) {\n  return value && typeof value.unsubscribe === 'function' && value.dataChanges;\n}\n\n/**\n * Injection token used for passing custom datasource transformer into DataSourceProvider.\n */\nconst FD_DATA_SOURCE_TRANSFORMER = new InjectionToken('FdDataSourceTransformer');\nlet DataSourceDirective = /*#__PURE__*/(() => {\n  class DataSourceDirective {\n    /**\n     * Data source.\n     * @param source\n     */\n    set dataSource(source) {\n      this._dataSource = source;\n      this.dataSourceChanged.next();\n      this._initializeDataSource();\n    }\n    get dataSource() {\n      return this._dataSource;\n    }\n    /** @hidden */\n    constructor(_destroyed$, _dataSourceTransformer) {\n      this._destroyed$ = _destroyed$;\n      this._dataSourceTransformer = _dataSourceTransformer;\n      /** @hidden */\n      this._dsSubscription = new Subscription();\n      /**\n       * Data stream. Emits when new data retrieved.\n       */\n      this.dataChanged$ = new BehaviorSubject([]);\n      /**\n       * Emits when the data source object has been changed.\n       */\n      this.dataSourceChanged = new EventEmitter();\n      /**\n       * Event emitted when datasource content has been changed.\n       */\n      this.dataChanged = new EventEmitter();\n      /**\n       * Event emitted when data provider loading state has been changed.\n       */\n      this.isLoading = new EventEmitter();\n    }\n    /** @hidden */\n    _initializeDataSource() {\n      if (isDataSource(this.dataSource)) {\n        this.dataSourceProvider?.unsubscribe();\n        this._dsSubscription?.unsubscribe();\n      }\n      // Convert whatever comes in as DataSource, so we can work with it identically\n      this.dataSourceProvider = this._toDataStream(this.dataSource);\n      if (!this.dataSourceProvider) {\n        return;\n      }\n      this._dsSubscription = new Subscription();\n      this._dsSubscription.add(this.dataSourceProvider.dataLoading.pipe(takeUntil(this._destroyed$)).subscribe(isLoading => this.isLoading.emit(isLoading)));\n      this._dsSubscription.add(this.dataSourceProvider.dataChanges.pipe(takeUntil(this._destroyed$)).subscribe(data => {\n        this.dataChanged.emit(data);\n        this.dataChanged$.next(data);\n      }));\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.dataSourceProvider?.unsubscribe();\n      this._dsSubscription?.unsubscribe();\n    }\n    /** @Hidden */\n    _toDataStream(source) {\n      return this._dataSourceTransformer ? this._dataSourceTransformer.parse(source) : undefined;\n    }\n  }\n  DataSourceDirective.ɵfac = function DataSourceDirective_Factory(t) {\n    return new (t || DataSourceDirective)(i0.ɵɵdirectiveInject(i1.DestroyedService), i0.ɵɵdirectiveInject(FD_DATA_SOURCE_TRANSFORMER));\n  };\n  DataSourceDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DataSourceDirective,\n    selectors: [[\"\", \"fdkDataSource\", \"\"]],\n    inputs: {\n      dataSource: \"dataSource\"\n    },\n    outputs: {\n      dataSourceChanged: \"dataSourceChanged\",\n      dataChanged: \"dataChanged\",\n      isLoading: \"isLoading\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([DestroyedService])]\n  });\n  return DataSourceDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DataSourceModule = /*#__PURE__*/(() => {\n  class DataSourceModule {}\n  DataSourceModule.ɵfac = function DataSourceModule_Factory(t) {\n    return new (t || DataSourceModule)();\n  };\n  DataSourceModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DataSourceModule\n  });\n  DataSourceModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return DataSourceModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nvar MatchingStrategy = /*#__PURE__*/(() => {\n  (function (MatchingStrategy) {\n    MatchingStrategy[\"STARTS_WITH_PER_TERM\"] = \"starts with per term\";\n    MatchingStrategy[\"STARTS_WITH\"] = \"starts with\";\n    MatchingStrategy[\"CONTAINS\"] = \"contains\";\n  })(MatchingStrategy || (MatchingStrategy = {}));\n  return MatchingStrategy;\n})();\nlet BaseDataSource = /*#__PURE__*/(() => {\n  class BaseDataSource {\n    /**\n     * Emitted when new data has been requested.\n     * @returns Observable\n     */\n    get dataRequested() {\n      return this._dataRequested$.asObservable();\n    }\n    /**\n     * Emitted when new data has been received.\n     * @returns Observable\n     */\n    get dataReceived() {\n      return this._dataReceived$.asObservable();\n    }\n    /**\n     * Emitted when loading state has been changed.\n     * @returns Observable.\n     */\n    get dataLoading() {\n      return this._dataLoading$.asObservable();\n    }\n    /**\n     * Emits when data from the provides has been changed.\n     * @returns Observable of data source objects.\n     */\n    get dataChanges() {\n      return this._dataChanges$.asObservable().pipe(takeUntil(this._destroy$));\n    }\n    /** @hidden */\n    constructor(dataProvider) {\n      this.dataProvider = dataProvider;\n      /**\n       * Whether to enable limit of max items.\n       */\n      this.limitless = false;\n      /** @hidden */\n      this._dataChanges$ = new BehaviorSubject([]);\n      /** @hidden */\n      this._dataRequested$ = new Subject();\n      /** @hidden */\n      this._dataReceived$ = new Subject();\n      /** @hidden */\n      this._destroy$ = new Subject();\n      /** @hidden */\n      this._dataLoading$ = new BehaviorSubject(false);\n    }\n    /**\n     * Searches through the data source with defined parameters.\n     * @param predicate Search query.\n     * @param start start index.\n     * @param end end index.\n     */\n    match(predicate = new Map(), start = 0, end = Infinity) {\n      this._dataRequested$.next();\n      this._dataLoading$.next(true);\n      const searchParam = new Map();\n      if (typeof predicate === 'string') {\n        searchParam.set('query', predicate);\n      } else if (predicate instanceof Map) {\n        predicate.forEach((v, k) => searchParam.set(k, v));\n      } else {\n        throw new Error('DataSource.match() predicate can only accepts string and Map');\n      }\n      if (!searchParam.has('limit') && !this.limitless) {\n        searchParam.set('limit', BaseDataSource.MaxLimit);\n      }\n      this.dataProvider.fetch(searchParam, start, end).pipe(takeUntil(this._destroy$)).subscribe({\n        next: result => {\n          this._dataReceived$.next();\n          this._dataLoading$.next(false);\n          this._dataChanges$.next(result);\n        },\n        error: () => {\n          this._dataReceived$.next();\n          this._dataLoading$.next(false);\n        }\n      });\n    }\n    /**\n     * Closes the stream\n     */\n    unsubscribe() {\n      this._destroy$.next();\n      this._destroy$.complete();\n    }\n  }\n  /**\n   * Max limit of items to be returned.\n   */\n  BaseDataSource.MaxLimit = 5;\n\n  /** @Hidden */\n  return BaseDataSource;\n})();\nfunction getMatchingStrategyStartsWithPerTermReqexp(value) {\n  return new RegExp(`(\\\\s|^)(${value})`, 'gi');\n}\n/** @hidden */\nfunction objectValues(obj) {\n  return Object.keys(obj).map(key => obj[key]);\n}\n/** @hidden */\nfunction objectToName(target) {\n  if (isBlank(target) || !isStringMap(target) && !isType(target)) {\n    throw new Error(' Cannot convert. Uknown object');\n  }\n  return isType(target) ? target.prototype.constructor.name : target.constructor.name;\n}\n\n/**\n * Base data provider class.\n */\nclass AbstractDataProvider {\n  constructor() {\n    /** @hidden */\n    this._matchingStrategy = MatchingStrategy.STARTS_WITH;\n    /** @hidden */\n    this._matchingBy = null;\n  }\n  /** @hidden */\n  setLookupKey(key) {\n    this._keyPath = key;\n  }\n  /** @hidden */\n  setMatchingBy(matchingBy) {\n    this._matchingBy = matchingBy;\n  }\n  /** @hidden */\n  setMatchingStrategy(strategy) {\n    this._matchingStrategy = strategy;\n  }\n}\n/**\n * Default data provider class used for other components to extend from.\n */\nclass DataProvider extends AbstractDataProvider {\n  /** @hidden */\n  constructor(values) {\n    super();\n    this.values = values;\n  }\n  /** @hidden */\n  fetch(params) {\n    const observable = isObservable(this.values) ? this.values : of(this.values);\n    const queryString = params.get('query');\n    const limit = params.get('limit') || 50;\n    if (!queryString || queryString === '*') {\n      return observable.pipe(map(items => this.withLimit(items, limit)));\n    }\n    const toLowerPattern = queryString.toLowerCase();\n    return observable.pipe(map(items => {\n      const result = [];\n      for (let i = 0; i < items.length; i++) {\n        const item = items[i];\n        if (this.matches(item, toLowerPattern)) {\n          result.push(item);\n          if (result.length >= limit) {\n            break;\n          }\n        }\n      }\n      return result;\n    }));\n  }\n  /**\n   * Warning: If you don't supply search Key and you want fulltext search, and you use this\n   * default implementation be aware that it can  perform poorly as it is naive implementation\n   * that does not do deep compare.\n   */\n  matches(item, pattern) {\n    if (!this._matchingBy) {\n      return false;\n    }\n    const {\n      firstBy,\n      secondaryBy\n    } = this._matchingBy;\n    let matched = this.matchesBy(item, pattern, firstBy);\n    if (!matched && secondaryBy) {\n      matched = this.matchesBy(item, pattern, secondaryBy);\n    }\n    return matched;\n  }\n  /** @hidden */\n  matchesBy(item, pattern, matchingBy) {\n    const value = isJsObject(item) && matchingBy ? matchingBy(item) : item;\n    if (isFunction(value)) {\n      return value.call(item);\n    } else if (isJsObject(value)) {\n      return this.hasObjectValue(item, pattern);\n    } else if (this._matchingStrategy === MatchingStrategy.STARTS_WITH_PER_TERM) {\n      const reqexp = getMatchingStrategyStartsWithPerTermReqexp(pattern);\n      return !!pattern && !!value && !!value.match(reqexp);\n    } else if (this._matchingStrategy === MatchingStrategy.STARTS_WITH) {\n      return !!pattern && !!value && value.toString().toLowerCase().startsWith(pattern.toLowerCase());\n    } else if (this._matchingStrategy === MatchingStrategy.CONTAINS) {\n      return !!pattern && !!value && value.toString().toLowerCase().indexOf(pattern) > -1;\n    } else {\n      return !!pattern && !!value && value.toString().toLowerCase() === pattern;\n    }\n  }\n  /** @hidden */\n  hasObjectValue(obj, pattern) {\n    const values = objectValues(obj);\n    const parentObj = objectToName(obj);\n    const length2 = values.filter(value => {\n      if (!value || Array.isArray(value)) {\n        return false;\n      } else if (!isJsObject(value) && !isFunction(value)) {\n        return value.toString().toLowerCase().indexOf(pattern) !== -1;\n      } else if (isJsObject(value) && objectToName(value) !== parentObj) {\n        return this.hasObjectValue(value, pattern);\n      }\n      return false;\n    }).length;\n    return length2 > 0;\n  }\n  /** @hidden */\n  withLimit(data, limit) {\n    if (limit && data.length > limit) {\n      return data.slice(0, limit);\n    }\n    return data;\n  }\n}\nconst applyDatasourceDirective = {\n  directive: DataSourceDirective,\n  inputs: ['dataSource'],\n  outputs: ['dataChanged']\n};\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AbstractDataProvider, BaseDataSource, DataProvider, DataSourceDirective, DataSourceModule, FD_DATA_SOURCE_TRANSFORMER, MatchingStrategy, applyDatasourceDirective, isDataSource };\n//# sourceMappingURL=fundamental-ngx-cdk-data-source.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}