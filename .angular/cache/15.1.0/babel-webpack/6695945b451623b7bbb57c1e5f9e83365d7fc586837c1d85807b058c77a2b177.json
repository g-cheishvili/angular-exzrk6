{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, HostBinding, Input, ContentChild, Injectable, InjectionToken, Inject, Optional, HostListener, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, Output, ContentChildren, ViewChildren, ViewChild, SkipSelf, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i4 from '@fundamental-ngx/core/popover';\nimport { PopoverModule } from '@fundamental-ngx/core/popover';\nimport * as i5 from '@fundamental-ngx/core/button';\nimport { ButtonModule } from '@fundamental-ngx/core/button';\nimport * as i9 from '@fundamental-ngx/i18n';\nimport { I18nModule } from '@fundamental-ngx/i18n';\nimport { TAB, DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';\nimport { Subscription, Subject, skip, filter, distinctUntilChanged, debounceTime, takeUntil, startWith, first, fromEvent } from 'rxjs';\nimport * as i1 from '@fundamental-ngx/cdk/utils';\nimport { resizeObservable, KeyUtil, DestroyedService } from '@fundamental-ngx/cdk/utils';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\n\n/**\n * Directive to hide component without actual destroying of the component instance.\n */\nconst _c0 = [\"itemsWrapper\"];\nconst _c1 = [\"layoutContainer\"];\nconst _c2 = [\"showMoreContainer\"];\nfunction OverflowLayoutComponent_ng_template_0_ng_template_0_Template(rf, ctx) {}\nfunction OverflowLayoutComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, OverflowLayoutComponent_ng_template_0_ng_template_0_Template, 0, 0, \"ng-template\", 8);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(9);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5);\n  }\n}\nfunction OverflowLayoutComponent_ng_container_6_ng_container_2_ng_template_1_Template(rf, ctx) {}\nconst _c3 = function (a0, a1, a2, a3, a4) {\n  return {\n    $implicit: a0,\n    index: a1,\n    first: a2,\n    last: a3,\n    globalIndex: a4\n  };\n};\nfunction OverflowLayoutComponent_ng_container_6_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, OverflowLayoutComponent_ng_container_6_ng_container_2_ng_template_1_Template, 0, 0, \"ng-template\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r8 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", item_r8.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction5(2, _c3, item_r8.hidden, item_r8.index, item_r8.first, item_r8.last, item_r8.globalIndex));\n  }\n}\nfunction OverflowLayoutComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 9);\n    i0.ɵɵtemplate(2, OverflowLayoutComponent_ng_container_6_ng_container_2_Template, 2, 8, \"ng-container\", 10);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r8 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"first\", item_r8.first)(\"last\", item_r8.last)(\"softHidden\", item_r8.softHidden);\n  }\n}\nfunction OverflowLayoutComponent_ng_template_7_ng_template_0_Template(rf, ctx) {}\nfunction OverflowLayoutComponent_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, OverflowLayoutComponent_ng_template_7_ng_template_0_Template, 0, 0, \"ng-template\", 8);\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(9);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5);\n  }\n}\nfunction OverflowLayoutComponent_ng_template_8_ng_template_2_ng_container_7_ng_template_1_Template(rf, ctx) {}\nfunction OverflowLayoutComponent_ng_template_8_ng_template_2_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, OverflowLayoutComponent_ng_template_8_ng_template_2_ng_container_7_ng_template_1_Template, 0, 0, \"ng-template\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r18 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", item_r18.templateRef)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction5(2, _c3, item_r18.hidden, item_r18.index, item_r18.first, item_r18.last, item_r18.globalIndex));\n  }\n}\nconst _c4 = function (a0) {\n  return {\n    count: a0\n  };\n};\nfunction OverflowLayoutComponent_ng_template_8_ng_template_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r21 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"fd-popover\", 15);\n    i0.ɵɵlistener(\"isOpenChange\", function OverflowLayoutComponent_ng_template_8_ng_template_2_Template_fd_popover_isOpenChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r21);\n      const ctx_r20 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r20._onPopoverStateChange($event));\n    });\n    i0.ɵɵelementStart(1, \"fd-popover-control\")(2, \"button\", 16);\n    i0.ɵɵtext(3);\n    i0.ɵɵpipe(4, \"fdTranslate\");\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementStart(5, \"fd-popover-body\")(6, \"div\", 17);\n    i0.ɵɵtemplate(7, OverflowLayoutComponent_ng_template_8_ng_template_2_ng_container_7_Template, 2, 8, \"ng-container\", 18);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r15 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"focusTrapped\", true)(\"focusAutoCapture\", true)(\"maxWidth\", 312);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"fdMenu\", true);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind2(4, 7, \"coreOverflowLayout.moreItemsButton\", i0.ɵɵpureFunction1(10, _c4, ctx_r15._hiddenItems.length)), \" \");\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"items\", ctx_r15._hiddenItems);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r15._hiddenItems);\n  }\n}\nfunction OverflowLayoutComponent_ng_template_8_ng_template_4_Template(rf, ctx) {}\nconst _c5 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\nfunction OverflowLayoutComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12, 13);\n    i0.ɵɵtemplate(2, OverflowLayoutComponent_ng_template_8_ng_template_2_Template, 8, 12, \"ng-template\", null, 14, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(4, OverflowLayoutComponent_ng_template_8_ng_template_4_Template, 0, 0, \"ng-template\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const _r14 = i0.ɵɵreference(3);\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"display\", ctx_r6._showMore ? \"block\" : \"none\");\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", (ctx_r6._moreButton == null ? null : ctx_r6._moreButton.templateRef) || _r14)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(4, _c5, ctx_r6._hiddenItems));\n  }\n}\nlet OverflowItemContainerRefDirective = /*#__PURE__*/(() => {\n  class OverflowItemContainerRefDirective {\n    /**\n     * Shows or hides element without destroying the view itself.\n     * @param value\n     */\n    set hidden(value) {\n      if (this._hidden === value) {\n        return;\n      }\n      this._hidden = value;\n      if (value && !this._detached) {\n        this._viewRef = this._viewContainerRef.detach();\n        this._detached = true;\n      } else if (!value && this._viewRef && !this._viewRef.destroyed && this._detached) {\n        this._viewRef = this._viewContainerRef.insert(this._viewRef);\n        this._detached = false;\n      }\n    }\n    /** @hidden */\n    constructor(_templateRef, _viewContainerRef, _elmRef) {\n      this._templateRef = _templateRef;\n      this._viewContainerRef = _viewContainerRef;\n      this._elmRef = _elmRef;\n      /** @hidden */\n      this._detached = false;\n      /** @hidden */\n      this._hidden = false;\n      // Create embedded view right away and manipulate its visibility later.\n      this._viewContainerRef.createEmbeddedView(this._templateRef);\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._viewRef?.destroy();\n    }\n  }\n  OverflowItemContainerRefDirective.ɵfac = function OverflowItemContainerRefDirective_Factory(t) {\n    return new (t || OverflowItemContainerRefDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  OverflowItemContainerRefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowItemContainerRefDirective,\n    selectors: [[\"\", \"fdOverflowItemContainerRef\", \"\"]]\n  });\n  return OverflowItemContainerRefDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OverflowLayoutItemContainerDirective = /*#__PURE__*/(() => {\n  class OverflowLayoutItemContainerDirective {\n    /** @hidden */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      /** @hidden */\n      this._initialClass = 'fd-overflow-layout__item';\n      /**\n       * Whether this item is the first one in the array.\n       */\n      this.last = false;\n      /**\n       * Whether this item is the last one in the array.\n       */\n      this.first = false;\n      /**\n       * Whether this item is softly hidden. Used during free space calculation without flickering of the items.\n       */\n      this.softHidden = true;\n    }\n  }\n  OverflowLayoutItemContainerDirective.ɵfac = function OverflowLayoutItemContainerDirective_Factory(t) {\n    return new (t || OverflowLayoutItemContainerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  OverflowLayoutItemContainerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowLayoutItemContainerDirective,\n    selectors: [[\"\", \"fdOverflowLayoutItemContainer\", \"\"]],\n    contentQueries: function OverflowLayoutItemContainerDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, OverflowItemContainerRefDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.containerRef = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function OverflowLayoutItemContainerDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx._initialClass);\n        i0.ɵɵclassProp(\"fd-overflow-layout__item--last\", ctx.last)(\"fd-overflow-layout__item--first\", ctx.first)(\"fd-overflow-layout__item--soft-hidden\", ctx.softHidden);\n      }\n    },\n    inputs: {\n      last: \"last\",\n      first: \"first\",\n      softHidden: \"softHidden\"\n    }\n  });\n  return OverflowLayoutItemContainerDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass OverflowLayoutListeningResult {\n  constructor() {\n    /** Whether to show more button */\n    this.showMore = false;\n    /** Overflow item s */\n    this.items = [];\n    /** Hidden overflow items */\n    this.hiddenItems = [];\n    /** Visible overflow items */\n    this.visibleItems = [];\n  }\n}\nlet OverflowLayoutService = /*#__PURE__*/(() => {\n  class OverflowLayoutService {\n    /**\n     * Observable which emits when changes detection is required.\n     */\n    get detectChanges() {\n      return this._detectChanges$.asObservable();\n    }\n    /**\n     * Observable which emits when new calculation result is available.\n     */\n    get onResult() {\n      return this._result$.asObservable();\n    }\n    /** @hidden */\n    constructor(_elRef) {\n      this._elRef = _elRef;\n      /**\n       * Overflow Layout calculation result.\n       */\n      this.result = new OverflowLayoutListeningResult();\n      /** @hidden */\n      this._listenToItemResize = true;\n      /** @hidden */\n      this._subscription = new Subscription();\n      /** @hidden */\n      this._allItems = [];\n      /** @hidden */\n      this._hiddenItems = [];\n      /** @hidden */\n      this._detectChanges$ = new Subject();\n      /** @hidden */\n      this._result$ = new Subject();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscription.unsubscribe();\n    }\n    /** @hidden */\n    startListening(config) {\n      this.setConfig(config);\n      this.fitVisibleItems();\n      this._listenToSizeChanges(this._elRef.nativeElement, this.config.itemsWrapper);\n    }\n    /** @hidden */\n    setConfig(config) {\n      this.config = config;\n    }\n    /** @hidden */\n    _emitResult() {\n      this._result$.next(this.result);\n    }\n    /** @hidden */\n    _listenToSizeChanges(...elements) {\n      elements.forEach(element => this._subscription.add(resizeObservable(element).pipe(skip(1), filter(() => this._listenToItemResize), distinctUntilChanged(), debounceTime(30)).subscribe(() => {\n        setTimeout(() => {\n          this.fitVisibleItems();\n        });\n      })));\n    }\n    /**\n     * Calculates available space for items and hides items that are not fitting into the container.\n     */\n    fitVisibleItems() {\n      this._listenToItemResize = false;\n      this._allItems = this.config.items;\n      let allItems = [...this.config.items];\n      let visibleContainerItems = [...this.config.visibleItems];\n      this._elRef.nativeElement.style.height = `${this._elRef.nativeElement.clientHeight}px`;\n      allItems.forEach((item, index) => {\n        // Softly hide previously completely hidden item in order to correctly calculate it's size.\n        item.softHidden = true;\n        item.hidden = false;\n        item.index = index;\n        item.first = index === 0;\n        item.last = index === allItems.length - 1;\n        item.globalIndex = index;\n        visibleContainerItems[index].containerRef.hidden = false;\n      });\n      this._detectChanges$.next();\n      allItems = this.config.direction === 'right' ? allItems : allItems.reverse();\n      visibleContainerItems = this.config.direction === 'right' ? visibleContainerItems : visibleContainerItems.reverse();\n      this.result.showMore = false;\n      this._emitResult();\n      const containerWidth = this._elRef.nativeElement.getBoundingClientRect().width;\n      const itemsContainerWidth = allItems.reduce((total, item) => total + (this._getElementWidth(item.elementRef.nativeElement) || 0), 0);\n      if (containerWidth >= itemsContainerWidth && this.config.visibleItems.length <= this.config.maxVisibleItems && this._hiddenItems.length === 0) {\n        // Make all items fully visible.\n        allItems.forEach(item => {\n          item.softHidden = false;\n        });\n        this.result.showMore = false;\n        this.result.hiddenItems = this._hiddenItems;\n        this._emitResult();\n        this._listenToItemResize = true;\n        this._elRef.nativeElement.style.height = '';\n        return;\n      }\n      this.result.showMore = true;\n      this._emitResult();\n      let fittingElmCount = 0;\n      let fittingElmsWidth = 0;\n      let shouldHideItems = false;\n      const showMoreContainerWidth = Math.ceil(this._getElementWidth(this.config.showMoreContainer));\n      let layoutWidth = containerWidth - showMoreContainerWidth;\n      // Try to find all forced visible items\n      const forcedItemsIndexes = this._getForcedItemsIndexes();\n      forcedItemsIndexes.forEach(itemIndex => {\n        const container = this.config.visibleItems[itemIndex];\n        if (!container) {\n          return;\n        }\n        const elementSize = this._getElementWidth(container.elementRef.nativeElement);\n        layoutWidth -= elementSize;\n      });\n      const maxVisibleItems = this.config.maxVisibleItems - forcedItemsIndexes.filter(index => index >= this.config.maxVisibleItems).length;\n      if (layoutWidth < 0 && forcedItemsIndexes.length > 0) {\n        console.warn('There is no enough space to fit all forced visible items into the container. Please adjust their visibility accordingly.');\n      }\n      this._detectChanges$.next();\n      visibleContainerItems.forEach((item, index) => {\n        const itemRef = allItems[index];\n        if (shouldHideItems && !itemRef.overflowItem.forceVisibility) {\n          item.containerRef.hidden = true;\n          item.softHidden = false;\n          itemRef.hidden = true;\n          return;\n        }\n        const elementSize = this._getElementWidth(item.elementRef.nativeElement);\n        const combinedWidth = fittingElmsWidth + elementSize;\n        const condition = (combinedWidth <= layoutWidth || item === this.config.visibleItems[this.config.visibleItems.length - 1] && combinedWidth <= layoutWidth + showMoreContainerWidth) && fittingElmCount < maxVisibleItems;\n        if (condition) {\n          fittingElmsWidth += elementSize;\n          fittingElmCount++;\n        } else if (!itemRef.overflowItem.forceVisibility) {\n          shouldHideItems = true;\n          item.softHidden = false;\n          item.containerRef.hidden = true;\n          itemRef.hidden = true;\n        }\n      });\n      // Reverse original order back.\n      allItems = this.config.direction === 'right' ? allItems : allItems.reverse();\n      allItems.forEach(item => {\n        item.softHidden = false;\n      });\n      let hiddenItems = allItems.filter(i => i.hidden);\n      hiddenItems = this.config.reverseHiddenItems ? hiddenItems.reverse() : hiddenItems;\n      const visibleItems = allItems.filter(i => !i.hidden);\n      visibleItems.forEach((item, index) => {\n        item.index = index;\n        item.first = index === 0;\n        item.last = index === visibleItems.length - 1;\n      });\n      this._hiddenItems = hiddenItems.map((item, index) => {\n        item.first = index === 0;\n        item.last = index === hiddenItems.length - 1;\n        item.index = index;\n        return item;\n      });\n      this.result.showMore = this._hiddenItems.length > 0;\n      this.result.hiddenItems = this._hiddenItems;\n      this._emitResult();\n      this._elRef.nativeElement.style.height = '';\n      this._listenToItemResize = true;\n    }\n    /** @hidden */\n    _getForcedItemsIndexes() {\n      return this._allItems.map((item, index) => item.overflowItem.forceVisibility ? index : -1).filter(i => i > -1);\n    }\n    /**\n     * @hidden\n     * Returns combined width of the element including margins.\n     * @param element Element to calculate width of.\n     */\n    _getElementWidth(element) {\n      const elementStyle = getComputedStyle(element);\n      const elementWidth = element.getBoundingClientRect().width;\n      const elementSize = elementWidth + parseFloat(elementStyle.marginLeft) + parseFloat(elementStyle.marginRight);\n      return Math.ceil(elementSize);\n    }\n  }\n  OverflowLayoutService.ɵfac = function OverflowLayoutService_Factory(t) {\n    return new (t || OverflowLayoutService)(i0.ɵɵinject(i0.ElementRef));\n  };\n  OverflowLayoutService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: OverflowLayoutService,\n    factory: OverflowLayoutService.ɵfac\n  });\n  return OverflowLayoutService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FD_OVERFLOW_CONTAINER = new InjectionToken('FdOverflowContainer');\nconst FD_OVERFLOW_EXPAND = new InjectionToken('FdOverflowLayoutExpand');\nconst FD_OVERFLOW_FOCUSABLE_ITEM = new InjectionToken('FdOverflowLayoutFocusableItem');\nconst FD_OVERFLOW_ITEM_REF = new InjectionToken('OverflowLayoutItemRef');\n\n/**\n * Directive to wrap Overlay Layout \"More\" popover content.\n * Used to apply keyboard navigation through the items.\n */\nlet OverflowLayoutPopoverContentDirective = /*#__PURE__*/(() => {\n  class OverflowLayoutPopoverContentDirective {\n    /**\n     * Array of hidden items.\n     */\n    set items(value) {\n      // Need to set items with a delay so that elementRef of the focusable item would refresh.\n      setTimeout(() => {\n        this._items = value;\n        this._keyboardEventsManager?.destroy();\n        this._keyboardEventsManager = new FocusKeyManager(this._items.filter(item => item.overflowItem.focusableItem?.focusable).map(item => item.overflowItem.focusableItem)).withWrap().withHorizontalOrientation(this._dir);\n      });\n    }\n    /** @hidden */\n    constructor(_overflowContainer, _rtl, _onDestroy$) {\n      this._overflowContainer = _overflowContainer;\n      this._rtl = _rtl;\n      this._onDestroy$ = _onDestroy$;\n      /** @hidden */\n      this._initialClass = 'fd-overflow-layout__popover-container';\n      /** @hidden */\n      this._dir = 'ltr';\n      this._overflowContainer?.registerPopoverContent(this);\n      this._rtl?.rtl.pipe(takeUntil(this._onDestroy$)).subscribe(rtl => {\n        this._dir = rtl ? 'rtl' : 'ltr';\n        if (this._keyboardEventsManager) {\n          this._keyboardEventsManager = this._keyboardEventsManager.withHorizontalOrientation(this._dir);\n        }\n      });\n    }\n    /** @hidden */\n    keyUpHandler(event) {\n      if (KeyUtil.isKeyCode(event, TAB)) {\n        const index = this._items.findIndex(item => item.overflowItem.elmRef.nativeElement === event.target);\n        if (index !== -1) {\n          this._keyboardEventsManager.setActiveItem(index);\n        }\n      }\n      if (KeyUtil.isKeyCode(event, [DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW])) {\n        event.preventDefault();\n        // passing the event to key manager, so we get a change fired\n        this._keyboardEventsManager.onKeydown(event);\n      }\n    }\n    /**\n     * Focuses on the first tabbable element inside directive's element.\n     */\n    focusFirstTabbableElement() {\n      this._keyboardEventsManager.setActiveItem(0);\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._keyboardEventsManager?.destroy();\n    }\n  }\n  OverflowLayoutPopoverContentDirective.ɵfac = function OverflowLayoutPopoverContentDirective_Factory(t) {\n    return new (t || OverflowLayoutPopoverContentDirective)(i0.ɵɵdirectiveInject(FD_OVERFLOW_CONTAINER), i0.ɵɵdirectiveInject(i1.RtlService, 8), i0.ɵɵdirectiveInject(i1.DestroyedService));\n  };\n  OverflowLayoutPopoverContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowLayoutPopoverContentDirective,\n    selectors: [[\"\", \"fdOverflowLayoutPopoverContent\", \"\"]],\n    hostVars: 2,\n    hostBindings: function OverflowLayoutPopoverContentDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keyup\", function OverflowLayoutPopoverContentDirective_keyup_HostBindingHandler($event) {\n          return ctx.keyUpHandler($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx._initialClass);\n      }\n    },\n    inputs: {\n      items: \"items\"\n    },\n    features: [i0.ɵɵProvidersFeature([DestroyedService])]\n  });\n  return OverflowLayoutPopoverContentDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OverflowLayoutComponent = /*#__PURE__*/(() => {\n  class OverflowLayoutComponent {\n    /**\n     * Maximum amount of visible items.\n     */\n    set maxVisibleItems(value) {\n      if (value === this._maxVisibleItems) {\n        return;\n      }\n      this._maxVisibleItems = value;\n      this.triggerRecalculation();\n    }\n    get maxVisibleItems() {\n      return this._maxVisibleItems;\n    }\n    /** @hidden */\n    get _config() {\n      return {\n        visibleItems: this._visibleItems.toArray(),\n        items: this._items.toArray(),\n        focusableItems: this._focusableOverflowItems.toArray(),\n        itemsWrapper: this._itemsWrapper.nativeElement,\n        showMoreContainer: this._showMoreContainer.nativeElement,\n        layoutContainerElement: this._layoutContainer.nativeElement,\n        maxVisibleItems: this.maxVisibleItems,\n        direction: this.showMorePosition,\n        enableKeyboardNavigation: this.enableKeyboardNavigation,\n        reverseHiddenItems: this.reverseHiddenItems\n      };\n    }\n    /** @hidden */\n    constructor(_elementRef, _ngZone, _cdr, _overflowLayoutService, _rtl) {\n      this._elementRef = _elementRef;\n      this._ngZone = _ngZone;\n      this._cdr = _cdr;\n      this._overflowLayoutService = _overflowLayoutService;\n      this._rtl = _rtl;\n      /**\n       * Keyboard event to listen for keyboard navigation through items.\n       */\n      this.navigationTrigger = 'keyup';\n      /** Direction of the fitting items calculation. */\n      this.showMorePosition = 'right';\n      /** Whether to render hidden items in reverse order. */\n      this.reverseHiddenItems = false;\n      /** Whether to enable keyboard navigation. */\n      this.enableKeyboardNavigation = true;\n      /**\n       * Event, triggered when amount of visible items has been changed.\n       */\n      this.visibleItemsCount = new EventEmitter();\n      /**\n       * Event, triggered when amount of hidden items has been changed.\n       */\n      this.hiddenItemsCount = new EventEmitter();\n      /** @hidden */\n      this._allItems = [];\n      /** @hidden */\n      this._hiddenItems = [];\n      /** @hidden */\n      this._showMore = false;\n      /** @hidden */\n      this._initialClass = 'fd-overflow-layout';\n      /** @hidden */\n      this._subscription = new Subscription();\n      /** @hidden */\n      this._fillTrigger$ = new Subject();\n      /** @hidden */\n      this._maxVisibleItems = Infinity;\n      /** @hidden */\n      this._canListenToResize = false;\n      /** @hidden */\n      this._dir = 'ltr';\n      /** Overflow Layout more button text */\n      this.moreItemsButtonText = count => `${count} more`;\n      this._subscription.add(this._fillTrigger$.pipe(debounceTime(30)).subscribe(() => {\n        this._overflowLayoutService.setConfig(this._config);\n        this._overflowLayoutService.fitVisibleItems();\n      }));\n    }\n    /** @hidden */\n    ngOnInit() {\n      this._setupKeyboardListener();\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._subscription.add(this._overflowLayoutService.detectChanges.subscribe(() => {\n        this._cdr.detectChanges();\n      }));\n      this._subscription.add(this._overflowLayoutService.onResult.subscribe(result => {\n        this._hiddenItems = result.hiddenItems;\n        this._showMore = result.showMore;\n        this.hiddenItemsCount.emit(result.hiddenItems.length);\n        this.visibleItemsCount.emit(this._allItems.filter(i => !i.hidden).length);\n        this._cdr.detectChanges();\n      }));\n      this._subscription.add(this._items.changes.pipe(startWith(() => this._items)).subscribe(() => {\n        this._allItems = this._items.toArray();\n        this._cdr.detectChanges();\n        this._overflowLayoutService.setConfig(this._config);\n        this._overflowLayoutService.fitVisibleItems();\n      }));\n      this._setFocusKeyManager();\n      this._subscribeToRtl();\n      // There might be cases when the elements are not rendered yet, but the component is initialized already.\n      // It may happen when it's inside the components that are wrapping ng-content with ng-containers and so on.\n      // IntersectionObserver is a good solution for this case, but it's hardly manageable when testing.\n      this._ngZone.onStable.pipe(first()).subscribe(() => {\n        this._overflowLayoutService.startListening(this._config);\n        this._canListenToResize = true;\n      });\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscription.unsubscribe();\n      this._keyboardEventsManager?.destroy();\n      this._keyboardEventsManager = null;\n    }\n    /**\n     * Triggers layout recalculation of the items.\n     */\n    triggerRecalculation() {\n      if (!this._canListenToResize) {\n        return;\n      }\n      this._fillTrigger$.next();\n    }\n    /**\n     * Sets current focused element.\n     * @param element Element that needs to be focused.\n     */\n    setFocusedElement(element) {\n      const index = this._focusableOverflowItems.toArray().findIndex(item => item === element);\n      if (index !== -1) {\n        this._keyboardEventsManager?.setActiveItem(index);\n      }\n    }\n    /**\n     * Registers popover content directive for main component.\n     * @param content {OverflowPopoverContent} directive\n     */\n    registerPopoverContent(content) {\n      this._overflowPopoverContent = content;\n    }\n    /** @hidden */\n    _itemsTrackFn(_, item) {\n      return item.templateRef;\n    }\n    /** @hidden */\n    _onPopoverStateChange(opened) {\n      if (opened) {\n        this._overflowPopoverContent?.focusFirstTabbableElement();\n      }\n    }\n    /** @hidden */\n    _setupKeyboardListener() {\n      this._subscription.add(fromEvent(this._elementRef.nativeElement, this.navigationTrigger).pipe(filter(() => this.enableKeyboardNavigation)).subscribe(event => {\n        if (KeyUtil.isKeyCode(event, TAB)) {\n          const index = this._focusableOverflowItems.toArray().findIndex(item => item.focusable && item.elementRef.nativeElement === event.target);\n          if (index !== -1) {\n            this._keyboardEventsManager?.setActiveItem(index);\n          }\n        }\n        if (KeyUtil.isKeyCode(event, [DOWN_ARROW, UP_ARROW, LEFT_ARROW, RIGHT_ARROW])) {\n          event.preventDefault();\n          // passing the event to key manager so, we get a change fired\n          this._keyboardEventsManager?.onKeydown(event);\n        }\n      }));\n    }\n    /** @hidden */\n    _setFocusKeyManager() {\n      if (!this.enableKeyboardNavigation) {\n        return;\n      }\n      this._dir = this._rtl?.rtl.value ? 'rtl' : 'ltr';\n      this._keyboardEventsManager?.destroy();\n      this._keyboardEventsManager = new FocusKeyManager(this._focusableOverflowItems).withWrap().withHorizontalOrientation(this._dir).withVerticalOrientation().skipPredicate(item => !item.navigable || item.hidden);\n    }\n    /** @hidden Rtl change subscription */\n    _subscribeToRtl() {\n      if (!this._rtl || !this.enableKeyboardNavigation) {\n        return;\n      }\n      this._subscription.add(this._rtl.rtl.subscribe(isRtl => {\n        this._dir = isRtl ? 'rtl' : 'ltr';\n        this._keyboardEventsManager = this._keyboardEventsManager?.withHorizontalOrientation(this._dir);\n      }));\n    }\n  }\n  OverflowLayoutComponent.ɵfac = function OverflowLayoutComponent_Factory(t) {\n    return new (t || OverflowLayoutComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(OverflowLayoutService), i0.ɵɵdirectiveInject(i1.RtlService, 8));\n  };\n  OverflowLayoutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: OverflowLayoutComponent,\n    selectors: [[\"fd-overflow-layout\"]],\n    contentQueries: function OverflowLayoutComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FD_OVERFLOW_EXPAND, 5);\n        i0.ɵɵcontentQuery(dirIndex, FD_OVERFLOW_ITEM_REF, 5);\n        i0.ɵɵcontentQuery(dirIndex, FD_OVERFLOW_FOCUSABLE_ITEM, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._moreButton = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._items = _t);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._focusableOverflowItems = _t);\n      }\n    },\n    viewQuery: function OverflowLayoutComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_c2, 5);\n        i0.ɵɵviewQuery(OverflowLayoutItemContainerDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._itemsWrapper = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._layoutContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._showMoreContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._visibleItems = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function OverflowLayoutComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx._initialClass);\n      }\n    },\n    inputs: {\n      maxVisibleItems: \"maxVisibleItems\",\n      navigationTrigger: \"navigationTrigger\",\n      showMorePosition: \"showMorePosition\",\n      reverseHiddenItems: \"reverseHiddenItems\",\n      enableKeyboardNavigation: \"enableKeyboardNavigation\",\n      moreItemsButtonText: \"moreItemsButtonText\"\n    },\n    outputs: {\n      visibleItemsCount: \"visibleItemsCount\",\n      hiddenItemsCount: \"hiddenItemsCount\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_OVERFLOW_CONTAINER,\n      useExisting: OverflowLayoutComponent\n    }, OverflowLayoutService])],\n    decls: 10,\n    vars: 4,\n    consts: [[3, \"ngIf\"], [1, \"fd-overflow-layout__items-container\"], [\"layoutContainer\", \"\"], [1, \"fd-overflow-layout__items-wrapper\"], [1, \"fd-overflow-layout__items\"], [\"itemsWrapper\", \"\"], [4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [\"showMore\", \"\"], [3, \"ngTemplateOutlet\"], [\"fdOverflowLayoutItemContainer\", \"\", 3, \"first\", \"last\", \"softHidden\"], [4, \"fdOverflowItemContainerRef\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"fd-overflow-layout__more\"], [\"showMoreContainer\", \"\"], [\"defaultShowMore\", \"\"], [\"placement\", \"bottom\", 3, \"focusTrapped\", \"focusAutoCapture\", \"maxWidth\", \"isOpenChange\"], [\"fd-button\", \"\", \"fdType\", \"transparent\", 3, \"fdMenu\"], [\"fdOverflowLayoutPopoverContent\", \"\", 3, \"items\"], [4, \"ngFor\", \"ngForOf\"]],\n    template: function OverflowLayoutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, OverflowLayoutComponent_ng_template_0_Template, 1, 1, \"ng-template\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1, 2)(3, \"div\", 3)(4, \"div\", 4, 5);\n        i0.ɵɵtemplate(6, OverflowLayoutComponent_ng_container_6_Template, 3, 3, \"ng-container\", 6);\n        i0.ɵɵelementEnd()()();\n        i0.ɵɵtemplate(7, OverflowLayoutComponent_ng_template_7_Template, 1, 1, \"ng-template\", 0);\n        i0.ɵɵtemplate(8, OverflowLayoutComponent_ng_template_8_Template, 5, 6, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.showMorePosition === \"left\");\n        i0.ɵɵadvance(6);\n        i0.ɵɵproperty(\"ngForOf\", ctx._allItems)(\"ngForTrackBy\", ctx._itemsTrackFn);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.showMorePosition === \"right\");\n      }\n    },\n    dependencies: [i3.NgForOf, i3.NgIf, i3.NgTemplateOutlet, i4.PopoverControlComponent, i4.PopoverBodyComponent, i4.PopoverComponent, i5.ButtonComponent, OverflowItemContainerRefDirective, OverflowLayoutPopoverContentDirective, OverflowLayoutItemContainerDirective, i9.FdTranslatePipe],\n    styles: [\".fd-overflow-layout{font-size:var(--sapFontSize);line-height:var(--sapContent_LineHeight);color:var(--sapTextColor);font-family:var(--sapFontFamily);font-weight:400;box-sizing:border-box;padding:0;margin:0;border:0;display:flex;align-items:center;width:100%;justify-content:space-between}.fd-overflow-layout:before,.fd-overflow-layout:after{box-sizing:inherit;font-size:inherit}.fd-overflow-layout__items{font-size:var(--sapFontSize);line-height:var(--sapContent_LineHeight);color:var(--sapTextColor);font-family:var(--sapFontFamily);font-weight:400;box-sizing:border-box;padding:0;margin:0;border:0;display:flex;align-items:center;display:inline-flex}.fd-overflow-layout__items:before,.fd-overflow-layout__items:after{box-sizing:inherit;font-size:inherit}.fd-overflow-layout__more{font-size:var(--sapFontSize);line-height:var(--sapContent_LineHeight);color:var(--sapTextColor);font-family:var(--sapFontFamily);font-weight:400;box-sizing:border-box;padding:0;margin:0;border:0;display:flex;align-items:center;flex-shrink:0}.fd-overflow-layout__more:before,.fd-overflow-layout__more:after{box-sizing:inherit;font-size:inherit}.fd-overflow-layout__items-container{font-size:var(--sapFontSize);line-height:var(--sapContent_LineHeight);color:var(--sapTextColor);font-family:var(--sapFontFamily);font-weight:400;box-sizing:border-box;padding:0;margin:0;border:0;position:relative}.fd-overflow-layout__items-container:before,.fd-overflow-layout__items-container:after{box-sizing:inherit;font-size:inherit}.fd-overflow-layout__items-wrapper{display:inline-flex}.fd-overflow-layout__popover-container{font-size:var(--sapFontSize);line-height:var(--sapContent_LineHeight);color:var(--sapTextColor);font-family:var(--sapFontFamily);font-weight:400;box-sizing:border-box;padding:0;margin:0;border:0;display:block;white-space:normal}.fd-overflow-layout__popover-container:before,.fd-overflow-layout__popover-container:after{box-sizing:inherit;font-size:inherit}.fd-overflow-layout__item--soft-hidden{opacity:0!important;position:absolute!important}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return OverflowLayoutComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Structural directive which is used to pass the context of the item to the template engine.\n */\nlet OverflowItemRefDirective = /*#__PURE__*/(() => {\n  class OverflowItemRefDirective {\n    /**\n     * Whether the item is hidden.\n     */\n    set hidden(value) {\n      this._hidden = value;\n      this.overflowItem.hiddenChange.emit(value);\n    }\n    get hidden() {\n      return this._hidden;\n    }\n    /** @hidden */\n    static ngTemplateContextGuard(dir, ctx) {\n      return true;\n    }\n    /** @hidden */\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n      /** @hidden */\n      this._hidden = false;\n      /** Whether the item is softly hidden. */\n      this.softHidden = true;\n    }\n    /**\n     * Sets the element reference of the `fdOverflowLayoutItem` directive.`\n     * @param elmRef\n     */\n    setElementRef(elmRef) {\n      if (this.elementRef) {\n        return;\n      }\n      this.elementRef = elmRef;\n    }\n    /**\n     * Sets the `fdOverflowLayoutItem` directive.\n     * @param item\n     */\n    setOverflowItem(item) {\n      this.overflowItem = item;\n    }\n  }\n  OverflowItemRefDirective.ɵfac = function OverflowItemRefDirective_Factory(t) {\n    return new (t || OverflowItemRefDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  OverflowItemRefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowItemRefDirective,\n    selectors: [[\"\", \"fdOverflowItemRef\", \"\"]],\n    inputs: {\n      item: [\"fdOverflowItemRef\", \"item\"]\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_OVERFLOW_ITEM_REF,\n      useExisting: OverflowItemRefDirective\n    }])]\n  });\n  return OverflowItemRefDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Structural directive which is responsible for rendering the \"More\" button and handling further logic.\n */\nlet OverflowExpandDirective = /*#__PURE__*/(() => {\n  class OverflowExpandDirective {\n    /** @hidden */\n    static ngTemplateContextGuard(dir, ctx) {\n      return true;\n    }\n    /** @hidden */\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n  }\n  OverflowExpandDirective.ɵfac = function OverflowExpandDirective_Factory(t) {\n    return new (t || OverflowExpandDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  OverflowExpandDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowExpandDirective,\n    selectors: [[\"\", \"fdOverflowExpand\", \"\"]],\n    inputs: {\n      fdOverflowExpandItems: \"fdOverflowExpandItems\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_OVERFLOW_EXPAND,\n      useExisting: OverflowExpandDirective\n    }])]\n  });\n  return OverflowExpandDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FD_OVERFLOW_ITEM = new InjectionToken('FdOverflowItem');\n\n/**\n * Directive to mark element as part of for Overflow Layout Component items.\n */\nlet OverflowLayoutItemDirective = /*#__PURE__*/(() => {\n  class OverflowLayoutItemDirective {\n    /** Whether to force the visibility of the item. */\n    set forceVisibility(value) {\n      if (value === this._forceVisibility) {\n        return;\n      }\n      this._forceVisibility = value;\n      this._overflowContainer.triggerRecalculation();\n    }\n    get forceVisibility() {\n      return this._forceVisibility;\n    }\n    /**\n     * Whether the item is hidden.\n     */\n    set hidden(value) {\n      this.hiddenChange.emit(value);\n    }\n    get hidden() {\n      return this._overflowItemRef?.hidden === true;\n    }\n    /** @hidden */\n    constructor(_overflowContainer, elmRef, _overflowItemRef) {\n      this._overflowContainer = _overflowContainer;\n      this.elmRef = elmRef;\n      this._overflowItemRef = _overflowItemRef;\n      /**\n       * Event emitted when `hidden` property has been changed.\n       */\n      this.hiddenChange = new EventEmitter();\n      /** @hidden */\n      this._forceVisibility = false;\n    }\n    /** @hidden */\n    ngOnInit() {\n      this._overflowItemRef?.setElementRef(this.elmRef);\n      this._overflowItemRef?.setOverflowItem(this);\n    }\n  }\n  OverflowLayoutItemDirective.ɵfac = function OverflowLayoutItemDirective_Factory(t) {\n    return new (t || OverflowLayoutItemDirective)(i0.ɵɵdirectiveInject(OverflowLayoutComponent), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(FD_OVERFLOW_ITEM_REF, 12));\n  };\n  OverflowLayoutItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowLayoutItemDirective,\n    selectors: [[\"\", \"fdOverflowLayoutItem\", \"\"]],\n    inputs: {\n      forceVisibility: \"forceVisibility\"\n    },\n    outputs: {\n      hiddenChange: \"hiddenChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_OVERFLOW_ITEM,\n      useExisting: OverflowLayoutItemDirective\n    }])]\n  });\n  return OverflowLayoutItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OverflowLayoutFocusableItemDirective = /*#__PURE__*/(() => {\n  class OverflowLayoutFocusableItemDirective {\n    /** @hidden */\n    get _tabindex() {\n      return this.focusable ? 0 : -1;\n    }\n    /** Whether the item is hidden. */\n    get hidden() {\n      return !!this._overflowItem?.hidden;\n    }\n    /** @hidden */\n    _onFocus() {\n      this._overflowContainer.setFocusedElement(this);\n    }\n    /** @hidden */\n    constructor(_overflowContainer, _overflowItem, elementRef) {\n      this._overflowContainer = _overflowContainer;\n      this._overflowItem = _overflowItem;\n      this.elementRef = elementRef;\n      /** Whether the item should be focusable. */\n      this.focusable = true;\n      /** Whether the item should be navigable via keyboard. */\n      this.navigable = true;\n    }\n    /** @hidden */\n    ngOnInit() {\n      if (this._overflowItem) {\n        this._overflowItem.focusableItem = this;\n      }\n    }\n    /** @hidden */\n    focus() {\n      this.elementRef.nativeElement.focus();\n    }\n  }\n  OverflowLayoutFocusableItemDirective.ɵfac = function OverflowLayoutFocusableItemDirective_Factory(t) {\n    return new (t || OverflowLayoutFocusableItemDirective)(i0.ɵɵdirectiveInject(OverflowLayoutComponent), i0.ɵɵdirectiveInject(FD_OVERFLOW_ITEM, 8), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  OverflowLayoutFocusableItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowLayoutFocusableItemDirective,\n    selectors: [[\"\", \"fdOverflowLayoutFocusableItem\", \"\"], [\"\", \"fdOverflowLayoutItem\", \"\", \"focusable\", \"\"]],\n    hostVars: 1,\n    hostBindings: function OverflowLayoutFocusableItemDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function OverflowLayoutFocusableItemDirective_focus_HostBindingHandler() {\n          return ctx._onFocus();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx._tabindex);\n      }\n    },\n    inputs: {\n      focusable: \"focusable\",\n      navigable: \"navigable\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_OVERFLOW_FOCUSABLE_ITEM,\n      useExisting: OverflowLayoutFocusableItemDirective\n    }])]\n  });\n  return OverflowLayoutFocusableItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OverflowLayoutModule = /*#__PURE__*/(() => {\n  class OverflowLayoutModule {}\n  OverflowLayoutModule.ɵfac = function OverflowLayoutModule_Factory(t) {\n    return new (t || OverflowLayoutModule)();\n  };\n  OverflowLayoutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OverflowLayoutModule\n  });\n  OverflowLayoutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, PopoverModule, ButtonModule, I18nModule]\n  });\n  return OverflowLayoutModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FD_OVERFLOW_CONTAINER, FD_OVERFLOW_EXPAND, FD_OVERFLOW_ITEM, FD_OVERFLOW_ITEM_REF, OverflowExpandDirective, OverflowItemContainerRefDirective, OverflowItemRefDirective, OverflowLayoutComponent, OverflowLayoutFocusableItemDirective, OverflowLayoutItemContainerDirective, OverflowLayoutItemDirective, OverflowLayoutListeningResult, OverflowLayoutModule, OverflowLayoutPopoverContentDirective, OverflowLayoutService };\n//# sourceMappingURL=fundamental-ngx-core-overflow-layout.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}