{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, inject, ViewContainerRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, ViewChild, Output, ElementRef, Optional, Inject, ContentChildren, forwardRef, ContentChild, ViewChildren, HostListener, Directive, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subscription, fromEvent, Subject, BehaviorSubject, startWith, merge } from 'rxjs';\nimport * as i2 from '@fundamental-ngx/cdk/utils';\nimport { DestroyedService, KeyUtil, resizeObservable, applyCssClass } from '@fundamental-ngx/cdk/utils';\nimport { ENTER, SPACE, DELETE, BACKSPACE, LEFT_ARROW, RIGHT_ARROW, A } from '@angular/cdk/keycodes';\nimport * as i1 from '@fundamental-ngx/core/content-density';\nimport { contentDensityObserverProviders, DeprecatedCompactDirective, CONTENT_DENSITY_DIRECTIVE, ContentDensityModule } from '@fundamental-ngx/core/content-density';\nimport { takeUntil, debounceTime, filter, map } from 'rxjs/operators';\nimport * as i3$1 from '@fundamental-ngx/i18n';\nimport { I18nModule } from '@fundamental-ngx/i18n';\nimport { __decorate, __metadata } from 'tslib';\nimport { FormControlComponent } from '@fundamental-ngx/core/form';\nimport * as i4 from '@fundamental-ngx/core/input-group';\nimport { InputGroupModule } from '@fundamental-ngx/core/input-group';\nimport * as i5 from '@fundamental-ngx/core/button';\nimport { ButtonModule } from '@fundamental-ngx/core/button';\nimport * as i6 from '@fundamental-ngx/core/popover';\nimport { PopoverModule } from '@fundamental-ngx/core/popover';\nimport * as i7 from '@fundamental-ngx/core/list';\nimport { ListModule } from '@fundamental-ngx/core/list';\n\n/**\n * A token is used to represent contextualizing information.\n * They can be useful to show applied filters, selected values for form fields or object metadata.\n */\nconst _c0 = [\"tokenWrapperElement\"];\nconst _c1 = [\"content\"];\nconst _c2 = [\"viewContainer\"];\nfunction TokenComponent_span_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r6 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 6);\n    i0.ɵɵlistener(\"click\", function TokenComponent_span_5_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r6);\n      const ctx_r5 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r5.closeClickHandler($event));\n    });\n    i0.ɵɵpipe(1, \"fdTranslate\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵattribute(\"aria-label\", ctx_r2.deleteButtonLabel || i0.ɵɵpipeBind1(1, 1, \"coreToken.deleteButtonLabel\"));\n  }\n}\nfunction TokenComponent_ng_template_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\nconst _c3 = [\"*\"];\nconst _c4 = [\"tokenizerInner\"];\nconst _c5 = [\"moreElementSpan\"];\nconst _c6 = [\"inputGroupAddOn\"];\nfunction TokenizerComponent_ng_container_5_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction TokenizerComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, TokenizerComponent_ng_container_5_ng_container_1_Template, 1, 0, \"ng-container\", 8);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(10);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n  }\n}\nfunction TokenizerComponent_span_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"span\", 9, 10);\n    i0.ɵɵelement(2, \"button\", 11);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"button\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"glyph\", ctx_r2.glyph);\n  }\n}\nfunction TokenizerComponent_ng_template_9_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction TokenizerComponent_ng_template_9_li_5_span_3_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r16 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 18);\n    i0.ɵɵlistener(\"click\", function TokenizerComponent_ng_template_9_li_5_span_3_Template_span_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r16);\n      const token_r11 = i0.ɵɵnextContext().$implicit;\n      return i0.ɵɵresetView(token_r11.closeClickHandler($event));\n    });\n    i0.ɵɵpipe(1, \"fdTranslate\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const token_r11 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵattribute(\"aria-label\", token_r11.deleteButtonLabel || i0.ɵɵpipeBind1(1, 1, \"coreToken.deleteButtonLabel\"));\n  }\n}\nfunction TokenizerComponent_ng_template_9_li_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 15);\n    i0.ɵɵelementContainer(1, null, 16);\n    i0.ɵɵtemplate(3, TokenizerComponent_ng_template_9_li_5_span_3_Template, 2, 3, \"span\", 17);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const token_r11 = ctx.$implicit;\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngIf\", !token_r11.readOnly);\n  }\n}\nfunction TokenizerComponent_ng_template_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"fd-popover\", 12)(1, \"fd-popover-control\");\n    i0.ɵɵtemplate(2, TokenizerComponent_ng_template_9_ng_container_2_Template, 1, 0, \"ng-container\", 8);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"fd-popover-body\")(4, \"ul\", 13);\n    i0.ɵɵtemplate(5, TokenizerComponent_ng_template_9_li_5_Template, 4, 1, \"li\", 14);\n    i0.ɵɵelementEnd()()();\n  }\n  if (rf & 2) {\n    const ctx_r4 = i0.ɵɵnextContext();\n    const _r5 = i0.ɵɵreference(12);\n    i0.ɵɵproperty(\"noArrow\", false)(\"focusTrapped\", true)(\"focusAutoCapture\", true);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5);\n    i0.ɵɵadvance(3);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r4._hiddenTokens);\n  }\n}\nconst _c7 = function (a0) {\n  return {\n    count: a0\n  };\n};\nfunction TokenizerComponent_ng_template_11_span_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"fdTranslate\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r20 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind2(2, 1, \"coreTokenizer.moreLabel\", i0.ɵɵpureFunction1(4, _c7, ctx_r20.moreTokensLeft.length + ctx_r20.moreTokensRight.length)), \" \");\n  }\n}\nfunction TokenizerComponent_ng_template_11_span_0_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵpipe(2, \"fdTranslate\");\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r21 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", i0.ɵɵpipeBind2(2, 1, \"coreTokenizer.moreLabel\", i0.ɵɵpureFunction1(4, _c7, ctx_r21.hiddenCozyTokenCount)), \" \");\n  }\n}\nfunction TokenizerComponent_ng_template_11_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"span\", 20, 21);\n    i0.ɵɵlistener(\"click\", function TokenizerComponent_ng_template_11_span_0_Template_span_click_0_listener() {\n      i0.ɵɵrestoreView(_r23);\n      const ctx_r22 = i0.ɵɵnextContext(2);\n      return i0.ɵɵresetView(ctx_r22.moreClicked());\n    });\n    i0.ɵɵtemplate(2, TokenizerComponent_ng_template_11_span_0_ng_container_2_Template, 3, 6, \"ng-container\", 22);\n    i0.ɵɵpipe(3, \"async\");\n    i0.ɵɵtemplate(4, TokenizerComponent_ng_template_11_span_0_ng_container_4_Template, 3, 6, \"ng-container\", 22);\n    i0.ɵɵpipe(5, \"async\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r18 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(3, 2, ctx_r18._compact$) || ctx_r18.compactCollapse);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", i0.ɵɵpipeBind1(5, 4, ctx_r18._compact$) === false && !ctx_r18.compactCollapse);\n  }\n}\nfunction TokenizerComponent_ng_template_11_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, TokenizerComponent_ng_template_11_span_0_Template, 6, 6, \"span\", 19);\n  }\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r6._showMoreElement);\n  }\n}\nconst _c8 = [[[\"fd-token\"]], [[\"\", \"fd-form-control\", \"\"]]];\nconst _c9 = [\"fd-token\", \"[fd-form-control]\"];\nlet TokenComponent = /*#__PURE__*/(() => {\n  class TokenComponent {\n    /** Whether the token is selected. */\n    set selected(val) {\n      if (this._selected !== val) {\n        this._cdRef.markForCheck();\n      }\n      this._selected = val;\n    }\n    get selected() {\n      return this._selected;\n    }\n    /** @hidden */\n    constructor(elementRef, _cdRef, _contentDensityObserver) {\n      this.elementRef = elementRef;\n      this._cdRef = _cdRef;\n      this._contentDensityObserver = _contentDensityObserver;\n      /** Whether the token is disabled. */\n      this.disabled = false;\n      /** @hidden */\n      this._selected = false;\n      /** @hidden */\n      this._subscriptions = new Subscription();\n      /** Whether the token is read-only. */\n      this.readOnly = false;\n      /** Emitted when the *x* icon is clicked. Specifically, any pseudo-element. */\n      this.onCloseClick = new EventEmitter();\n      /** Emitted when token should be removed */\n      this.onRemove = new EventEmitter();\n      /** Emitted when a token is clicked. */\n      // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n      this.onTokenClick = new EventEmitter();\n      /** Emitted when a there's a keydown registered on the token. */\n      // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n      this.onTokenKeydown = new EventEmitter();\n      /**\n       * Emitted when token element received or lost focus.\n       */\n      this.elementFocused = new EventEmitter();\n      /** @hidden */\n      this._destroy$ = inject(DestroyedService);\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._viewContainer.createEmbeddedView(this._content);\n      fromEvent(this.tokenWrapperElement.nativeElement, 'focus').pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this.elementFocused.emit(true);\n      });\n      fromEvent(this.tokenWrapperElement.nativeElement, 'blur').pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this.elementFocused.emit(false);\n      });\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscriptions.unsubscribe();\n    }\n    /** @hidden */\n    closeClickHandler(event) {\n      if (event) {\n        event.stopPropagation();\n        if (!this.disabled) {\n          this.onCloseClick.emit(event);\n        }\n      }\n    }\n    /** @hidden */\n    tokenClickHandler(event) {\n      this.onTokenClick.emit(event);\n    }\n    /** @hidden */\n    tokenKeydownHandler(event) {\n      this.onTokenKeydown.emit(event);\n      if (KeyUtil.isKeyCode(event, [ENTER, SPACE])) {\n        this.onTokenClick.emit(event);\n      }\n    }\n    /** @hidden */\n    _setTotalCount(count) {\n      this.totalCount = count;\n    }\n  }\n  TokenComponent.ɵfac = function TokenComponent_Factory(t) {\n    return new (t || TokenComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.ContentDensityObserver));\n  };\n  TokenComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TokenComponent,\n    selectors: [[\"fd-token\"]],\n    viewQuery: function TokenComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_c2, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tokenWrapperElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._content = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._viewContainer = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function TokenComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"max-width\", 100, \"%\");\n      }\n    },\n    inputs: {\n      disabled: \"disabled\",\n      selected: \"selected\",\n      readOnly: \"readOnly\",\n      deleteButtonLabel: \"deleteButtonLabel\",\n      ariaRoleDescription: \"ariaRoleDescription\"\n    },\n    outputs: {\n      onCloseClick: \"onCloseClick\",\n      onRemove: \"onRemove\",\n      onTokenClick: \"onTokenClick\",\n      onTokenKeydown: \"onTokenKeydown\",\n      elementFocused: \"elementFocused\"\n    },\n    features: [i0.ɵɵProvidersFeature([contentDensityObserverProviders(), DestroyedService])],\n    ngContentSelectors: _c3,\n    decls: 8,\n    vars: 11,\n    consts: [[\"role\", \"option\", \"tabindex\", \"0\", 1, \"fd-token\", 3, \"click\", \"keydown\"], [\"tokenWrapperElement\", \"\"], [1, \"fd-token__text\", \"no-text-select\"], [\"viewContainer\", \"\"], [\"role\", \"button\", \"class\", \"fd-token__close\", 3, \"click\", 4, \"ngIf\"], [\"content\", \"\"], [\"role\", \"button\", 1, \"fd-token__close\", 3, \"click\"]],\n    template: function TokenComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"span\", 0, 1);\n        i0.ɵɵlistener(\"click\", function TokenComponent_Template_span_click_0_listener($event) {\n          return ctx.tokenClickHandler($event);\n        })(\"keydown\", function TokenComponent_Template_span_keydown_0_listener($event) {\n          return ctx.tokenKeydownHandler($event);\n        });\n        i0.ɵɵelementStart(2, \"span\", 2);\n        i0.ɵɵelementContainer(3, null, 3);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, TokenComponent_span_5_Template, 2, 3, \"span\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, TokenComponent_ng_template_6_Template, 1, 0, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"fd-token__disabled\", ctx.disabled)(\"fd-token--selected\", ctx.selected)(\"fd-token--readonly\", ctx.readOnly);\n        i0.ɵɵattribute(\"aria-roledescription\", ctx.ariaRoleDescription)(\"aria-setsize\", ctx.totalCount)(\"aria-selected\", ctx.selected)(\"aria-readonly\", ctx.readOnly);\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngIf\", !ctx.readOnly);\n      }\n    },\n    dependencies: [i3.NgIf, i3$1.FdTranslatePipe],\n    styles: [\"/*!\\n * Fundamental Library Styles v0.28.3\\n * Copyright (c) 2023 SAP SE or an SAP affiliate company.\\n * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/main/LICENSE)\\n */.fd-token{-webkit-box-sizing:border-box;-ms-flex-negative:0;align-items:center;background-color:var(--sapButton_TokenBackground);border:0;border:var(--sapButton_BorderWidth) solid var(--sapButton_TokenBorderColor);border-radius:var(--fdToken_Border_Radius);box-sizing:border-box;color:var(--sapTextColor);color:var(--fdToken_Text_Color);cursor:default;display:inline-flex;flex-shrink:0;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:1.625rem;line-height:var(--sapContent_LineHeight);line-height:1.5rem;margin:0;max-width:100%;min-width:3.625rem;padding:0;padding:.25rem 0 .25rem var(--fdToken_Padding_Left);text-align:center;text-overflow:clip;white-space:nowrap}.fd-token:after,.fd-token:before{box-sizing:inherit;font-size:inherit}.fd-token[dir=rtl],[dir=rtl] .fd-token{padding-left:0;padding-right:var(--fdToken_Padding_Left)}.fd-token__text{max-width:100%;min-width:auto;overflow:hidden;text-overflow:ellipsis;text-shadow:var(--fdToken_Text_Shadow);width:100%}.fd-token__close{-webkit-box-sizing:border-box;-webkit-box-align:center;-ms-flex-align:center;-webkit-box-pack:center;-ms-flex-pack:center;align-items:center;background-color:transparent;border:0;box-sizing:border-box;color:var(--sapTextColor);color:var(--sapContent_IconColor);cursor:pointer;display:flex;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-size:var(--sapFontSmallSize);font-weight:400;forced-color-adjust:none;height:1.625rem;justify-content:center;line-height:var(--sapContent_LineHeight);line-height:1.25rem;margin:0;min-width:1.75rem;padding:.25rem .5rem;width:1.75rem}.fd-token__close:after,.fd-token__close:before{box-sizing:inherit;font-size:inherit}.fd-token__close:before{content:\\\"\\\\e03e\\\";font-family:SAP-icons;text-align:center;text-decoration:inherit;text-rendering:optimizeLegibility;text-transform:none}.fd-token__close.is-focus,.fd-token__close:focus{box-shadow:none;outline:none;z-index:5}.fd-token:hover{-webkit-box-shadow:var(--fdToken_Box_Shadow_Hover);background-color:var(--fdToken_Background_Color_Hover);border-color:var(--fdToken_Border_Color_Hover);box-shadow:var(--fdToken_Box_Shadow_Hover)}.fd-token.is-focus,.fd-token:focus{box-shadow:none;outline-color:var(--sapContent_FocusColor);outline-offset:var(--fdToken_Outline_Offset);outline-style:var(--sapContent_FocusStyle);outline-width:var(--sapContent_FocusWidth)}.fd-token[class*=-compact],.fd-token[class*=-condensed],[class*=-compact] .fd-token:not([class*=-cozy]),[class*=-condensed] .fd-token:not([class*=-cozy]){height:1.25rem;line-height:1.125rem;min-width:3rem;padding:.1rem 0 .1rem .25rem}.fd-token[class*=-compact] .fd-token__close,.fd-token[class*=-condensed] .fd-token__close,[class*=-compact] .fd-token:not([class*=-cozy]) .fd-token__close,[class*=-condensed] .fd-token:not([class*=-cozy]) .fd-token__close{height:1.25rem;min-width:1.25rem;padding:.1rem .25rem;vertical-align:baseline;width:1.25rem}.fd-token[class*=-compact][dir=rtl],.fd-token[class*=-condensed][dir=rtl],[class*=-compact] .fd-token:not([class*=-cozy])[dir=rtl],[class*=-condensed] .fd-token:not([class*=-cozy])[dir=rtl],[dir=rtl] .fd-token[class*=-compact],[dir=rtl] .fd-token[class*=-condensed],[dir=rtl] [class*=-compact] .fd-token:not([class*=-cozy]),[dir=rtl] [class*=-condensed] .fd-token:not([class*=-cozy]){padding-left:0;padding-right:.25rem}.fd-token[class*=-compact].is-focus,.fd-token[class*=-compact]:focus,.fd-token[class*=-condensed].is-focus,.fd-token[class*=-condensed]:focus,[class*=-compact] .fd-token:not([class*=-cozy]).is-focus,[class*=-compact] .fd-token:not([class*=-cozy]):focus,[class*=-condensed] .fd-token:not([class*=-cozy]).is-focus,[class*=-condensed] .fd-token:not([class*=-cozy]):focus{box-shadow:none;outline-color:var(--sapContent_FocusColor);outline-offset:var(--fdToken_Outline_Offset);outline-offset:var(--fdToken_Outline_Offset_Compact);outline-style:var(--sapContent_FocusStyle);outline-width:var(--sapContent_FocusWidth)}.fd-token--disabled{cursor:not-allowed}.fd-token--readonly{background-color:var(--fdToken_Background_Color_Read_Only);border:var(--sapButton_BorderWidth) solid var(--fdToken_Border_Color_Read_Only);color:var(--sapContent_LabelColor);padding:.25rem .375rem}.fd-token--readonly[class*=-compact],.fd-token--readonly[class*=-condensed],[class*=-compact] .fd-token--readonly:not([class*=-cozy]),[class*=-condensed] .fd-token--readonly:not([class*=-cozy]){padding:.1rem .25rem}.fd-token--readonly[class*=-compact][dir=rtl],.fd-token--readonly[class*=-condensed][dir=rtl],[class*=-compact] .fd-token--readonly:not([class*=-cozy])[dir=rtl],[class*=-condensed] .fd-token--readonly:not([class*=-cozy])[dir=rtl],[dir=rtl] .fd-token--readonly[class*=-compact],[dir=rtl] .fd-token--readonly[class*=-condensed],[dir=rtl] [class*=-compact] .fd-token--readonly:not([class*=-cozy]),[dir=rtl] [class*=-condensed] .fd-token--readonly:not([class*=-cozy]){padding-left:.25rem}.fd-token--readonly.is-hover,.fd-token--readonly:hover{-webkit-box-shadow:none;background-color:var(--fdToken_Background_Color_Read_Only);border:var(--sapButton_BorderWidth) solid var(--fdToken_Border_Color_Read_Only);box-shadow:none;color:var(--sapContent_LabelColor)}.fd-token--readonly[dir=rtl],[dir=rtl] .fd-token--readonly{padding-left:.375rem}.fd-token.fd-token--selected{background-color:var(--sapButton_Selected_Background);border-color:var(--sapButton_Selected_BorderColor)}.fd-token.fd-token--selected,.fd-token.fd-token--selected .fd-token__close{color:var(--sapButton_Selected_TextColor)}.fd-token.fd-token--selected.is-hover,.fd-token.fd-token--selected:hover{-webkit-box-shadow:var(--fdToken_Box_Shadow_Selected_Hover);background-color:var(--sapButton_Selected_Hover_Background);border-color:var(--sapButton_Selected_Hover_BorderColor);box-shadow:var(--fdToken_Box_Shadow_Selected_Hover)}.fd-token.fd-token--selected.is-focus,.fd-token.fd-token--selected:focus{box-shadow:none;outline-color:var(--sapContent_FocusColor);outline-color:var(--fdToken_Border_Color_Selected_Focus);outline-offset:var(--fdToken_Outline_Offset);outline-style:var(--sapContent_FocusStyle);outline-width:var(--sapContent_FocusWidth)}.fd-token__disabled:after{cursor:not-allowed}.no-text-select{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return TokenComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TokenizerComponent = /*#__PURE__*/(() => {\n  class TokenizerComponent {\n    /** @hidden */\n    set content(content) {\n      this.inputGroupAddonEl = content;\n    }\n    /** @hidden */\n    get _hiddenTokens() {\n      return this.tokenList.filter(token => token.elementRef.nativeElement.style.display === 'none');\n    }\n    /**\n     * @hidden\n     * Observable state of the compact mode.\n     */\n    get _compact$() {\n      return this._contentDensityObserver.isCompact$;\n    }\n    /**\n     * @hidden\n     * Component is in compact mode, determined by the consumer\n     */\n    get _compact() {\n      return this._contentDensityObserver.isCompact;\n    }\n    /** @hidden */\n    constructor(_contentDensityObserver, _elementRef, _cdRef, _rtlService, _renderer, _document) {\n      this._contentDensityObserver = _contentDensityObserver;\n      this._elementRef = _elementRef;\n      this._cdRef = _cdRef;\n      this._rtlService = _rtlService;\n      this._renderer = _renderer;\n      this._document = _document;\n      /** Disables possibility to remove tokens by keyboard */\n      this.disableKeyboardDeletion = false;\n      /** Whether to use cozy visuals but compact collapsing behavior. */\n      this.compactCollapse = false;\n      /** Whether tokenizer should have fake focus indicator, when input is focused inside*/\n      this.tokenizerFocusable = true;\n      /** Word to use for when there are extra tokens. */\n      this.moreTerm = 'more';\n      /** Event emitted when the search term changes. Use *$event* to access the new term. */\n      this.moreClickedEvent = new EventEmitter();\n      /** @hidden */\n      this.moreTokensLeft = [];\n      /** @hidden */\n      this.moreTokensRight = [];\n      /** @hidden */\n      this.tokenListClickSubscriptions = [];\n      /** @hidden */\n      this.hiddenCozyTokenCount = 0;\n      /** @hidden Used to add focus to tokenizer element */\n      this._tokenizerHasFocus = false;\n      /** @hidden */\n      this._showOverflowPopover = true;\n      /** @hidden */\n      this._showMoreElement = false;\n      /** @hidden */\n      this._tokensContainerWidth = 'auto';\n      /** @hidden\n       * Variable which will keep the index of the first token pressed in the tokenizer\n       */\n      this._firstElementInSelection = null;\n      /** @hidden\n       * Variable which will keep the index of the last token pressed in the tokenizer\n       */\n      this._lastElementInSelection = null;\n      /** @hidden\n       * Flag which will say if they held shift and clicked highlighting elements before or\n       */\n      this._directionShiftIsRight = null;\n      /** An RxJS Subject that will kill the data stream upon destruction (for unsubscribing)  */\n      this._onDestroy$ = new Subject();\n      /** @hidden */\n      this._eventListeners = [];\n      /** @hidden */\n      this._forceAllTokensToDisplay = false;\n      /** @hidden */\n      this._tokenElementFocused = new BehaviorSubject(false);\n      /** @hidden */\n      this._inputElementFocused = false;\n      this._eventListeners.push(this._renderer.listen('window', 'click', e => {\n        if (this._elementRef.nativeElement.contains(e.target) === false) {\n          this.tokenList.forEach(token => {\n            token.selected = false;\n          });\n        }\n      }));\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      if (this.input?.nativeElement) {\n        this._inputKeydownEvent();\n      }\n      // watch for changes to the tokenList and attempt to expand/collapse tokens as needed\n      this.tokenList.changes.pipe(startWith(null)).subscribe(() => {\n        this.tokenListChangesSubscription?.unsubscribe();\n        this.tokenListChangesSubscription = new Subscription();\n        this._resetTokens();\n        this.tokenList.forEach(token => {\n          this.tokenListChangesSubscription.add(token.onCloseClick.subscribe(() => {\n            this._resetTokens();\n          }));\n          this.tokenListChangesSubscription.add(token.elementFocused.subscribe(isFocused => {\n            this._tokenElementFocused.next(isFocused);\n          }));\n        });\n      });\n      if (!this._compact && !this.compactCollapse) {\n        this._handleCozyTokenCount();\n      }\n      this._listenElementEvents();\n      this.previousElementWidth = this._elementRef.nativeElement.getBoundingClientRect().width;\n      this._listenOnResize();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.tokenListChangesSubscription?.unsubscribe();\n      this._tokenElementFocusedSub?.unsubscribe();\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n      this._eventListeners.forEach(e => e());\n      this._unsubscribeClicks();\n    }\n    /** @hidden */\n    ngOnInit() {\n      this.buildComponentCssClass();\n    }\n    /** @hidden */\n    ngOnChanges() {\n      this.buildComponentCssClass();\n    }\n    /** @hidden\n     * CssClassBuilder interface implementation\n     * function must return single string\n     * function is responsible for order which css classes are applied\n     */\n    buildComponentCssClass() {\n      return [this.class];\n    }\n    /** @hidden */\n    elementRef() {\n      return this._elementRef;\n    }\n    /** @hidden */\n    handleTokenClickSubscriptions() {\n      this._unsubscribeClicks();\n      this.tokenList.forEach((token, index) => {\n        if (token.tokenWrapperElement) {\n          token.tokenWrapperElement.nativeElement.tabIndex = -1;\n        }\n        this.tokenListClickSubscriptions.push(token.onTokenClick.subscribe(event => {\n          event.stopPropagation();\n          this.focusTokenElement(index);\n          if (this._isControlKey(event)) {\n            this._ctrlSelected(token, index);\n          } else if (!event.shiftKey || this._ctrlPrevious) {\n            this._basicSelected(token, index);\n          } else if (event.shiftKey) {\n            this.resetFirstAndLastElement();\n            this._shiftSelected(index);\n          }\n        }));\n        this.tokenListClickSubscriptions.push(token.onTokenKeydown.subscribe(event => {\n          this.handleKeyDown(event, index);\n        }));\n      });\n    }\n    /** @hidden */\n    focusTokenElement(newIndex) {\n      let elementToFocus;\n      const tokenListArray = this.tokenList.toArray();\n      if (tokenListArray[newIndex]) {\n        elementToFocus = tokenListArray[newIndex].tokenWrapperElement.nativeElement;\n        // element needs tabindex in order to be focused\n        elementToFocus.focus();\n      }\n      return elementToFocus;\n    }\n    /** @hidden */\n    keyDown(keyboardEvent) {\n      if (KeyUtil.isKeyCode(keyboardEvent, [DELETE, BACKSPACE]) && (!this._isInputFocused() || this._tokensSelected()) && !this.disableKeyboardDeletion) {\n        const selectedElements = this._getActiveTokens();\n        const focusedTokenIndex = this._getFocusedTokenIndex();\n        selectedElements.forEach(element => element.onCloseClick.emit());\n        if (selectedElements.length > 0) {\n          if (KeyUtil.isKeyCode(keyboardEvent, DELETE)) {\n            this._focusInput();\n          } else {\n            this.focusTokenElement(focusedTokenIndex - 1);\n          }\n        }\n      }\n      if (KeyUtil.isKeyCode(keyboardEvent, BACKSPACE) && this._isInputFocused() && !this._getInputValue() && !this.disableKeyboardDeletion) {\n        this.focusTokenElement(this.tokenList.length - 1);\n      }\n    }\n    /** @hidden */\n    onResize() {\n      if (this._elementRef) {\n        const elementWidth = this._elementRef.nativeElement.getBoundingClientRect().width;\n        this._resetTokens();\n        this.previousElementWidth = elementWidth;\n        if (!this._compact && !this.compactCollapse) {\n          this._handleCozyTokenCount();\n        }\n      }\n    }\n    /** @hidden */\n    handleKeyDown(event, fromIndex) {\n      let newIndex;\n      const rtl = this._rtlService && this._rtlService.rtl ? this._rtlService.rtl.getValue() : false;\n      if (KeyUtil.isKeyCode(event, SPACE) && !this._isInputFocused()) {\n        const token = this.tokenList.find((_, index) => index === fromIndex);\n        this.tokenList.forEach(shadowedToken => {\n          if (shadowedToken !== token) {\n            shadowedToken.selected = false;\n          }\n        });\n        token && (token.selected = !token.selected);\n        event.preventDefault();\n      } else if (KeyUtil.isKeyCode(event, ENTER)) {\n        this._focusInput();\n      } else if (KeyUtil.isKeyCode(event, LEFT_ARROW) && !rtl || KeyUtil.isKeyCode(event, RIGHT_ARROW) && rtl) {\n        this._handleArrowLeft(fromIndex);\n        newIndex = fromIndex - 1;\n      } else if (KeyUtil.isKeyCode(event, RIGHT_ARROW) && !rtl || KeyUtil.isKeyCode(event, LEFT_ARROW) && rtl) {\n        this._handleArrowRight(fromIndex);\n        newIndex = fromIndex + 1;\n      } else if (KeyUtil.isKeyCode(event, A) && !this._getInputValue() && this._isControlKey(event)) {\n        event.preventDefault();\n        this.tokenList.forEach(token => token.selected = true);\n      }\n      if (newIndex === this.tokenList.length && (KeyUtil.isKeyCode(event, RIGHT_ARROW) && !rtl || KeyUtil.isKeyCode(event, LEFT_ARROW) && rtl)) {\n        this._focusInput();\n      } else if (newIndex > this.tokenList.length - this.moreTokensRight.length && this._isInputFocused()) {\n        this.focusTokenElement(newIndex - this.moreTokensRight.length);\n      } else if (newIndex || newIndex === 0) {\n        this.focusTokenElement(newIndex);\n      }\n    }\n    /** @hidden */\n    getCombinedTokenWidth() {\n      let totalTokenWidth = this._getTokensAreaWidthWithoutTokens();\n      // get the width of each token\n      this.tokenList.forEach(token => {\n        totalTokenWidth = totalTokenWidth + token.elementRef.nativeElement.getBoundingClientRect().width;\n      });\n      return totalTokenWidth;\n    }\n    /** @hidden */\n    _getTokensAreaWidthWithoutTokens() {\n      let totalTokenWidth = 0;\n      // add input width\n      if (this.input?.nativeElement) {\n        totalTokenWidth = totalTokenWidth + this.input.nativeElement.getBoundingClientRect().width;\n      }\n      // add the width of the \"____ more\" element\n      if (this.moreTokensLeft.length > 0 && this.moreElement && this.moreElement.nativeElement) {\n        totalTokenWidth = totalTokenWidth + this.moreElement.nativeElement.getBoundingClientRect().width;\n      }\n      // add the input group addon\n      if (this.inputGroupAddonEl && this.inputGroupAddonEl.nativeElement) {\n        totalTokenWidth = totalTokenWidth + this.inputGroupAddonEl.nativeElement.getBoundingClientRect().width;\n      }\n      return totalTokenWidth;\n    }\n    /** @hidden */\n    moreClicked() {\n      this.moreClickedEvent.emit();\n    }\n    /** Removes all selected tokens */\n    removeSelectedTokens() {\n      const selectedElements = this._getActiveTokens();\n      selectedElements.forEach(element => element.onRemove.emit());\n    }\n    /** @hidden */\n    _handleArrowLeft(fromIndex) {\n      // if the leftmost visible token is selected, and there are moreTokensLeft, need to display a moreTokenLeft\n      if (fromIndex === this.moreTokensLeft.length) {\n        const poppedToken = this.moreTokensLeft.pop();\n        if (poppedToken) {\n          this._makeElementVisible(poppedToken.elementRef);\n        }\n        // and then hide any tokens from the right that no longer fit\n        this._collapseTokens('right');\n        this._cdRef.detectChanges();\n      }\n    }\n    /** @hidden */\n    _showAllTokens() {\n      this._forceAllTokensToDisplay = true;\n      this._inputElementFocused = true;\n      this.tokenList.forEach(token => {\n        this._makeElementVisible(token.elementRef);\n        token._viewContainer.createEmbeddedView(token._content);\n      });\n      this._tokensContainerWidth = 'auto';\n      this._showMoreElement = false;\n      this._cdRef.detectChanges();\n      this.tokenizerInnerEl.nativeElement.scrollLeft = this.tokenizerInnerEl.nativeElement.scrollWidth;\n    }\n    /** @hidden */\n    _hideTokens() {\n      setTimeout(() => {\n        this._inputElementFocused = false;\n        const tokenFocused = this._getFocusedTokenIndex() > -1;\n        if (tokenFocused) {\n          this._waitForFocusToDisappear();\n          return;\n        }\n        this._forceAllTokensToDisplay = false;\n        this._resetTokens();\n        this._cdRef.detectChanges();\n        this.tokenizerInnerEl.nativeElement.scrollLeft = this.tokenizerInnerEl.nativeElement.scrollWidth;\n      });\n    }\n    /** @hidden */\n    _waitForFocusToDisappear() {\n      this._tokenElementFocusedSub?.unsubscribe();\n      // 5 ms delay for other token to receive focus, check if _showAllTokens was called again\n      this._tokenElementFocusedSub = this._tokenElementFocused.pipe(debounceTime(5), filter(isFocused => isFocused && !this._inputElementFocused)).subscribe(() => {\n        this._hideTokens();\n      });\n    }\n    /** @hidden */\n    _handleArrowRight(fromIndex) {\n      if (fromIndex === this.tokenList.length - this.moreTokensRight.length - 1 && this.moreTokensRight.length) {\n        const poppedToken = this.moreTokensRight.pop();\n        if (poppedToken) {\n          this._makeElementVisible(poppedToken.elementRef);\n        }\n        // and then hide any tokens from the left that no longer fit\n        this._collapseTokens('left');\n        this._cdRef.detectChanges();\n      }\n    }\n    /** @hidden */\n    _collapseTokens(side) {\n      if (this._forceAllTokensToDisplay) {\n        return;\n      }\n      if (!this._compact && !this.compactCollapse) {\n        this._getHiddenCozyTokenCount();\n        return;\n      }\n      this._cdRef.detectChanges();\n      this._viewContainer.forEach(viewContainer => viewContainer.clear());\n      const availableWidth = this._getTokensAreaWidthWithoutTokens();\n      if (this.tokenList.length === 1) {\n        const tokenWidth = this.tokenList.get(0)?.elementRef.nativeElement.getBoundingClientRect().width;\n        this._tokensContainerWidth = availableWidth < tokenWidth ? `calc(100% - ${availableWidth}px)` : 'auto';\n        return;\n      } else {\n        this._tokensContainerWidth = 'auto';\n      }\n      this._checkMoreElementVisibility();\n      this.tokenList.forEach(token => token._viewContainer.createEmbeddedView(token._content));\n      let elementWidth = this._elementRef.nativeElement.getBoundingClientRect().width;\n      let combinedTokenWidth = this.getCombinedTokenWidth(); // the combined width of all tokens, the \"____ more\" text, and the input\n      let i = 0;\n      /*\n       When resizing, we want to collapse the tokens on the left first. However, when the user is navigating through\n       a group of overflowing tokens using the arrow left key, we may need to hide tokens on the right. So if this\n       function has been called with the param 'right' it will collapse tokens from the right side of the list rather\n       than the (default) left side.\n       */\n      if (side === 'right') {\n        i = this.tokenList.length - 1;\n      }\n      while (combinedTokenWidth > elementWidth && (side === 'right' ? i >= 0 : i < this.tokenList.length)) {\n        // loop through the tokens and hide them until the combinedTokenWidth fits in the elementWidth\n        const token = this.tokenList.get(i);\n        const moreTokens = side === 'right' ? this.moreTokensRight : this.moreTokensLeft;\n        if (token) {\n          if (moreTokens.indexOf(token) === -1) {\n            moreTokens.push(token);\n          }\n          token.elementRef.nativeElement.style.display = 'none';\n        }\n        // get the new elementWidth and combinedTokenWidth as these will have changed after setting a token display to 'none'\n        elementWidth = this._elementRef.nativeElement.getBoundingClientRect().width;\n        this._checkMoreElementVisibility();\n        combinedTokenWidth = this.getCombinedTokenWidth();\n        side === 'right' ? i-- : i++;\n      }\n      this._cdRef.detectChanges();\n      this._hiddenTokens.forEach((hiddenToken, index) => {\n        hiddenToken._viewContainer.clear();\n        this._viewContainer.get(index)?.createEmbeddedView(hiddenToken._content);\n      });\n    }\n    /** @hidden */\n    _resetTokens() {\n      this.moreTokensLeft = [];\n      this.moreTokensRight = [];\n      if (this._compact || this.compactCollapse || this._forceAllTokensToDisplay) {\n        this.tokenList.forEach(token => {\n          this._makeElementVisible(token.elementRef);\n        });\n        this._cdRef.markForCheck();\n        this._collapseTokens();\n      } else {\n        this._getHiddenCozyTokenCount();\n      }\n      this.handleTokenClickSubscriptions();\n      this.previousTokenCount = this.tokenList.length;\n      this.tokenList.forEach(token => token._setTotalCount(this.tokenList.length));\n      this._cdRef.markForCheck();\n    }\n    /** @hidden */\n    _getHiddenCozyTokenCount() {\n      const elementLeft = this._elementRef.nativeElement.getBoundingClientRect().left;\n      this.hiddenCozyTokenCount = 0;\n      this.tokenList.forEach(token => {\n        if (token.tokenWrapperElement && token.tokenWrapperElement.nativeElement.getBoundingClientRect().right < elementLeft) {\n          this.hiddenCozyTokenCount += 1;\n        }\n      });\n      this._checkMoreElementVisibility();\n    }\n    /** @hidden */\n    _handleCozyTokenCount() {\n      // because justify-content breaks scrollbar, it cannot be used on cozy screens, so use JS to scroll to the end\n      this.tokenizerInnerEl.nativeElement.scrollLeft = this.tokenizerInnerEl.nativeElement.scrollWidth;\n      this._getHiddenCozyTokenCount();\n      if (this.hiddenCozyTokenCount > 0) {\n        // need to do this again in case \"____ more\" text was added\n        this.tokenizerInnerEl.nativeElement.scrollLeft = this.tokenizerInnerEl.nativeElement.scrollWidth;\n        this._getHiddenCozyTokenCount();\n      }\n    }\n    /** @hidden */\n    _makeElementVisible(elementRef) {\n      elementRef.nativeElement.style.display = 'inline-block';\n      elementRef.nativeElement.style.visibility = 'visible';\n    }\n    /** @hidden */\n    _unsubscribeClicks() {\n      if (this.tokenListClickSubscriptions && this.tokenListClickSubscriptions.length) {\n        this.tokenListClickSubscriptions.forEach(subscription => {\n          subscription.unsubscribe();\n        });\n      }\n    }\n    /** @hidden */\n    _inputKeydownEvent() {\n      this._eventListeners.push(this._renderer.listen(this.input.nativeElement, 'keydown', event => {\n        this.handleKeyDown(event, this.tokenList.length);\n      }));\n    }\n    /** @hidden Method which handles what happens to token when it is clicked and no key is being held down.*/\n    _basicSelected(token, index) {\n      this.tokenList.forEach(shadowedToken => {\n        if (shadowedToken !== token) {\n          shadowedToken.selected = false;\n        }\n      });\n      this._firstElementInSelection = index;\n      this._lastElementInSelection = index;\n      token.selected = true;\n      this._ctrlPrevious = false;\n    }\n    /** @hidden Restart first and last elements for shift selection.*/\n    resetFirstAndLastElement() {\n      const reset = !this.tokenList.some(token => token.selected);\n      if (reset) {\n        this._firstElementInSelection = null;\n        this._lastElementInSelection = null;\n      }\n    }\n    /** @hidden Method which handles what happens to token when it is clicked and the shift key is being held down.*/\n    _shiftSelected(index) {\n      if (!this._firstElementInSelection && !this._lastElementInSelection) {\n        this._firstElementInSelection = index;\n        this._lastElementInSelection = index;\n        this._directionShiftIsRight = null;\n      } else {\n        if (this._firstElementInSelection && index < this._firstElementInSelection) {\n          if (this._directionShiftIsRight) {\n            this._lastElementInSelection = this._firstElementInSelection;\n          }\n          this._directionShiftIsRight = false;\n          this._firstElementInSelection = index;\n        } else if (this._lastElementInSelection && index > this._lastElementInSelection) {\n          if (!this._directionShiftIsRight) {\n            this._firstElementInSelection = this._lastElementInSelection;\n          }\n          this._directionShiftIsRight = true;\n          this._lastElementInSelection = index;\n        }\n        if (!this._directionShiftIsRight) {\n          this._firstElementInSelection = index;\n        } else if (this._directionShiftIsRight) {\n          this._lastElementInSelection = index;\n        }\n      }\n      this.tokenList.forEach((token, indexOfToken) => {\n        token.selected = this._firstElementInSelection != null && this._lastElementInSelection != null && indexOfToken >= this._firstElementInSelection && indexOfToken <= this._lastElementInSelection;\n      });\n      this._ctrlPrevious = false;\n    }\n    /** @hidden Method which handles what happens to token when it is clicked and the control or meta key is being held down.*/\n    _ctrlSelected(token, index) {\n      this._firstElementInSelection = null;\n      this._lastElementInSelection = null;\n      const selected = token.selected;\n      token.selected = true;\n      if (selected) {\n        token.selected = false;\n        this.tokenList.forEach((element, indexOfToken) => {\n          if (!this._firstElementInSelection) {\n            if (element.selected) {\n              this._firstElementInSelection = indexOfToken;\n            }\n          } else {\n            this._lastElementInSelection = indexOfToken;\n          }\n        });\n        if (index === this._lastElementInSelection) {\n          this._lastElementInSelection = this._lastElementInSelection - 1;\n        }\n        if (index === this._firstElementInSelection) {\n          this._firstElementInSelection = this._firstElementInSelection - 1;\n        }\n      }\n      this._ctrlPrevious = true;\n    }\n    /** Get selected and focused tokens */\n    _getActiveTokens() {\n      return this.tokenList.filter(item => item.selected || this._isTokenFocused(item));\n    }\n    /** @hidden */\n    _getFocusedTokenIndex() {\n      return this.tokenList.toArray().findIndex(token => this._isTokenFocused(token));\n    }\n    /** @hidden */\n    _isTokenFocused(token) {\n      return token.tokenWrapperElement.nativeElement === this._document.activeElement;\n    }\n    /** @hidden */\n    _isInputFocused() {\n      return this._document.activeElement === this.input.nativeElement;\n    }\n    /** @hidden */\n    _tokensSelected() {\n      return this.tokenList.some(t => t.selected);\n    }\n    /** @hidden */\n    _getInputValue() {\n      return this.input.nativeElement.value;\n    }\n    /** @hidden */\n    _focusInput() {\n      this.input.nativeElement.focus();\n    }\n    /** @hidden */\n    _isControlKey(keyboardEvent) {\n      return keyboardEvent.ctrlKey || keyboardEvent.metaKey;\n    }\n    /** @hidden */\n    _listenElementEvents() {\n      merge(fromEvent(this._elementRef.nativeElement, 'focus', {\n        capture: true\n      }).pipe(filter(event => event['target']?.tagName === 'INPUT' && this.tokenizerFocusable), map(() => true)), fromEvent(this._elementRef.nativeElement, 'blur', {\n        capture: true\n      }).pipe(map(() => false))).pipe(\n      // debounceTime is needed in order to filter subsequent focus-blur events, that happen simultaneously\n      debounceTime(10), takeUntil(this._onDestroy$)).subscribe(focused => {\n        this._tokenizerHasFocus = focused;\n        this._cdRef.markForCheck();\n      });\n    }\n    /** @hidden Listen window resize and distribute cards on column change */\n    _listenOnResize() {\n      this.onResize();\n      resizeObservable(this._elementRef.nativeElement).pipe(debounceTime(30), takeUntil(this._onDestroy$)).subscribe(() => this.onResize());\n    }\n    /** @hidden */\n    _checkMoreElementVisibility() {\n      const showMoreElement = (this.moreTokensLeft.length > 0 || this.moreTokensRight.length > 0 || this.hiddenCozyTokenCount > 0) && !this.open && !this._tokenizerHasFocus;\n      if (showMoreElement === this._showMoreElement) {\n        return;\n      }\n      this._showMoreElement = showMoreElement;\n      this._cdRef.detectChanges();\n    }\n  }\n  TokenizerComponent.ɵfac = function TokenizerComponent_Factory(t) {\n    return new (t || TokenizerComponent)(i0.ɵɵdirectiveInject(i1.ContentDensityObserver), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.RtlService, 8), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n  TokenizerComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: TokenizerComponent,\n    selectors: [[\"fd-tokenizer\"]],\n    contentQueries: function TokenizerComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FormControlComponent, 5, ElementRef);\n        i0.ɵɵcontentQuery(dirIndex, TokenComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.input = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tokenList = _t);\n      }\n    },\n    viewQuery: function TokenizerComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c4, 5);\n        i0.ɵɵviewQuery(_c5, 5);\n        i0.ɵɵviewQuery(_c6, 5);\n        i0.ɵɵviewQuery(_c2, 5, ViewContainerRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.tokenizerInnerEl = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.moreElement = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._viewContainer = _t);\n      }\n    },\n    hostBindings: function TokenizerComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function TokenizerComponent_keydown_HostBindingHandler($event) {\n          return ctx.keyDown($event);\n        });\n      }\n    },\n    inputs: {\n      class: \"class\",\n      disableKeyboardDeletion: \"disableKeyboardDeletion\",\n      compactCollapse: \"compactCollapse\",\n      tokenizerFocusable: \"tokenizerFocusable\",\n      inputValue: \"inputValue\",\n      glyph: \"glyph\",\n      moreTerm: \"moreTerm\",\n      open: \"open\"\n    },\n    outputs: {\n      moreClickedEvent: \"moreClickedEvent\"\n    },\n    features: [i0.ɵɵProvidersFeature([contentDensityObserverProviders()]), i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c9,\n    decls: 13,\n    vars: 9,\n    consts: [[1, \"fd-tokenizer\", \"fd-tokenizer--scrollable\"], [1, \"fd-tokenizer__inner\"], [\"tokenizerInner\", \"\"], [\"role\", \"listbox\"], [4, \"ngIf\", \"ngIfElse\"], [\"fd-input-group-addon\", \"\", \"placement\", \"after\", 3, \"button\", 4, \"ngIf\"], [\"tokensOverflow\", \"\"], [\"moreElement\", \"\"], [4, \"ngTemplateOutlet\"], [\"fd-input-group-addon\", \"\", \"placement\", \"after\", 3, \"button\"], [\"inputGroupAddOn\", \"\"], [\"fd-button\", \"\", \"fdType\", \"transparent\", \"type\", \"button\", 1, \"fd-tokenizer-addon\", 3, \"glyph\"], [\"placement\", \"bottom-start\", \"title\", \"\", 3, \"noArrow\", \"focusTrapped\", \"focusAutoCapture\"], [\"fd-list\", \"\", 1, \"fd-tokenizer__overflow-list\"], [\"fd-list-item\", \"\", \"class\", \"fd-tokenizer__overflow-list-item\", 4, \"ngFor\", \"ngForOf\"], [\"fd-list-item\", \"\", 1, \"fd-tokenizer__overflow-list-item\"], [\"viewContainer\", \"\"], [\"class\", \"fd-token__close\", \"role\", \"button\", 3, \"click\", 4, \"ngIf\"], [\"role\", \"button\", 1, \"fd-token__close\", 3, \"click\"], [\"class\", \"fd-tokenizer-more\", \"role\", \"button\", \"tabindex\", \"0\", 3, \"click\", 4, \"ngIf\"], [\"role\", \"button\", \"tabindex\", \"0\", 1, \"fd-tokenizer-more\", 3, \"click\"], [\"moreElementSpan\", \"\"], [4, \"ngIf\"]],\n    template: function TokenizerComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c8);\n        i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1, 2)(3, \"div\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(5, TokenizerComponent_ng_container_5_Template, 2, 1, \"ng-container\", 4);\n        i0.ɵɵpipe(6, \"async\");\n        i0.ɵɵprojection(7, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, TokenizerComponent_span_8_Template, 3, 2, \"span\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, TokenizerComponent_ng_template_9_Template, 6, 5, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(11, TokenizerComponent_ng_template_11_Template, 1, 1, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        const _r5 = i0.ɵɵreference(12);\n        i0.ɵɵclassProp(\"is-focus\", ctx._tokenizerHasFocus);\n        i0.ɵɵadvance(3);\n        i0.ɵɵstyleProp(\"width\", ctx._tokensContainerWidth);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx._showOverflowPopover && (i0.ɵɵpipeBind1(6, 7, ctx._compact$) || ctx.compactCollapse))(\"ngIfElse\", _r5);\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.glyph);\n      }\n    },\n    dependencies: [i3.NgForOf, i3.NgIf, i3.NgTemplateOutlet, i4.InputGroupAddOnDirective, i5.ButtonComponent, i6.PopoverControlComponent, i6.PopoverBodyComponent, i6.PopoverComponent, i7.ListComponent, i7.ListItemComponent, i3.AsyncPipe, i3$1.FdTranslatePipe],\n    styles: [\"/*!\\n * Fundamental Library Styles v0.28.3\\n * Copyright (c) 2023 SAP SE or an SAP affiliate company.\\n * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/main/LICENSE)\\n */.fd-tokenizer{-webkit-box-sizing:border-box;-webkit-box-shadow:none;-moz-appearance:none;-webkit-appearance:none;align-items:center;appearance:none;background:var(--sapField_BackgroundStyle, var(--sapField_BackgroundStyle));background-color:var(--sapField_Background, var(--sapField_Background));border:none;border-radius:var(--sapField_BorderCornerRadius);box-shadow:none;box-sizing:border-box;color:var(--sapTextColor);color:var(--sapField_TextColor);cursor:text;display:flex;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:2.25rem;height:auto;line-height:var(--sapContent_LineHeight);margin:0;min-height:2.25rem;min-width:var(2.75rem, 2.75rem);outline:none;overflow:hidden;padding:0;text-overflow:ellipsis;text-shadow:var(--fdInput_Text_Shadow);white-space:nowrap;width:100%;z-index:1}.fd-tokenizer:after,.fd-tokenizer:before{box-sizing:inherit;font-size:inherit}.fd-tokenizer::placeholder{color:var(--sapField_PlaceholderTextColor);font-style:var(--fdPlaceholder_Font_Style)}.fd-tokenizer[dir=rtl]::placeholder,[dir=rtl] .fd-tokenizer::placeholder{text-indent:.125rem}.fd-tokenizer::selection{background-color:var(--sapSelectedColor);color:var(--sapContent_ContrastTextColor)}.fd-tokenizer::-ms-clear{display:none}.fd-tokenizer.is-hover,.fd-tokenizer:hover{-webkit-box-shadow:var(--fdInput_Box_Shadow_Hover);background:var(--sapField_Hover_BackgroundStyle, var(--sapField_Hover_BackgroundStyle));background-color:var(--sapField_Hover_Background, var(--sapField_Hover_Background));border-color:var(--sapField_Hover_BorderColor);box-shadow:var(--fdInput_Box_Shadow_Hover)}.fd-tokenizer.is-focus,.fd-tokenizer:focus{background:var(--sapField_Focus_Background, var(--sapField_Focus_Background));outline-color:var(--fdInput_Outline_Color);outline-offset:var(--fdInput_Outline_Offset)}.fd-tokenizer.is-hover,.fd-tokenizer:hover{box-shadow:none}.fd-tokenizer__inner{-ms-overflow-style:none;-webkit-box-align:center;-ms-flex-align:center;-webkit-box-pack:end;-ms-flex-pack:end;align-items:center;display:flex;float:right;justify-content:flex-end;overflow:hidden;padding:var(--fdTokenizer_Inner_Padding, 0 .3125rem);scrollbar-width:none;white-space:nowrap;width:100%}.fd-tokenizer__inner::-webkit-scrollbar{display:none}.fd-tokenizer .fd-token{margin-right:.3125rem;max-width:calc(100% - 3.3125rem)}.fd-tokenizer .fd-token[dir=rtl],[dir=rtl] .fd-tokenizer .fd-token{margin:0 0 0 .3125rem}.fd-tokenizer__indicator{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);cursor:pointer;display:inline-block;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;padding:0}.fd-tokenizer__indicator:after,.fd-tokenizer__indicator:before{box-sizing:inherit;font-size:inherit}.fd-tokenizer .fd-tokenizer__input{background:transparent}.fd-tokenizer .fd-tokenizer__input.fd-input{border:none;min-width:var(--fdTokenizer_Input_Width, 3rem);padding:0}.fd-tokenizer .fd-tokenizer__input:first-child{padding:0 .3125rem}.fd-tokenizer .fd-tokenizer__input:last-child{flex-basis:100%}.fd-tokenizer .fd-tokenizer__input.is-focus,.fd-tokenizer .fd-tokenizer__input:focus{border:none;outline:none;z-index:5}.fd-tokenizer .fd-tokenizer__input.is-focus,.fd-tokenizer .fd-tokenizer__input.is-hover,.fd-tokenizer .fd-tokenizer__input:focus,.fd-tokenizer .fd-tokenizer__input:hover{-webkit-box-shadow:none;background:none;background-color:var(transparent, transparent);box-shadow:none}.fd-tokenizer.is-focus,.fd-tokenizer:focus{-webkit-box-shadow:none;border:none;box-shadow:none;outline-color:var(--sapContent_FocusColor);outline-offset:-.0625rem;outline-style:var(--sapContent_FocusStyle);outline-width:var(--sapContent_FocusWidth);z-index:5}.fd-tokenizer[class*=-compact],.fd-tokenizer[class*=-condensed],[class*=-compact] .fd-tokenizer:not([class*=-cozy]),[class*=-condensed] .fd-tokenizer:not([class*=-cozy]){--fdTokenizer_Inner_Padding:0 .25rem;--fdInput_Field_Compact_Min_Width:2rem;height:1.625rem;min-height:1.625rem}.fd-tokenizer[class*=-compact] .fd-tokenizer__input:first-child,.fd-tokenizer[class*=-condensed] .fd-tokenizer__input:first-child,[class*=-compact] .fd-tokenizer:not([class*=-cozy]) .fd-tokenizer__input:first-child,[class*=-condensed] .fd-tokenizer:not([class*=-cozy]) .fd-tokenizer__input:first-child{padding:0 .25rem}.fd-tokenizer[class*=-compact] .fd-token,.fd-tokenizer[class*=-condensed] .fd-token,[class*=-compact] .fd-tokenizer:not([class*=-cozy]) .fd-token,[class*=-condensed] .fd-tokenizer:not([class*=-cozy]) .fd-token{margin-right:.25rem;max-width:calc(100% - 2.25rem)}.fd-tokenizer[class*=-compact] .fd-token[dir=rtl],.fd-tokenizer[class*=-condensed] .fd-token[dir=rtl],[class*=-compact] .fd-tokenizer:not([class*=-cozy]) .fd-token[dir=rtl],[class*=-condensed] .fd-tokenizer:not([class*=-cozy]) .fd-token[dir=rtl],[dir=rtl] .fd-tokenizer[class*=-compact] .fd-token,[dir=rtl] .fd-tokenizer[class*=-condensed] .fd-token,[dir=rtl] [class*=-compact] .fd-tokenizer:not([class*=-cozy]) .fd-token,[dir=rtl] [class*=-condensed] .fd-tokenizer:not([class*=-cozy]) .fd-token{margin:0 0 0 .3125rem}.fd-tokenizer--readonly{background-color:var(--sapField_ReadOnly_Background);overflow:visible}.fd-tokenizer--readonly .fd-tokenizer__inner{overflow:visible}.fd-tokenizer--readonly .fd-tokenizer__input.is-readonly,.fd-tokenizer--readonly .fd-tokenizer__input[aria-readonly=true],.fd-tokenizer--readonly .fd-tokenizer__input[readonly]{-webkit-box-shadow:none;background:none;background-color:var(transparent, transparent);box-shadow:none}.fd-tokenizer--readonly .fd-tokenizer__input.is-readonly.is-focus,.fd-tokenizer--readonly .fd-tokenizer__input.is-readonly:focus,.fd-tokenizer--readonly .fd-tokenizer__input[aria-readonly=true].is-focus,.fd-tokenizer--readonly .fd-tokenizer__input[aria-readonly=true]:focus,.fd-tokenizer--readonly .fd-tokenizer__input[readonly].is-focus,.fd-tokenizer--readonly .fd-tokenizer__input[readonly]:focus{-webkit-box-shadow:none;background:none;background-color:var(transparent, transparent);box-shadow:none;z-index:5}.fd-tokenizer--scrollable .fd-tokenizer__inner{justify-content:normal;overflow:scroll}.fd-tokenizer .fd-token{max-width:inherit!important}input.fd-input.fd-tokenizer__input{background-color:transparent;margin-right:1px;border:none;outline:none}.fd-tokenizer-more{padding-right:.5rem;color:var(--sapLinkColor);cursor:pointer}[dir=rtl] .fd-tokenizer-more,.fd-tokenizer-more[dir=rtl]{padding-left:.5rem;padding-right:0}.fd-input-group__addon--button .fd-input-group__button.fd-tokenizer-addon{height:2.25rem}.fd-input-group__addon--button .fd-input-group__button.fd-tokenizer-addon--compact{height:1.625rem}.fd-tokenizer__overflow-list-item{display:flex;justify-content:space-between}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  __decorate([applyCssClass, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Array)], TokenizerComponent.prototype, \"buildComponentCssClass\", null);\n  return TokenizerComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TokenizerInputDirective = /*#__PURE__*/(() => {\n  class TokenizerInputDirective {\n    /** @hidden\n     * CssClassBuilder interface implementation\n     * function must return single string\n     * function is responsible for order which css classes are applied\n     */\n    buildComponentCssClass() {\n      return ['fd-tokenizer__input', this.class];\n    }\n    /** @hidden */\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n    }\n    /** @hidden */\n    ngOnInit() {\n      this.buildComponentCssClass();\n    }\n    /** @hidden */\n    ngOnChanges() {\n      this.buildComponentCssClass();\n    }\n    /** @hidden */\n    elementRef() {\n      return this._elementRef;\n    }\n  }\n  TokenizerInputDirective.ɵfac = function TokenizerInputDirective_Factory(t) {\n    return new (t || TokenizerInputDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  TokenizerInputDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TokenizerInputDirective,\n    selectors: [[\"\", \"fd-tokenizer-input\", \"\"]],\n    inputs: {\n      class: \"class\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  __decorate([applyCssClass, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Array)], TokenizerInputDirective.prototype, \"buildComponentCssClass\", null);\n  return TokenizerInputDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedTokenizerContentDensityDirective = /*#__PURE__*/(() => {\n  class DeprecatedTokenizerContentDensityDirective extends DeprecatedCompactDirective {\n    /** @hidden */\n    constructor() {\n      super('fd-tokenizer[compact], fd-token');\n    }\n  }\n  DeprecatedTokenizerContentDensityDirective.ɵfac = function DeprecatedTokenizerContentDensityDirective_Factory(t) {\n    return new (t || DeprecatedTokenizerContentDensityDirective)();\n  };\n  DeprecatedTokenizerContentDensityDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedTokenizerContentDensityDirective,\n    selectors: [[\"fd-tokenizer\", \"compact\", \"\"], [\"fd-token\", \"compact\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CONTENT_DENSITY_DIRECTIVE,\n      useExisting: forwardRef(() => DeprecatedTokenizerContentDensityDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedTokenizerContentDensityDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TokenModule = /*#__PURE__*/(() => {\n  class TokenModule {}\n  TokenModule.ɵfac = function TokenModule_Factory(t) {\n    return new (t || TokenModule)();\n  };\n  TokenModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TokenModule\n  });\n  TokenModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, InputGroupModule, ButtonModule, PopoverModule, ListModule, ContentDensityModule, I18nModule, ContentDensityModule]\n  });\n  return TokenModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DeprecatedTokenizerContentDensityDirective, TokenComponent, TokenModule, TokenizerComponent, TokenizerInputDirective };\n//# sourceMappingURL=fundamental-ngx-core-token.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}