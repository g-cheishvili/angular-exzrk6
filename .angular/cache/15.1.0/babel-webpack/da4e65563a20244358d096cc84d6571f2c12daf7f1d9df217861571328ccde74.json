{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Component, ViewEncapsulation, ChangeDetectionStrategy, Input, HostBinding, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport * as i1 from '@angular/platform-browser';\nclass HtmlSanitizer {\n  /** @hidden */\n  constructor() {\n    /** @hidden */\n    this.tagWhitelist = {};\n    /** @hidden */\n    this.attributeWhitelist = {};\n    /** @hidden */\n    this._schemaWhiteList = ['http', 'https', 'ftp', 'mailto'];\n    /** @hidden */\n    this._uriAttributes = {\n      href: true\n    };\n    /** @hidden */\n    this._safeWrapper = {\n      iframe: null,\n      iframeDoc: null\n    };\n    this.extendTags();\n  }\n  /** @hidden */\n  get defTagWhitelist() {\n    return {\n      A: true,\n      ABBR: true,\n      BLOCKQUOTE: true,\n      BR: true,\n      CITE: true,\n      CODE: true,\n      DL: true,\n      DT: true,\n      DD: true,\n      EM: true,\n      H1: true,\n      H2: true,\n      H3: true,\n      H4: true,\n      H5: true,\n      H6: true,\n      P: true,\n      PRE: true,\n      STRONG: true,\n      SPAN: true,\n      U: true,\n      UL: true,\n      OL: true,\n      LI: true\n    };\n  }\n  /** @hidden */\n  get defAttributeWhitelist() {\n    return {\n      class: true,\n      style: true,\n      href: true,\n      target: '_blank',\n      download: true,\n      hreflang: true,\n      rel: true,\n      type: true,\n      title: true\n    };\n  }\n  /** @hidden */\n  extendTags(customTags) {\n    this.tagWhitelist = {\n      ...this.defTagWhitelist,\n      ...customTags,\n      BODY: true\n    };\n  }\n  /** @hidden */\n  extendAttrs(customAttrs) {\n    this.attributeWhitelist = {\n      ...this.defAttributeWhitelist,\n      ...customAttrs\n    };\n  }\n  /** @hidden */\n  sanitizeHtml(input) {\n    input = input.trim();\n    if (input.length === 0) {\n      return '';\n    }\n    this._safeWrapper = this._getSafeWrapper();\n    if (!this._safeWrapper?.iframeDoc) {\n      return '';\n    }\n    this._safeWrapper.iframeDoc.body.innerHTML = input;\n    const resultElement = this._makeSanitizedCopy(this._safeWrapper.iframeDoc.body);\n    this._removeSafeWrapper();\n    return resultElement.innerHTML;\n  }\n  /** @hidden */\n  _makeSanitizedCopy(node) {\n    let newNode = node;\n    if (node.nodeType === Node.TEXT_NODE) {\n      newNode = node.cloneNode(true);\n    } else if (node.nodeType === Node.ELEMENT_NODE && this.tagWhitelist[node.tagName]) {\n      newNode = this._extendLinkTarget(this._implementTag(node));\n    } else {\n      newNode = document.createDocumentFragment();\n    }\n    return newNode;\n  }\n  /** @hidden */\n  _implementTag(node) {\n    const newNode = this._safeWrapper?.iframeDoc?.createElement(node.tagName);\n    if (!newNode) {\n      throw new Error('Failed to create node');\n    }\n    for (const key in this.attributeWhitelist) {\n      if (this.attributeWhitelist[key]) {\n        const allowed = this.attributeWhitelist[key];\n        const origin = node.getAttribute(key);\n        if (key in node || key === 'class') {\n          if (this._uriAttributes[key] && this._validateBySchema(origin)) {\n            continue;\n          }\n          switch (typeof allowed) {\n            case 'string':\n              newNode.setAttribute(key, allowed);\n              break;\n            default:\n              if (allowed && origin) {\n                newNode.setAttribute(key, origin);\n              }\n          }\n        }\n      }\n    }\n    for (const child of Array.from(node.childNodes)) {\n      const subCopy = this._makeSanitizedCopy(child);\n      if (subCopy) {\n        newNode.appendChild(subCopy);\n      }\n    }\n    return newNode;\n  }\n  /** @hidden */\n  _extendLinkTarget(node) {\n    if (node.tagName === 'A') {\n      const hrefAttr = node.getAttribute('href');\n      if (!hrefAttr || /^#/.test(hrefAttr)) {\n        node.removeAttribute('target');\n      } else {\n        const defTarget = this.attributeWhitelist['target'] || '_blank';\n        node.setAttribute('target', defTarget.toString());\n      }\n    }\n    return node;\n  }\n  /** @hidden */\n  _getSafeWrapper() {\n    const iframe = document.createElement('iframe');\n    if (iframe.sandbox === undefined) {\n      console.warn('Your browser does not support sandboxed iframes. Please upgrade to a modern browser.');\n      return null;\n    }\n    iframe.setAttribute('sandbox', 'allow-same-origin');\n    iframe.style.setProperty('display', 'none');\n    document.body.appendChild(iframe);\n    const iframeDoc = iframe.contentDocument || iframe.contentWindow?.document;\n    if (!iframeDoc) {\n      console.warn('Could not resolve document from the provided iframe');\n      return null;\n    }\n    if (!iframeDoc?.body) {\n      iframeDoc.write('<body></body>');\n    }\n    return {\n      iframe,\n      iframeDoc\n    };\n  }\n  /** @hidden */\n  _removeSafeWrapper() {\n    if (this._safeWrapper?.iframe) {\n      document.body.removeChild(this._safeWrapper.iframe);\n    }\n  }\n  /** @hidden */\n  _validateBySchema(value) {\n    return !!value && value.indexOf(':') > -1 && !this._startsWithAny(value, this._schemaWhiteList);\n  }\n  /** @hidden */\n  _startsWithAny(str, substrings) {\n    return !!str && substrings.some(value => str.indexOf(value) === 0);\n  }\n}\n\n/**\n * Formatted-text allowed tags, only this tags will render in component, other will skip;\n *\n * ``` selector: fd-formatted-text ```\n *\n * ```html\n * <fd-formatted-text [htmlText]=\"...\"></fd-formatted-text>\n * ```\n */\nlet FormattedTextComponent = /*#__PURE__*/(() => {\n  class FormattedTextComponent {\n    /** @hidden */\n    constructor(domSanitizer) {\n      this.domSanitizer = domSanitizer;\n      /**\n       * Target attribute for included links.\n       */\n      this.convertedLinksDefaultTarget = '_blank';\n      /** @hidden */\n      this.formattedText = '';\n      this._htmlSanitizer = new HtmlSanitizer();\n    }\n    /** @hidden */\n    ngOnInit() {\n      this.render();\n    }\n    /** @hidden */\n    ngOnChanges(changes) {\n      if ('htmlText' in changes) {\n        this.render();\n      }\n    }\n    /** @hidden */\n    render() {\n      this._htmlSanitizer.extendAttrs({\n        target: this.convertedLinksDefaultTarget\n      });\n      const text = this._htmlSanitizer.sanitizeHtml(this.htmlText ?? '');\n      this.formattedText = this.domSanitizer.bypassSecurityTrustHtml(text.trim());\n    }\n  }\n  FormattedTextComponent.ɵfac = function FormattedTextComponent_Factory(t) {\n    return new (t || FormattedTextComponent)(i0.ɵɵdirectiveInject(i1.DomSanitizer));\n  };\n  FormattedTextComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: FormattedTextComponent,\n    selectors: [[\"fd-formatted-text\"]],\n    hostVars: 9,\n    hostBindings: function FormattedTextComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"innerHTML\", ctx.formattedText, i0.ɵɵsanitizeHtml);\n        i0.ɵɵstyleProp(\"height\", ctx.height)(\"width\", ctx.width);\n        i0.ɵɵclassProp(\"fd-formatted-text-with-height\", ctx.height)(\"fd-formatted-text-with-width\", ctx.width);\n      }\n    },\n    inputs: {\n      htmlText: \"htmlText\",\n      convertedLinksDefaultTarget: \"convertedLinksDefaultTarget\",\n      height: \"height\",\n      width: \"width\"\n    },\n    exportAs: [\"fd-formatted-text\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 0,\n    vars: 0,\n    template: function FormattedTextComponent_Template(rf, ctx) {},\n    styles: [\"fd-formatted-text{display:block}fd-formatted-text.fd-formatted-text-with-height{overflow-y:auto}fd-formatted-text.fd-formatted-text-with-width{overflow-x:auto}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return FormattedTextComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormattedTextModule = /*#__PURE__*/(() => {\n  class FormattedTextModule {}\n  FormattedTextModule.ɵfac = function FormattedTextModule_Factory(t) {\n    return new (t || FormattedTextModule)();\n  };\n  FormattedTextModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FormattedTextModule\n  });\n  FormattedTextModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return FormattedTextModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { FormattedTextComponent, FormattedTextModule };\n//# sourceMappingURL=fundamental-ngx-core-formatted-text.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}