{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, Input, HostBinding, Output, HostListener, ContentChildren, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport { DragDropModule } from '@angular/cdk/drag-drop';\nimport { CardModule } from '@fundamental-ngx/core/card';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport { takeUntil } from 'rxjs/operators';\nimport { Subscription, Subject } from 'rxjs';\nimport * as i1 from '@fundamental-ngx/cdk/utils';\n\n// Card resizes in step of fixed values. values are in pixel\nfunction ResizableCardItemComponent_ng_container_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r9 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 8)(2, \"div\", 9, 10);\n    i0.ɵɵlistener(\"mousedown\", function ResizableCardItemComponent_ng_container_5_Template_div_mousedown_2_listener($event) {\n      i0.ɵɵrestoreView(_r9);\n      const ctx_r8 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r8.onMouseDown($event, \"both\"));\n    });\n    i0.ɵɵelementEnd()();\n    i0.ɵɵelementContainerEnd();\n  }\n}\nfunction ResizableCardItemComponent_ng_container_6_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction ResizableCardItemComponent_ng_container_6_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction ResizableCardItemComponent_ng_container_6_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, ResizableCardItemComponent_ng_container_6_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵtemplate(2, ResizableCardItemComponent_ng_container_6_ng_container_2_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r3 = i0.ɵɵreference(9);\n    const _r5 = i0.ɵɵreference(11);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r5);\n  }\n}\nfunction ResizableCardItemComponent_ng_template_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r14 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 12, 13);\n    i0.ɵɵlistener(\"mousedown\", function ResizableCardItemComponent_ng_template_8_Template_div_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r14);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r13.onMouseDown($event, \"horizontal\"));\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nfunction ResizableCardItemComponent_ng_template_10_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r17 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 14, 15);\n    i0.ɵɵlistener(\"mousedown\", function ResizableCardItemComponent_ng_template_10_Template_div_mousedown_0_listener($event) {\n      i0.ɵɵrestoreView(_r17);\n      const ctx_r16 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r16.onMouseDown($event, \"vertical\"));\n    });\n    i0.ɵɵelementEnd();\n  }\n}\nconst _c0 = [\"*\"];\nconst horizontalResizeStep = 320;\n// vertical resize step\nconst verticalResizeStep = 16;\n// gap of 1rem between the cards\nconst gap = 16;\n// threshold offset for horizontal resizing.\nconst horizontalResizeOffset = 160;\n// threshold offset for vertical resizing.\nconst verticalResizeOffset = 8;\n// card is given numeric value, on which sorting of cards is done\nlet cardRank = 1;\nlet cardUniqueId = 0;\nlet ResizableCardItemComponent = /*#__PURE__*/(() => {\n  class ResizableCardItemComponent {\n    /** Card properties from the config */\n    set config(config) {\n      this._config = config;\n      this._initialSetup();\n      this._cd.detectChanges();\n    }\n    get config() {\n      return this._config;\n    }\n    /**\n     * Serial order of card.\n     * cards are sorted based on ranks before displaying layout.\n     * card with lower rank will be displayed first in layout than the card with higher rank.\n     */\n    set rank(rankValue) {\n      // determine max value between user given value and default value\n      this._rank = rankValue ? rankValue : cardRank++;\n      if (rankValue > cardRank) {\n        cardRank = rankValue;\n      }\n    }\n    get rank() {\n      return this._rank;\n    }\n    /**\n     * Number of column span card width takes.\n     * It will be in step of 20rem.\n     */\n    set cardWidthColSpan(colSpan) {\n      this._cardWidthColSpan = colSpan;\n      this._setCardWidth();\n    }\n    get cardWidthColSpan() {\n      return this._cardWidthColSpan;\n    }\n    /**\n     * Number of row span, card height takes.\n     * It will be in the step of 1rem.\n     */\n    set cardHeightRowSpan(rowSpan) {\n      this._cardHeightRowSpan = rowSpan;\n      this._setCardHeight();\n    }\n    get cardHeightRowSpan() {\n      return this._cardHeightRowSpan;\n    }\n    /**\n     * Number of row span card mini header height takes.\n     * Mini Header: The smallest representation of the card is the header.\n     * The card can be collapsed to only its header height.\n     */\n    set cardMiniHeaderRowSpan(rowSpan) {\n      this._cardMiniHeaderRowSpan = rowSpan;\n      this._setCardMiniHeaderHeight();\n    }\n    get cardMiniHeaderRowSpan() {\n      return this._cardMiniHeaderRowSpan;\n    }\n    /**\n     * Number of row span card mini content height takes.\n     * Mini Content: The minimum height for the card content depends on the card type,\n     * and must be as high as the smallest representation of the content.\n     */\n    set cardMiniContentRowSpan(rowSpan) {\n      this._cardMiniContentRowSpan = rowSpan;\n      this._setCardMiniContentHeight();\n    }\n    get cardMiniContentRowSpan() {\n      return this._cardMiniContentRowSpan ?? 0;\n    }\n    /** @hidden */\n    constructor(_cd, _elementRef, _rtlService) {\n      this._cd = _cd;\n      this._elementRef = _elementRef;\n      this._rtlService = _rtlService;\n      /** set uinque id for the card */\n      this.itemId = `fd-card-item-${cardUniqueId++}`;\n      /** Card can be set to resizable=false, to restrict card resize */\n      this.resizable = true;\n      /** Set top position for the card*/\n      this.top = 0;\n      /** @hidden while resizing this value will change to a greater value */\n      this.zIndex = 0;\n      /** @hidden */\n      this.position = 'absolute';\n      /** @hidden transition animation when layout re-draws */\n      this.reDrawAnimation = true;\n      /** Emits when card is still resizing */\n      this.resizing = new EventEmitter();\n      /** Emits when card resize is completed */\n      this.resized = new EventEmitter();\n      /** Emits when card height is reduced to show only header */\n      this.miniHeaderReached = new EventEmitter();\n      /** Emits when minimum height of card content area is reached */\n      this.miniContentReached = new EventEmitter();\n      /** show corner resize icon on hover over card */\n      this.showingResizeIcon = false;\n      /** show border when card is resizing */\n      this.showBorder = false;\n      /** card width in px. Default value to 20rem */\n      this.cardWidth = horizontalResizeStep;\n      /** Outer resize indication border width for the card */\n      this.resizeIndicationBorderWidth = 0;\n      /**\n       * Denotes if card is currently expanding or contracting horizontally.\n       * +1 denotes increasing, -1 denotes decreasing and 0 denotes card-state has not changed horizontally.\n       */\n      this.cardState = 0;\n      /** Change in rank from previous value*/\n      this.prevRank = 0;\n      /** @hidden Default width of card is 20rem ie. 1 column */\n      this._cardWidthColSpan = 1;\n      /** @hidden flag to control resize */\n      this._resize = false;\n      /**\n       * @hidden stores original width span of card.\n       * It may reduce on small screen, so have to restore using this.\n       */\n      this._originalCardWidthSpan = 0;\n      /** @hidden */\n      this._rtl = false;\n      /** @hidden */\n      this._subscriptions = new Subscription();\n      if (this._rtlService) {\n        this._subscriptions.add(this._rtlService.rtl.subscribe(value => this._rtl = value));\n      }\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscriptions.unsubscribe();\n    }\n    /**\n     * When resize handler is pressed and resizing may start.\n     * @param event: MouseEvent\n     * @param resizeDirection: which handler is pressed to resize\n     */\n    onMouseDown(event, resizeDirection) {\n      event.preventDefault();\n      if (!this.resizable) {\n        return;\n      }\n      this.showingResizeIcon = true;\n      this._resize = true;\n      this._prevX = event.clientX;\n      this._prevY = event.clientY;\n      this._prevCardWidth = this.cardWidth;\n      this._prevCardHeight = this.cardHeight;\n      this._resizeDirection = resizeDirection;\n    }\n    /**\n     * @hidden When mouse moves to resize the card.\n     * using window:mousemove so, resize will happen smoothly\n     * @param event: MouseEvent\n     */\n    onMouseMove(event) {\n      event.preventDefault();\n      if (!this.resizable) {\n        return;\n      }\n      // saves from un-necessary resize\n      if (!this._resize) {\n        return;\n      }\n      if (!this.showBorder) {\n        this.showBorder = true;\n      }\n      // resizing card will go over other cards\n      this.zIndex = 1;\n      const {\n        clientX,\n        clientY\n      } = event;\n      switch (this._resizeDirection) {\n        case 'both':\n          this._horizontalResizing(clientX);\n          this._verticalResizing(clientY);\n          break;\n        case 'horizontal':\n          this._horizontalResizing(clientX);\n          break;\n        case 'vertical':\n          this._verticalResizing(clientY);\n          break;\n        default:\n          this._horizontalResizing(clientX);\n          this._verticalResizing(clientY);\n      }\n      const cardWidthColSpan = Math.floor(this.cardWidth / horizontalResizeStep);\n      const cardWidthWithColumn = cardWidthColSpan * horizontalResizeStep + cardWidthColSpan * gap;\n      const horizontalResizeThresholdReached = this.cardWidth - cardWidthWithColumn > horizontalResizeOffset;\n      if (clientX > this._prevX) {\n        // increasing width\n        this.cardState = 1;\n        if (horizontalResizeThresholdReached) {\n          const futureCardWidth = (cardWidthColSpan + 1) * horizontalResizeStep + cardWidthColSpan * gap;\n          this.resizeIndicationBorderWidth = futureCardWidth - this.cardWidth;\n        } else {\n          this.resizeIndicationBorderWidth = 0;\n        }\n      } else if (clientX < this._prevX) {\n        // decreasing width\n        this.cardState = -1;\n        if (horizontalResizeThresholdReached) {\n          const futureCardWidth = (cardWidthColSpan + 1) * horizontalResizeStep + cardWidthColSpan * gap;\n          this.resizeIndicationBorderWidth = futureCardWidth - this.cardWidth;\n        } else {\n          this.resizeIndicationBorderWidth = 0;\n        }\n      }\n      this._prevX = clientX;\n      this._prevY = clientY;\n      this._cd.detectChanges();\n      // Emits resizing event.\n      this.resizing.emit(this.getResizedEventObject());\n    }\n    /**\n     * when resizing of card stops\n     * @param event: MouseEvent\n     */\n    onMouseUp() {\n      if (!this.resizable) {\n        return;\n      }\n      // if card was not resizing\n      if (!this._resize) {\n        return;\n      }\n      // increase/decrease width of card in order of 20rem\n      if (Math.abs(this.cardWidth - this._prevCardWidth) > 0) {\n        this._horizontalStepResizing();\n      }\n      // increase/decrease height of card in order of 1rem\n      if (Math.abs(this.cardHeight - this._prevCardHeight) > 0) {\n        this._verticalStepResizing();\n      }\n      this._stopResizing();\n      this._cd.markForCheck();\n    }\n    /** Sets focus on the element */\n    focus() {\n      const header = this._elementRef.nativeElement.querySelector('.fd-card__header');\n      header?.focus();\n    }\n    /** Shows resize icon */\n    showResizeIcon() {\n      if (!this.resizable) {\n        return;\n      }\n      this.showingResizeIcon = true;\n    }\n    /** Hides resize icon */\n    hideResizeIcon() {\n      if (!this._resize) {\n        this.showingResizeIcon = false;\n      }\n    }\n    /** Returns max width for card, based on layout size passed */\n    getMaxColSpan(layoutSize) {\n      switch (layoutSize) {\n        case 'sm':\n          this._maxColumn = 1;\n          break;\n        case 'md':\n          this._maxColumn = 2;\n          break;\n        case 'lg':\n          this._maxColumn = 3;\n          break;\n        case 'xl':\n          this._maxColumn = 4;\n          break;\n        default:\n          this._maxColumn = 1;\n      }\n      return this._maxColumn;\n    }\n    /** Update card width if it exceeds column span based on layout */\n    verifyUpdateCardWidth(layoutSize) {\n      const widthColSpan = this._config?.cardWidthColSpan || this.cardWidthColSpan;\n      // storing original width of card.\n      // used to restore width on window resize from small to large\n      this._originalCardWidthSpan = !this._originalCardWidthSpan ? widthColSpan : this._originalCardWidthSpan;\n      this._maxColumn = this.getMaxColSpan(layoutSize);\n      if (widthColSpan > this._maxColumn) {\n        this.cardWidthColSpan = this._maxColumn;\n        this._setCardWidth();\n        // Emits resized event.\n        this.resized.emit(this.getResizedEventObject());\n      } else {\n        // keep card width minimum, so it can fit in screen.\n        this.cardWidthColSpan = Math.min(this._maxColumn, this._originalCardWidthSpan);\n        this._setCardWidth();\n        // Emits resized event.\n        this.resized.emit(this.getResizedEventObject());\n      }\n    }\n    /** @hidden */\n    elementRef() {\n      return this._elementRef;\n    }\n    /** Returns ResizedEvent object to emit. */\n    getResizedEventObject() {\n      const newCardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n      const newCardWidthColSpan = Math.floor(this.cardWidth / horizontalResizeStep);\n      const newCardWidth = newCardWidthColSpan * horizontalResizeStep + newCardWidthColSpan * gap;\n      const horizontalResizeThresholdReached = this.cardWidth - newCardWidth > horizontalResizeOffset;\n      const newCardColSpan = horizontalResizeThresholdReached ? newCardWidthColSpan + 1 : newCardWidthColSpan;\n      return new ResizedEvent(this, this._prevCardWidth, this._prevCardHeight, this.cardWidth, this.cardHeight, this._cardWidthColSpan, this._cardHeightRowSpan, newCardColSpan, newCardHeightRowSpan);\n    }\n    /** @hidden Return previous height row span of the card */\n    get previousCardHeightRowSpan() {\n      return this._prevCardHeightRowSpan;\n    }\n    /** @hidden Set card properties using config received */\n    _initialSetup() {\n      this.cardWidthColSpan = this._config?.cardWidthColSpan || this.cardWidthColSpan;\n      this.cardHeightRowSpan = this._config?.cardHeightRowSpan || this.cardHeightRowSpan;\n      this.title = this._config?.title || this.title;\n      this.rank = this._config?.rank || this.rank;\n      this.cardMiniHeaderRowSpan = this._config?.cardMiniHeaderRowSpan || this.cardMiniHeaderRowSpan;\n      this.cardMiniContentRowSpan = this._config?.cardMiniContentRowSpan || this.cardMiniContentRowSpan;\n      this.resizable = this._config.resizable || this.resizable;\n    }\n    /** @hidden Returns true when resize offset is crossed */\n    _horizontalResizeWithOffset() {\n      // positive value indicates that width has increased\n      const widthIncrement = this.cardWidth - this._prevCardWidth;\n      const cardSpan = Math.floor(this.cardWidth / horizontalResizeStep);\n      const cardSpanFraction = this.cardWidth % horizontalResizeStep;\n      // when width increases\n      if (widthIncrement > 0) {\n        if (widthIncrement < horizontalResizeOffset + gap) {\n          // widthIncrement is less than offset, do not increase width\n          this.cardWidth = this._prevCardWidth;\n        } else {\n          // check value of cardSpanFraction, including gaps in cards\n          let isCardSpanFractionCrossingOffset = false;\n          isCardSpanFractionCrossingOffset = cardSpanFraction - (cardSpan - 1) * gap > horizontalResizeOffset;\n          this.cardWidth = isCardSpanFractionCrossingOffset ? (cardSpan + 1) * horizontalResizeStep : cardSpan * horizontalResizeStep;\n        }\n      } else {\n        // when width decreases\n        if (Math.abs(widthIncrement) < horizontalResizeOffset) {\n          // widthIncrement is less than offset, do not decrease width\n          this.cardWidth = this._prevCardWidth;\n        } else {\n          // check value of cardSpanFraction, including gaps in cards\n          let isCardSpanFractionCrossingOffset = false;\n          isCardSpanFractionCrossingOffset = cardSpanFraction - cardSpan * gap > horizontalResizeOffset;\n          this.cardWidth = isCardSpanFractionCrossingOffset ? (cardSpan + 1) * horizontalResizeStep : cardSpan * horizontalResizeStep;\n        }\n      }\n    }\n    /**\n     * @hidden make horizontal resize only on step of 20rem\n     */\n    _horizontalStepResizing() {\n      this._horizontalResizeWithOffset();\n      // Add inner gap in  cardWidth if width is more than 1 column\n      if (this.cardWidth > horizontalResizeStep) {\n        this.cardWidth = this.cardWidth + (this.cardWidth / horizontalResizeStep - 1) * gap;\n      }\n      this.cardWidthColSpan = Math.floor(this.cardWidth / horizontalResizeStep);\n    }\n    /**\n     * @hidden make vertical resize only on step of 1rem\n     */\n    _verticalStepResizing() {\n      // positive value indicates that height has increased\n      const cardHeightSpan = Math.floor(this.cardHeight / verticalResizeStep);\n      const cardSpanFraction = this.cardHeight % verticalResizeStep;\n      this.cardHeight = cardSpanFraction > verticalResizeOffset ? (cardHeightSpan + 1) * verticalResizeStep : cardHeightSpan * verticalResizeStep;\n      this.cardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n    }\n    /**\n     * @hidden Resize card horizontally by checking boundary condition\n     * @param xPosition: current x-position of cursor\n     */\n    _horizontalResizing(xPosition) {\n      const difference = this._prevX - xPosition;\n      this.cardWidth = this._rtl ? this.cardWidth + difference : this.cardWidth - difference;\n      const totalIndentation = (this._maxColumn - 1) * gap;\n      const maxCardWidtWithoutIndentation = this._maxColumn * horizontalResizeStep;\n      const maxCardWidth = this._rtl ? maxCardWidtWithoutIndentation - totalIndentation : maxCardWidtWithoutIndentation + totalIndentation;\n      if (this.cardWidth > maxCardWidth) {\n        this.cardWidth = maxCardWidth;\n      } else if (this.cardWidth < horizontalResizeStep) {\n        this.cardWidth = horizontalResizeStep;\n      }\n    }\n    /**\n     * @hidden Resize card vertically.\n     * takes care of mini-header height and mini-content height\n     * @param yPosition: current y-position of cursor\n     */\n    _verticalResizing(yPosition) {\n      let reachingMiniHeader = false;\n      if (this.cardHeight === this.cardMiniHeaderHeight) {\n        // if card height is already at mini-header height\n        if (this._prevY - yPosition > 0) {\n          // decreasing height\n          // if miniHeader height reached, stop resizing\n          this.cardHeight = this.cardMiniHeaderHeight;\n          this._prevCardHeightRowSpan = this._cardHeightRowSpan;\n          this._cardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n        } else {\n          // increasing height\n          this.cardHeight = this.cardMiniHeaderHeight + this.cardMiniContentHeight;\n          this._prevCardHeightRowSpan = this._cardHeightRowSpan;\n          this._cardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n          this._stopResizing();\n          this.miniContentReached.emit(this.getResizedEventObject());\n        }\n      } else if (this.cardHeight < this.cardMiniContentHeight + this.cardMiniHeaderHeight) {\n        // if card height is between mini-header and mini-content\n        if (this._prevY - yPosition < 0) {\n          this.cardHeight = this.cardMiniHeaderHeight + this.cardMiniContentHeight;\n          this._prevCardHeightRowSpan = this._cardHeightRowSpan;\n          this._cardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n          this._stopResizing();\n          this.miniContentReached.emit(this.getResizedEventObject());\n        }\n      } else if (this.cardHeight === this.cardMiniContentHeight + this.cardMiniHeaderHeight && this._prevY - yPosition > 0) {\n        // decreasing height\n        // height decreasing after reaching mini-content. this needs to differentiate\n        // from height decreasing and reaching to mini-content.\n        reachingMiniHeader = true;\n        this.cardHeight = this.cardMiniHeaderHeight;\n        this._prevCardHeightRowSpan = this._cardHeightRowSpan;\n        this._cardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n        // miniHeader height reached, stop resizing\n        this._stopResizing();\n        this.miniHeaderReached.emit(this.getResizedEventObject());\n      } else {\n        this.cardHeight = this.cardHeight - (this._prevY - yPosition);\n        this._prevCardHeightRowSpan = this._cardHeightRowSpan;\n        this._cardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n      }\n      // stop resizing on miniContent height\n      if (this.cardHeight <= this.cardMiniContentHeight + this.cardMiniHeaderHeight && this._prevY - yPosition > 0 && !reachingMiniHeader) {\n        this.cardHeight = this.cardMiniContentHeight + this.cardMiniHeaderHeight;\n        this._prevCardHeightRowSpan = this._cardHeightRowSpan;\n        this._cardHeightRowSpan = Math.floor(this.cardHeight / verticalResizeStep);\n        this.miniContentReached.emit(this.getResizedEventObject());\n        this._stopResizing();\n      }\n      // while corner resize, width might have increased and reached to mini-content height.\n      // so, on mini-content resize will stop, but have to do step resizing for vertical and horizontal.\n      if (!this._resize) {\n        // increase/decrease width of card in order of 20rem\n        if (Math.abs(this.cardWidth - this._prevCardWidth) > 0) {\n          this._horizontalStepResizing();\n        }\n        // increase/decrease height of card in order of 1rem\n        if (Math.abs(this.cardHeight - this._prevCardHeight) > 0) {\n          this._verticalStepResizing();\n        }\n      }\n    }\n    /** @hidden reset involved variables while resizing */\n    _stopResizing() {\n      if (this._resize) {\n        this.cardState = 0;\n        this.resizeIndicationBorderWidth = 0;\n        this._resize = false;\n        this.zIndex = 0;\n        this.showBorder = false;\n        this.resized.emit(this.getResizedEventObject());\n      }\n    }\n    /** @hidden Returns cardWidth based on card column span */\n    _setCardWidth() {\n      this.cardWidth = this._cardWidthColSpan * horizontalResizeStep + (this._cardWidthColSpan - 1) * gap;\n      this._cd.markForCheck();\n    }\n    /** @hidden Returns cardHeight based on card row span */\n    _setCardHeight() {\n      this.cardHeight = this._cardHeightRowSpan * verticalResizeStep;\n      this._cd.markForCheck();\n    }\n    /** @hidden Returns card mini header height */\n    _setCardMiniHeaderHeight() {\n      this.cardMiniHeaderHeight = this._cardMiniHeaderRowSpan * verticalResizeStep;\n      this._cd.markForCheck();\n    }\n    /** @hidden Returns card mini content height */\n    _setCardMiniContentHeight() {\n      this.cardMiniContentHeight = this.cardMiniContentRowSpan * verticalResizeStep;\n      this._cd.markForCheck();\n    }\n  }\n  ResizableCardItemComponent.ɵfac = function ResizableCardItemComponent_Factory(t) {\n    return new (t || ResizableCardItemComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.RtlService, 8));\n  };\n  ResizableCardItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ResizableCardItemComponent,\n    selectors: [[\"fd-resizable-card-item\"]],\n    hostVars: 12,\n    hostBindings: function ResizableCardItemComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousemove\", function ResizableCardItemComponent_mousemove_HostBindingHandler($event) {\n          return ctx.onMouseMove($event);\n        }, false, i0.ɵɵresolveWindow)(\"mouseup\", function ResizableCardItemComponent_mouseup_HostBindingHandler($event) {\n          return ctx.onMouseUp($event);\n        }, false, i0.ɵɵresolveDocument);\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"left\", ctx.left, \"px\")(\"right\", ctx.right, \"px\")(\"top\", ctx.top, \"px\")(\"z-index\", ctx.zIndex)(\"position\", ctx.position);\n        i0.ɵɵclassProp(\"fd-resizable-card-layout__draw-transition\", ctx.reDrawAnimation);\n      }\n    },\n    inputs: {\n      config: \"config\",\n      itemId: \"itemId\",\n      title: \"title\",\n      rank: \"rank\",\n      cardWidthColSpan: \"cardWidthColSpan\",\n      cardHeightRowSpan: \"cardHeightRowSpan\",\n      cardMiniHeaderRowSpan: \"cardMiniHeaderRowSpan\",\n      cardMiniContentRowSpan: \"cardMiniContentRowSpan\",\n      resizable: \"resizable\",\n      left: \"left\",\n      right: \"right\",\n      top: \"top\"\n    },\n    outputs: {\n      resizing: \"resizing\",\n      resized: \"resized\",\n      miniHeaderReached: \"miniHeaderReached\",\n      miniContentReached: \"miniContentReached\"\n    },\n    ngContentSelectors: _c0,\n    decls: 12,\n    vars: 12,\n    consts: [[1, \"fd-resizable-card-layout__item\"], [\"resizeCard\", \"\"], [1, \"fd-resizable-card-layout__item--border-display\", \"fd-resizable-card-layout__item--resize-transition\", 3, \"mouseenter\", \"mouseleave\"], [1, \"fd-resizable-card-layout__card\"], [4, \"ngIf\"], [1, \"fd-resizable-card-layout__item--resize-transition\"], [\"verticalHandleTemplate\", \"\"], [\"horizontalHandleTemplate\", \"\"], [1, \"fd-resizable-card-layout__icon-wrapper\"], [1, \"fd-resizable-card-layout__icon\", 3, \"mousedown\"], [\"cornerHandle\", \"\"], [4, \"ngTemplateOutlet\"], [1, \"fd-resizable-card-layout__resize--vertical\", 3, \"mousedown\"], [\"verticalHandle\", \"\"], [1, \"fd-resizable-card-layout__resize--horizontal\", 3, \"mousedown\"], [\"horizontalHandle\", \"\"]],\n    template: function ResizableCardItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0, 1)(2, \"div\", 2);\n        i0.ɵɵlistener(\"mouseenter\", function ResizableCardItemComponent_Template_div_mouseenter_2_listener() {\n          return ctx.showResizeIcon();\n        })(\"mouseleave\", function ResizableCardItemComponent_Template_div_mouseleave_2_listener() {\n          return ctx.hideResizeIcon();\n        });\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵprojection(4);\n        i0.ɵɵtemplate(5, ResizableCardItemComponent_ng_container_5_Template, 4, 0, \"ng-container\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(6, ResizableCardItemComponent_ng_container_6_Template, 3, 2, \"ng-container\", 4);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(7, \"div\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, ResizableCardItemComponent_ng_template_8_Template, 2, 0, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(10, ResizableCardItemComponent_ng_template_10_Template, 2, 0, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"fd-resizable-card-layout__indication-border\", ctx.showBorder);\n        i0.ɵɵadvance(2);\n        i0.ɵɵstyleProp(\"width\", ctx.cardWidth, \"px\")(\"height\", ctx.cardHeight, \"px\");\n        i0.ɵɵadvance(3);\n        i0.ɵɵproperty(\"ngIf\", ctx.showingResizeIcon);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.resizable);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx.resizeIndicationBorderWidth, \"px\")(\"height\", ctx.cardHeight, \"px\");\n      }\n    },\n    dependencies: [i2.NgIf, i2.NgTemplateOutlet],\n    styles: [\"/*!\\n * Fundamental Library Styles v0.28.3\\n * Copyright (c) 2023 SAP SE or an SAP affiliate company.\\n * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/main/LICENSE)\\n */.fd-resizable-card-layout{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:1rem 0 0;padding:0 .5rem;position:relative}.fd-resizable-card-layout:after,.fd-resizable-card-layout:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__item{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);display:flex;flex-direction:row;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;min-width:20rem;padding:0;position:relative}.fd-resizable-card-layout__item:after,.fd-resizable-card-layout__item:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__card{-webkit-box-sizing:border-box;-webkit-box-ordinal-group:2;-ms-flex-order:1;-webkit-box-flex:1;-ms-flex:1;border:0;box-sizing:border-box;color:var(--sapTextColor);flex:1;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:calc(100% - .0625rem);line-height:var(--sapContent_LineHeight);margin:0;order:1;padding:0;position:relative}.fd-resizable-card-layout__card:after,.fd-resizable-card-layout__card:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__icon-wrapper{-webkit-box-sizing:border-box;border:0;bottom:0;box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:1rem;line-height:var(--sapContent_LineHeight);margin:0;padding:0 .0625rem .0625rem 0;position:absolute;right:0;width:1rem;z-index:2}.fd-resizable-card-layout__icon-wrapper:after,.fd-resizable-card-layout__icon-wrapper:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__icon-wrapper[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon-wrapper{left:0;padding:0 0 .0625rem .0625rem;right:auto}.fd-resizable-card-layout__icon{-webkit-box-sizing:border-box;border:0;bottom:0;box-sizing:border-box;color:var(--sapTextColor);color:var(--sapButton_IconColor);cursor:nwse-resize;font-family:var(--sapFontFamily);font-family:SAP-icons;font-size:var(--sapFontSize);font-size:1rem;font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);line-height:1rem;margin:0;padding:0;position:absolute;right:.0625rem;z-index:2}.fd-resizable-card-layout__icon:after,.fd-resizable-card-layout__icon:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__icon:before{content:\\\"\\\\e24f\\\";font-family:SAP-icons;text-align:center;text-decoration:inherit;text-rendering:optimizeLegibility;text-transform:none}.fd-resizable-card-layout__icon[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon{-webkit-transform:rotate(90deg);cursor:nesw-resize;padding:0 .0625rem .0625rem .5rem;position:relative;transform:rotate(90deg)}.fd-resizable-card-layout__icon--vertical,.fd-resizable-card-layout__icon--vertical[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon--vertical{cursor:ns-resize}.fd-resizable-card-layout__icon--horizontal,.fd-resizable-card-layout__icon--horizontal[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon--horizontal{cursor:ew-resize}.fd-resizable-card-layout__resize--vertical{-webkit-box-ordinal-group:3;-ms-flex-order:2;cursor:ew-resize;order:2;width:.0625rem;z-index:2}.fd-resizable-card-layout__resize--vertical::content{content:\\\"\\\";position:absolute}.fd-resizable-card-layout__resize--horizontal{bottom:0;cursor:ns-resize;height:.0625rem;position:absolute;width:calc(100% - .5rem);z-index:2}.fd-resizable-card-layout__indication-border{-webkit-box-sizing:border-box;border:0;border:.125rem dashed var(--sapContent_DragAndDropActiveColor);box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;padding:0}.fd-resizable-card-layout__indication-border:after,.fd-resizable-card-layout__indication-border:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout--sm{padding-left:.5rem;padding-right:.5rem}.fd-resizable-card-layout--lg,.fd-resizable-card-layout--md{padding-left:1rem;padding-right:1rem}.fd-resizable-card-layout--xl{padding-left:3rem;padding-right:3rem}.fd-resizable-card-layout__item--resize-transition{transition-duration:.25s;animation-timing-function:ease-in-out}.fd-resizable-card-layout__draw-transition{transition-duration:.5s;animation-timing-function:ease-in}.fd-resizable-card-layout__item--border-display{display:flex}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return ResizableCardItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Object to emit on resize complete */\nclass ResizedEvent {\n  /**\n   * Object to emit on resize complete\n   * @param card\n   * @param prevCardWidth Previous card width\n   * @param prevCardHeight Previous card height\n   * @param cardWidth Current card width\n   * @param cardHeight Current card height\n   * @param cardWidthColSpan Current card width column span\n   * @param cardHeightRowSpan Current card height row span\n   * @param newCardWidthColSpan New card width column span\n   * @param newCardHeightRowSpan New card height row span\n   */\n  constructor(card, prevCardWidth, prevCardHeight, cardWidth, cardHeight, cardWidthColSpan, cardHeightRowSpan, newCardWidthColSpan, newCardHeightRowSpan) {\n    this.card = card;\n    this.prevCardWidth = prevCardWidth;\n    this.prevCardHeight = prevCardHeight;\n    this.cardWidth = cardWidth;\n    this.cardHeight = cardHeight;\n    this.cardWidthColSpan = cardWidthColSpan;\n    this.cardHeightRowSpan = cardHeightRowSpan;\n    this.newCardWidthColSpan = newCardWidthColSpan;\n    this.newCardHeightRowSpan = newCardHeightRowSpan;\n  }\n}\nlet ResizableCardLayoutComponent = /*#__PURE__*/(() => {\n  class ResizableCardLayoutComponent {\n    /** @hidden */\n    constructor(_cd, _elementRef, _rtlService) {\n      this._cd = _cd;\n      this._elementRef = _elementRef;\n      this._rtlService = _rtlService;\n      /** Emits when card resize is reached to one new step in horizontal or vertical direction */\n      this.stepChange = new EventEmitter();\n      /** Emits when card is still resizing */\n      this.resizing = new EventEmitter();\n      /** Emits when card resize is completed */\n      this.resized = new EventEmitter();\n      /** Emits when card height is reduced to show only header */\n      this.miniHeaderReached = new EventEmitter();\n      /** Emits when minimum height of card content area is reached */\n      this.miniContentReached = new EventEmitter();\n      /** Emits when layout changes */\n      this.layoutChange = new EventEmitter();\n      /** @hidden */\n      this._destroy$ = new Subject();\n      /** @hidden */\n      this._layoutShifted = false;\n      /** @hidden */\n      this._directionPosition = 'left';\n    }\n    /** @hidden */\n    ngOnInit() {\n      this._columnsHeight = new Array(this._columns);\n      this._columnsHeight.fill(0);\n      // initialise value 0\n      this._subscribeToRtl();\n      // detect initial window size and set layout\n      this._createLayout();\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      this._initialSetup();\n      // listen for query-list change\n      this.resizeCardItems?.forEach(card => {\n        card?.verifyUpdateCardWidth(this.layoutSize);\n      });\n      this.resizeCardItems.changes.subscribe(() => {\n        this.arrangeCards(this.resizeCardItems?.toArray());\n      });\n      this.arrangeCards(this.resizeCardItems?.toArray());\n      this._cd.markForCheck();\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._accessibilitySetup();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._destroy$.next();\n      this._destroy$.complete();\n      this._keyboardEventsManager?.destroy();\n    }\n    /** @hidden handles keyboard accessibility */\n    handleKeydown(event) {\n      event.stopImmediatePropagation();\n      if (!this._keyboardEventsManager.activeItemIndex) {\n        this._keyboardEventsManager.setFirstItemActive();\n      }\n      if (this._keyboardEventsManager) {\n        this._keyboardEventsManager.onKeydown(event);\n      }\n    }\n    /** @hidden */\n    onResize() {\n      this._createLayout();\n    }\n    /** Layout size. Available options are 'sm', 'md', 'lg' and 'xl' */\n    set layoutSize(layoutSize) {\n      this._layout = layoutSize;\n    }\n    get layoutSize() {\n      return this._layout;\n    }\n    /**\n     * Arranges cards in layout based on rank, width and height of card\n     * @param cards: Array of ResizableCardItemComponent\n     */\n    arrangeCards(cards) {\n      this._columnsHeight = new Array(this._columns);\n      this._columnsHeight.fill(0);\n      // sort based on the card rank\n      this._sortedCards = cards?.sort(this._sortCards);\n      this._sortedCards?.forEach((card, index) => {\n        this._setCardPositionValues(card, index);\n        this._updateColumnsHeight(card);\n      });\n      this.layoutHeight = Math.max.apply(null, this._columnsHeight) + verticalResizeStep;\n      this._emitLayoutChange();\n      this._cd.markForCheck();\n    }\n    /**\n     * Handles shifting of cards with animation, while card is still resizing.\n     * @param event: ResizedEvent\n     */\n    cardResizing(event) {\n      this.resizing.emit(event);\n      this._handleHorizontalResize(event);\n      this._handleVerticalResize(event);\n    }\n    /**\n     * Handles arrangement of cards in layout\n     * @param event: ResizedEvent\n     */\n    cardResizeComplete(event) {\n      this._layoutShifted = false;\n      this.arrangeCards(this.resizeCardItems.toArray());\n      this.resized.emit(event);\n    }\n    /** @hidden */\n    elementRef() {\n      return this._elementRef;\n    }\n    /** @hidden */\n    updateLayout() {\n      this.resizeCardItems?.forEach(card => {\n        card?.verifyUpdateCardWidth(this.layoutSize);\n      });\n      this.arrangeCards(this.resizeCardItems?.toArray());\n    }\n    /**\n     * method to get screen width\n     * @returns Window width in px\n     */\n    getWidthAvailable() {\n      return window.innerWidth;\n    }\n    /** @hidden Subscribe to events from items */\n    _initialSetup() {\n      // listen for resizing event of card item\n      this.resizeCardItems?.forEach((resizeCardItem, index) => {\n        if (this.layoutConfig && this.layoutConfig.length >= index + 1) {\n          resizeCardItem.config = this.layoutConfig[index];\n        }\n        resizeCardItem.resizing.pipe(takeUntil(this._destroy$)).subscribe(event => this.cardResizing(event));\n        // listen for resize complete event of card item\n        resizeCardItem.resized.pipe(takeUntil(this._destroy$)).subscribe(event => this.cardResizeComplete(event));\n        // listen for mini-header height event of card item\n        resizeCardItem.miniHeaderReached.pipe(takeUntil(this._destroy$)).subscribe(event => {\n          this.miniHeaderReached.emit(event);\n          this.stepChange.emit(event);\n        });\n        // listen for mini-content height event of card item\n        resizeCardItem.miniContentReached.pipe(takeUntil(this._destroy$)).subscribe(event => {\n          this.miniContentReached.emit(event);\n          this.stepChange.emit(event);\n        });\n      });\n    }\n    /** @hidden */\n    _accessibilitySetup() {\n      this._keyboardEventsManager?.destroy();\n      this._keyboardEventsManager = new FocusKeyManager(this.resizeCardItems).withWrap();\n    }\n    /** @hidden create layout based on layout size */\n    _createLayout() {\n      const screenWidth = this.getWidthAvailable();\n      const prevLayoutSize = this.layoutSize;\n      if (screenWidth > 0 && screenWidth <= 656 && prevLayoutSize !== 'sm') {\n        this.layoutSize = 'sm';\n        this._setLayoutColumns(this.layoutSize);\n        this.updateLayout();\n      } else if (screenWidth > 656 && screenWidth <= 975 && prevLayoutSize !== 'md') {\n        this.layoutSize = 'md';\n        this._setLayoutColumns(this.layoutSize);\n        this.updateLayout();\n      } else if (screenWidth > 975 && screenWidth <= 1359 && prevLayoutSize !== 'lg') {\n        this.layoutSize = 'lg';\n        this._setLayoutColumns(this.layoutSize);\n        this.updateLayout();\n      } else if (screenWidth > 1359 && prevLayoutSize !== 'xl') {\n        this.layoutSize = 'xl';\n        this._setLayoutColumns(this.layoutSize);\n        this.updateLayout();\n      }\n    }\n    /** @hidden Emit layoutChange event with updated card dimensions */\n    _emitLayoutChange() {\n      const latestCardConfig = [];\n      this.resizeCardItems?.forEach(card => {\n        const cardConfig = {};\n        cardConfig.cardWidthColSpan = card.cardWidthColSpan;\n        cardConfig.cardHeightRowSpan = card.cardHeightRowSpan;\n        cardConfig.rank = card.rank;\n        cardConfig.title = card.title;\n        cardConfig.cardMiniContentRowSpan = card.cardMiniContentRowSpan;\n        cardConfig.cardMiniHeaderRowSpan = card.cardMiniHeaderRowSpan;\n        cardConfig.resizable = card.resizable;\n        latestCardConfig.push(cardConfig);\n      });\n      this.layoutChange.emit(latestCardConfig);\n    }\n    /**\n     * @hidden Sets number of column in layout, based on LayoutSize passed\n     * @param layoutSize: Available options are 'sm' | 'md' | 'lg' | 'xl'\n     */\n    _setLayoutColumns(layoutSize) {\n      let layoutWidthDefault;\n      switch (layoutSize) {\n        case 'sm':\n          this._columns = 1;\n          this._paddingLeft = 8;\n          layoutWidthDefault = this._columns * horizontalResizeStep + 2 * this._paddingLeft;\n          this.layoutWidth = layoutWidthDefault;\n          break;\n        case 'md':\n          this._columns = 2;\n          this._paddingLeft = 16;\n          layoutWidthDefault = this._columns * horizontalResizeStep + 2 * this._paddingLeft;\n          this.layoutWidth = layoutWidthDefault + gap;\n          break;\n        case 'lg':\n          this._columns = 3;\n          this._paddingLeft = 16;\n          layoutWidthDefault = this._columns * horizontalResizeStep + 2 * this._paddingLeft;\n          this.layoutWidth = layoutWidthDefault + 2 * gap;\n          break;\n        case 'xl':\n          this._columns = 4;\n          this._paddingLeft = 48;\n          layoutWidthDefault = this._columns * horizontalResizeStep + 2 * this._paddingLeft;\n          this.layoutWidth = layoutWidthDefault + 3 * gap;\n          break;\n        default:\n          this._columns = 4;\n          this._paddingLeft = 48;\n          layoutWidthDefault = this._columns * horizontalResizeStep + 2 * this._paddingLeft;\n          this.layoutWidth = layoutWidthDefault + 3 * gap;\n      }\n    }\n    /**\n     * @hidden Method to handle card vertical resize and trigger the layout change\n     * @param event: ResizedEvent\n     */\n    _handleVerticalResize(event) {\n      if (event.card.cardHeightRowSpan !== event.card.previousCardHeightRowSpan) {\n        this.arrangeCards(this._sortedCards);\n        this._cd.markForCheck();\n        this.stepChange.emit(event.card.getResizedEventObject());\n      }\n    }\n    /**\n     * @hidden Method to handle card horizontal resize and trigger the layout change\n     * @param event : ResizedEvent\n     */\n    _handleHorizontalResize(event) {\n      // when increasing width hit the offset, show extended border and start pushing down border cards\n      // when width is decreasing , show extended border till it reaches to offset.\n      const cardWidthChange = event.cardWidth - event.prevCardWidth;\n      const currentResizingItemIndex = this._sortedCards?.findIndex(x => x.rank === event.card.rank);\n      if (event.cardWidth > event.prevCardWidth) {\n        // when increasing size\n        // card width increasing currently\n        if (event.card.cardState === 1 && cardWidthChange > horizontalResizeOffset + gap && !this._layoutShifted) {\n          // index of this card, then get next card. exchange ranks\n          this._sortedCards.forEach((card, index) => {\n            if (index > currentResizingItemIndex) {\n              // if there are some cards on same height. make the current card rank higher than these.\n              // otherwise next index where it will fit. until any card has less column span than total columns\n              // if only in next top, one card is taking full columns\n              if (card.startingColumnPosition + card.cardWidthColSpan === this._columns && card.cardWidthColSpan !== this._columns) {\n                // get cards with top > current top , but minimum of it\n                // exchange rank with these card\n                this._moveCardDown(index);\n              }\n            }\n          });\n          this._layoutShifted = true;\n          this.arrangeCards(this._sortedCards);\n          this.stepChange.emit(event.card.getResizedEventObject());\n        } else if (event.card.cardState === -1 && cardWidthChange < horizontalResizeOffset + gap && this._layoutShifted) {\n          // card width decreasing currently\n          // move up the cards, if it was shifted while increasing the width\n          this._sortedCards.forEach(card => {\n            card.rank = card.prevRank ? card.prevRank : card.rank;\n            card.prevRank = 0;\n          });\n          this._layoutShifted = false;\n          this.arrangeCards(this._sortedCards);\n          this.stepChange.emit(event.card.getResizedEventObject());\n        }\n      } else if (event.cardWidth < event.prevCardWidth) {\n        // when decreasing size\n        if (event.card.cardState === -1 && -cardWidthChange > horizontalResizeOffset && !this._layoutShifted) {\n          // card width decreasing currently\n          this._layoutShifted = true;\n          this.arrangeCards(this._sortedCards);\n          this.stepChange.emit(event.card.getResizedEventObject());\n        } else if (event.card.cardState === 1 && -cardWidthChange < horizontalResizeOffset && this._layoutShifted) {\n          // card width increasing currently\n          this._layoutShifted = false;\n          this.arrangeCards(this._sortedCards);\n          this.stepChange.emit(event.card.getResizedEventObject());\n        }\n      }\n    }\n    /**\n     * @hidden Method to move card down, when another card width is increasing\n     * Method to loop till this._columns -1 positions and exchange the rank\n     * @param currentCardIndex: Index of current card\n     */\n    _moveCardDown(currentCardIndex) {\n      // taking width of adjacent card col-span into account\n      // eg: 4 columns - 2 col(adjacent card) = 2 positions can exchange ranks\n      const currentCard = this._sortedCards[currentCardIndex];\n      let card;\n      // unoccupiedPositions positions left after currentCard occupies in next row.\n      let unoccupiedPositions = this._columns - currentCard.cardWidthColSpan;\n      currentCard.prevRank = currentCard.rank;\n      let index = 1;\n      while (unoccupiedPositions > 0) {\n        // compare from next card\n        card = this._sortedCards[index + currentCardIndex];\n        if (card && unoccupiedPositions >= card.cardWidthColSpan) {\n          card.prevRank = card.rank;\n          card.rank -= 1;\n          currentCard.rank = card.prevRank;\n          unoccupiedPositions -= card.cardWidthColSpan;\n        } else {\n          unoccupiedPositions = 0;\n        }\n        index += 1;\n      }\n    }\n    /**\n     * @hidden updates array with new column heights\n     * @param card: ResizableCardItemComponent\n     */\n    _updateColumnsHeight(card) {\n      const columnsStart = card[this._directionPosition] != null ? Math.floor(card[this._directionPosition] / horizontalResizeStep) : 0;\n      // Get width of current card resizing and assign width here for that card\n      const cardBaseColSpan = Math.floor(card.cardWidth / horizontalResizeStep);\n      // till which columns card spans\n      const columnsSpan = card.cardWidth - cardBaseColSpan * horizontalResizeStep - cardBaseColSpan * gap > horizontalResizeOffset ? cardBaseColSpan + 1 : cardBaseColSpan;\n      const columnHeight = card.cardHeight + card.top;\n      for (let i = 0; i < columnsSpan; i++) {\n        this._columnsHeight[i + columnsStart] = columnHeight;\n      }\n      if (columnsStart === columnsSpan) {\n        this._columnsHeight[columnsStart] = columnHeight;\n      }\n    }\n    /**\n     * @hidden Try to set card at available heights\n     * @param card : ResizableCardItemComponent\n     * @param index : index value of card in array of ResizableCardItemComponent\n     */\n    _setCardPositionValues(card, index) {\n      if (index === 0) {\n        card[this._directionPosition] = 0 + this._paddingLeft;\n        card.top = 0;\n        card.startingColumnPosition = 0;\n        return;\n      }\n      const uniqueHeights = this._getSortedUniqueHeights();\n      let cardPositioned = false;\n      for (let i = 0; i < uniqueHeights.length && !cardPositioned; i++) {\n        cardPositioned = this._isPositionSetSuccess(uniqueHeights[i], card);\n      }\n    }\n    /**\n     * @hidden try to set card at given height.\n     * @param height : height at which card is getting positioned.\n     * @param card : ResizableCardItemComponent\n     * @returns It returns true when card position id found otherwise it returns false.\n     */\n    _isPositionSetSuccess(height, card) {\n      const columnPositions = [];\n      let index = 0;\n      for (const columnHeight of this._columnsHeight) {\n        index++;\n        if (columnHeight === height) {\n          columnPositions.push(index);\n        }\n      }\n      // check for each card position, starting from leftmost\n      let isFitting = false;\n      let startingColumnPosition = -1;\n      // try to fit as left (or right if Rtl) as possible from the column position\n      startingColumnPosition = this._fitCardColumnPosition(card, columnPositions, height);\n      if (startingColumnPosition !== -1) {\n        isFitting = true;\n        card[this._directionPosition] = startingColumnPosition * horizontalResizeStep + this._paddingLeft + (startingColumnPosition > 0 ? gap * startingColumnPosition : 0);\n        card.top = height + (height > 0 ? verticalResizeStep : 0);\n        card.startingColumnPosition = startingColumnPosition;\n      }\n      return isFitting;\n    }\n    /**\n     * @hidden Try to start card position from left most fit position.\n     * @param card : ResizableCardItemComponent\n     * @param columnPositions : Array of available positions for cards.\n     * @param height : height at which fixing the card\n     * @returns : returns starting column position where card will fit.\n     */\n    _fitCardColumnPosition(card, columnPositions, height) {\n      // check for each card position, starting from leftmost\n      let isFitting = false;\n      let startingColumnPosition = -1;\n      // start from previous indexes\n      const cardBaseColSpan = Math.floor(card.cardWidth / horizontalResizeStep);\n      const cardColSpan = card.cardWidth - cardBaseColSpan * horizontalResizeStep - cardBaseColSpan * gap > horizontalResizeOffset ? cardBaseColSpan + 1 : cardBaseColSpan;\n      // try to set towards left from available card position\n      // eg. [1, 2, 3, 4] columnsPositions\n      for (const columnPosition of columnPositions) {\n        if (isFitting) {\n          break;\n        }\n        // startingPosition values will be 1, 2, 3, 4\n        // try to fit as left as possible\n        let startingPosition = columnPosition - (cardColSpan - 1);\n        startingPosition = startingPosition > 0 ? startingPosition : 1;\n        for (let index = startingPosition; index <= columnPosition && !isFitting; index++) {\n          for (let span = 0; span < cardColSpan; span++) {\n            if (this._columnsHeight[index + span - 1] <= height && cardColSpan + index - 1 <= this._columns) {\n              isFitting = true;\n              startingColumnPosition = index - 1;\n            } else {\n              isFitting = false;\n              startingColumnPosition = -1;\n              break;\n            }\n          }\n        }\n      }\n      return startingColumnPosition;\n    }\n    /** @hidden returns sorted unique height of columns */\n    _getSortedUniqueHeights() {\n      const tempArray = this._columnsHeight.slice();\n      const sortedColumnsHeightArray = tempArray.sort(comparer);\n      const uniqueHeights = [];\n      for (const sortedHeight of sortedColumnsHeightArray) {\n        if (uniqueHeights.indexOf(sortedHeight) === -1) {\n          uniqueHeights.push(sortedHeight);\n        }\n      }\n      function comparer(first, second) {\n        return first - second;\n      }\n      return uniqueHeights;\n    }\n    /**\n     * @hidden Comparator to sort card based on rank.\n     * @param firstCard : ResizableCardItemComponent\n     * @param secondCard : ResizableCardItemComponent\n     * @returns : returns difference between first card rank and other card rank.\n     */\n    _sortCards(firstCard, secondCard) {\n      return firstCard.rank - secondCard.rank;\n    }\n    /** get value for rtl */\n    get _isRtl() {\n      return this._rtlService?.rtl.getValue();\n    }\n    /** @hidden Rtl change subscription */\n    _subscribeToRtl() {\n      const refreshDirection = isRtl => {\n        this._directionPosition = isRtl ? 'right' : 'left';\n        this._cd.detectChanges();\n      };\n      refreshDirection(this._isRtl);\n      this._rtlService?.rtl.pipe(takeUntil(this._destroy$)).subscribe(refreshDirection);\n    }\n  }\n  ResizableCardLayoutComponent.ɵfac = function ResizableCardLayoutComponent_Factory(t) {\n    return new (t || ResizableCardLayoutComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.RtlService, 8));\n  };\n  ResizableCardLayoutComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: ResizableCardLayoutComponent,\n    selectors: [[\"fd-resizable-card-layout\"]],\n    contentQueries: function ResizableCardLayoutComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ResizableCardItemComponent, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeCardItems = _t);\n      }\n    },\n    hostBindings: function ResizableCardLayoutComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function ResizableCardLayoutComponent_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydown($event);\n        })(\"resize\", function ResizableCardLayoutComponent_resize_HostBindingHandler() {\n          return ctx.onResize();\n        }, false, i0.ɵɵresolveWindow);\n      }\n    },\n    inputs: {\n      layoutConfig: \"layoutConfig\"\n    },\n    outputs: {\n      stepChange: \"stepChange\",\n      resizing: \"resizing\",\n      resized: \"resized\",\n      miniHeaderReached: \"miniHeaderReached\",\n      miniContentReached: \"miniContentReached\",\n      layoutChange: \"layoutChange\"\n    },\n    ngContentSelectors: _c0,\n    decls: 3,\n    vars: 6,\n    consts: [[1, \"fd-resizable-card-layout\"], [\"layout\", \"\"]],\n    template: function ResizableCardLayoutComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵclassMap(\"fd-resizable-card-layout--\" + ctx.layoutSize);\n        i0.ɵɵstyleProp(\"width\", ctx.layoutWidth, \"px\")(\"height\", ctx.layoutHeight, \"px\");\n      }\n    },\n    styles: [\"/*!\\n * Fundamental Library Styles v0.28.3\\n * Copyright (c) 2023 SAP SE or an SAP affiliate company.\\n * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/main/LICENSE)\\n */.fd-resizable-card-layout{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:1rem 0 0;padding:0 .5rem;position:relative}.fd-resizable-card-layout:after,.fd-resizable-card-layout:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__item{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);display:flex;flex-direction:row;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;min-width:20rem;padding:0;position:relative}.fd-resizable-card-layout__item:after,.fd-resizable-card-layout__item:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__card{-webkit-box-sizing:border-box;-webkit-box-ordinal-group:2;-ms-flex-order:1;-webkit-box-flex:1;-ms-flex:1;border:0;box-sizing:border-box;color:var(--sapTextColor);flex:1;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:calc(100% - .0625rem);line-height:var(--sapContent_LineHeight);margin:0;order:1;padding:0;position:relative}.fd-resizable-card-layout__card:after,.fd-resizable-card-layout__card:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__icon-wrapper{-webkit-box-sizing:border-box;border:0;bottom:0;box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:1rem;line-height:var(--sapContent_LineHeight);margin:0;padding:0 .0625rem .0625rem 0;position:absolute;right:0;width:1rem;z-index:2}.fd-resizable-card-layout__icon-wrapper:after,.fd-resizable-card-layout__icon-wrapper:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__icon-wrapper[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon-wrapper{left:0;padding:0 0 .0625rem .0625rem;right:auto}.fd-resizable-card-layout__icon{-webkit-box-sizing:border-box;border:0;bottom:0;box-sizing:border-box;color:var(--sapTextColor);color:var(--sapButton_IconColor);cursor:nwse-resize;font-family:var(--sapFontFamily);font-family:SAP-icons;font-size:var(--sapFontSize);font-size:1rem;font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);line-height:1rem;margin:0;padding:0;position:absolute;right:.0625rem;z-index:2}.fd-resizable-card-layout__icon:after,.fd-resizable-card-layout__icon:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout__icon:before{content:\\\"\\\\e24f\\\";font-family:SAP-icons;text-align:center;text-decoration:inherit;text-rendering:optimizeLegibility;text-transform:none}.fd-resizable-card-layout__icon[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon{-webkit-transform:rotate(90deg);cursor:nesw-resize;padding:0 .0625rem .0625rem .5rem;position:relative;transform:rotate(90deg)}.fd-resizable-card-layout__icon--vertical,.fd-resizable-card-layout__icon--vertical[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon--vertical{cursor:ns-resize}.fd-resizable-card-layout__icon--horizontal,.fd-resizable-card-layout__icon--horizontal[dir=rtl],[dir=rtl] .fd-resizable-card-layout__icon--horizontal{cursor:ew-resize}.fd-resizable-card-layout__resize--vertical{-webkit-box-ordinal-group:3;-ms-flex-order:2;cursor:ew-resize;order:2;width:.0625rem;z-index:2}.fd-resizable-card-layout__resize--vertical::content{content:\\\"\\\";position:absolute}.fd-resizable-card-layout__resize--horizontal{bottom:0;cursor:ns-resize;height:.0625rem;position:absolute;width:calc(100% - .5rem);z-index:2}.fd-resizable-card-layout__indication-border{-webkit-box-sizing:border-box;border:0;border:.125rem dashed var(--sapContent_DragAndDropActiveColor);box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;padding:0}.fd-resizable-card-layout__indication-border:after,.fd-resizable-card-layout__indication-border:before{box-sizing:inherit;font-size:inherit}.fd-resizable-card-layout--sm{padding-left:.5rem;padding-right:.5rem}.fd-resizable-card-layout--lg,.fd-resizable-card-layout--md{padding-left:1rem;padding-right:1rem}.fd-resizable-card-layout--xl{padding-left:3rem;padding-right:3rem}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return ResizableCardLayoutComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ResizableCardLayoutModule = /*#__PURE__*/(() => {\n  class ResizableCardLayoutModule {}\n  ResizableCardLayoutModule.ɵfac = function ResizableCardLayoutModule_Factory(t) {\n    return new (t || ResizableCardLayoutModule)();\n  };\n  ResizableCardLayoutModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ResizableCardLayoutModule\n  });\n  ResizableCardLayoutModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, CardModule, DragDropModule]\n  });\n  return ResizableCardLayoutModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ResizableCardItemComponent, ResizableCardLayoutComponent, ResizableCardLayoutModule, ResizedEvent, gap, horizontalResizeOffset, horizontalResizeStep, verticalResizeOffset, verticalResizeStep };\n//# sourceMappingURL=fundamental-ngx-core-resizable-card-layout.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}