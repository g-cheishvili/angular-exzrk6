{"ast":null,"code":"import _asyncToGenerator from \"/home/webpct/angular-exzrk6/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Optional, Inject, isDevMode, inject, Directive, EventEmitter, Input, Output, HostListener, NgModule, ContentChildren, forwardRef, HostBinding, ElementRef, INJECTOR, ContentChild, Self, SkipSelf, PLATFORM_ID, Injector, NgModuleFactory, Pipe } from '@angular/core';\nimport { DOCUMENT, CommonModule, AsyncPipe } from '@angular/common';\nimport { BehaviorSubject, Subject, fromEvent, Observable, NEVER, Subscription, merge, ReplaySubject, takeUntil as takeUntil$1, startWith as startWith$1, switchMap, combineLatest, firstValueFrom, filter as filter$1, map as map$1, of } from 'rxjs';\nimport * as i2 from '@angular/platform-browser';\nimport { EVENT_MANAGER_PLUGINS } from '@angular/platform-browser';\nimport * as i1 from '@angular/router';\nimport { takeUntil, filter, take, distinctUntilChanged, debounceTime, map, mapTo, pairwise, tap, startWith, finalize, shareReplay, switchMap as switchMap$1, delay } from 'rxjs/operators';\nimport { RIGHT_ARROW, DOWN_ARROW, LEFT_ARROW, UP_ARROW, SPACE, ESCAPE, DELETE, ENTER, MAC_ENTER, TAB, HOME, END, ALT, CONTROL, META, SHIFT, BACKSPACE, A, C, V, X, PAGE_UP, PAGE_DOWN, DASH, NUMPAD_MINUS, NUMPAD_ZERO, NUMPAD_ONE, NUMPAD_TWO, NUMPAD_THREE, NUMPAD_FOUR, NUMPAD_FIVE, NUMPAD_SIX, NUMPAD_SEVEN, NUMPAD_EIGHT, NUMPAD_NINE, F2, hasModifierKey } from '@angular/cdk/keycodes';\nimport { coerceBooleanProperty, coerceNumberProperty, coerceElement, coerceArray, coerceCssPixelValue } from '@angular/cdk/coercion';\nimport * as i1$1 from '@angular/cdk/a11y';\nimport { FocusKeyManager } from '@angular/cdk/a11y';\nimport * as i1$2 from '@angular/cdk/overlay';\nimport { ViewportRuler } from '@angular/cdk/overlay';\nimport { createFocusTrap } from 'focus-trap';\nimport * as i1$3 from '@angular/cdk/observers';\nimport { findLastIndex, get } from 'lodash-es';\nimport equal from 'fast-deep-equal';\nimport { __decorate, __metadata } from 'tslib';\nimport * as i1$4 from '@angular/cdk/drag-drop';\nimport { DragDrop, moveItemInArray, transferArrayItem, DragDropModule } from '@angular/cdk/drag-drop';\nimport { ComponentPortal, TemplatePortal } from '@angular/cdk/portal';\nimport escape from 'lodash-es/escape';\nconst DefaultRtlLanguages = ['ar', 'arc', 'dv', 'fa', 'ha', 'he', 'khw', 'ks', 'ku', 'ps', 'ur', 'yi'];\nconst RTL_LANGUAGE = new InjectionToken('RtlLanguage');\n/**\n * Service taking care of RTL trough behavior subject\n * language list is used to determine if rtl should be enabled at start\n * user can overwrite default languages by using injection token RtlLanguageToken\n */\nlet RtlService = /*#__PURE__*/(() => {\n  class RtlService {\n    /** @hidden */\n    constructor(injectedRtlLanguages) {\n      injectedRtlLanguages = injectedRtlLanguages || DefaultRtlLanguages;\n      const filtered = injectedRtlLanguages.filter(language => navigator.language.includes(language));\n      this.rtl = new BehaviorSubject(filtered.length > 0);\n    }\n  }\n  RtlService.ɵfac = function RtlService_Factory(t) {\n    return new (t || RtlService)(i0.ɵɵinject(RTL_LANGUAGE, 8));\n  };\n  RtlService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: RtlService,\n    factory: RtlService.ɵfac\n  });\n  return RtlService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst MOBILE_CONFIG_ERROR = `Missing configuration object for mobile version of the component.\n    Consult the documentation on how to provide MobileModeConfiguration object for this component.\n`;\nconst THEME_SWITCHER_ROUTER_MISSING_ERROR = `You need to import RouterModule to enable theme settings via the url.`;\nconst INVALID_DATE_ERROR = 'Invalid Date';\n\n/**\n * Instead of `/\\p{L}/u` because of it's not working in IE11 and Edge\n * - https://github.com/Microsoft/ChakraCore/issues/2969\n * */\n// eslint-disable-next-line max-len\nconst LETTERS_UNICODE_RANGE = `[A-Za-z\\u00AA\\u00B5\\u00BA\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F5\\u13F8-\\u13FD\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2183\\u2184\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005\\u3006\\u3031-\\u3035\\u303B\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6E5\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA7AD\\uA7B0-\\uA7B7\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB65\\uAB70-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]`;\n// eslint-disable-next-line max-len\nconst ANY_LANGUAGE_LETTERS_REGEX = new RegExp(LETTERS_UNICODE_RANGE, 'g');\n// eslint-disable-next-line max-len\nconst ANY_LANGUAGE_LETTERS_GROUP_REGEX = new RegExp(`(${LETTERS_UNICODE_RANGE})+`, 'g');\n\n/**\n * Polyfill for `/\\p{Nd}/u` to work in IE11 and Edge\n */\n// eslint-disable-next-line max-len\nconst DECIMAL_NUMBER_UNICODE_RANGE = `[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]`;\nconst DECIMAL_NUMBER_UNICODE_REGEX = new RegExp(DECIMAL_NUMBER_UNICODE_RANGE, 'g');\nconst DECIMAL_NUMBER_UNICODE_GROUP_REGEX = new RegExp(`(${DECIMAL_NUMBER_UNICODE_RANGE})+`, 'g');\nconst OVERFLOW_PRIORITY_SCORE = new Map([['always', 0], ['disappear', 1], ['low', 2], ['high', 3], ['never', 4]]);\n\n/**\n * @deprecated\n * Service providing theme switcher functionality.\n * Deprecated since 0.35.0 in favor of ThemingService from ThemingModule\n */\nlet ThemesService = /*#__PURE__*/(() => {\n  class ThemesService {\n    /** @hidden */\n    constructor(_activatedRoute, _sanitizer) {\n      this._activatedRoute = _activatedRoute;\n      this._sanitizer = _sanitizer;\n      /** Available themes */\n      this.themes = [{\n        id: 'sap_horizon',\n        name: 'Morning Horizon (Light)'\n      }, {\n        id: 'sap_horizon_dark',\n        name: 'Evening Horizon (Dark)'\n      }, {\n        id: 'sap_horizon_hcb',\n        name: 'Horizon High Contrast Black',\n        description: 'Optimized contrast and accessibiliwty for extremely bright environments'\n      }, {\n        id: 'sap_horizon_hcw',\n        name: 'Horizon High Contrast White Horizon',\n        description: 'Optimized contrast and accessibility for extremely dark environments'\n      }, {\n        id: 'sap_fiori_3',\n        name: 'Quartz Light',\n        description: 'Use in regular office environment'\n      }, {\n        id: 'sap_fiori_3_dark',\n        name: 'Quartz Dark',\n        description: 'Use in dimmed environments'\n      }, {\n        id: 'sap_fiori_3_hcb',\n        name: 'Quartz High Contrast Black',\n        description: 'Optimized contrast and accessibility for extremely bright environments'\n      }, {\n        id: 'sap_fiori_3_hcw',\n        name: 'Quartz High Contrast White',\n        description: 'Optimized contrast and accessibility for extremely dark environments'\n      }, {\n        id: 'sap_fiori_3_light_dark',\n        name: 'Quartz Auto (Depending on the OS Settings)'\n      }];\n      /** Subject triggered, when the theming is changed by URL parameter */\n      this.onThemeQueryParamChange = new Subject();\n      /** @hidden **/\n      this._onDestroy$ = new Subject();\n    }\n    /**\n     * Set theme according to additional URL parameter.\n     * This parameter can be changed in function argument.\n     * By default it's `theme`.\n     **/\n    setThemeByRoute(themeParamName) {\n      const paramName = themeParamName || 'theme';\n      if (!this._activatedRoute) {\n        throw new Error(THEME_SWITCHER_ROUTER_MISSING_ERROR);\n      }\n      this._activatedRoute.queryParams.pipe(takeUntil(this._onDestroy$), filter(param => param && param[paramName])).subscribe(param => this._propagateThemes(param[paramName]));\n      const nativeTheme = this._getNativeParameterByName(paramName);\n      if (nativeTheme) {\n        this._propagateThemes(nativeTheme);\n      }\n    }\n    /** Method to get once theme object directly from url. */\n    getThemesFromURL(param) {\n      const paramName = param || 'theme';\n      const nativeTheme = this._getNativeParameterByName(paramName);\n      if (!nativeTheme && isDevMode()) {\n        console.warn('There is no theme param set named: ' + param);\n        return;\n      }\n      return {\n        themeUrl: this.setTheme(nativeTheme),\n        customThemeUrl: this.setCustomTheme(nativeTheme)\n      };\n    }\n    /** Assign css file corresponding to chosen theme from @sap-theming **/\n    setTheme(theme) {\n      return this._sanitizer.bypassSecurityTrustResourceUrl('assets/theming-base/' + theme + '/css_variables.css');\n    }\n    /** Assign css file corresponding to chosen theme fundamental-styles **/\n    setCustomTheme(theme) {\n      return this._sanitizer.bypassSecurityTrustResourceUrl('assets/fundamental-styles-theming/' + theme + '.css');\n    }\n    /** @hidden */\n    _getNativeParameterByName(paramName) {\n      paramName = paramName.replace(/[[\\]]/g, '\\\\$&');\n      const regex = new RegExp('[?&]' + paramName + '(=([^&#]*)|&|#|$)'),\n        results = regex.exec(window.location.href);\n      if (!results || !results[2]) {\n        return '';\n      }\n      return decodeURIComponent(results[2].replace(/\\+/g, ' '));\n    }\n    /** @hidden */\n    _propagateThemes(theme) {\n      this.onThemeQueryParamChange.next({\n        themeUrl: this.setTheme(theme),\n        customThemeUrl: this.setCustomTheme(theme)\n      });\n    }\n  }\n  ThemesService.ɵfac = function ThemesService_Factory(t) {\n    return new (t || ThemesService)(i0.ɵɵinject(i1.ActivatedRoute, 8), i0.ɵɵinject(i2.DomSanitizer));\n  };\n  ThemesService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ThemesService,\n    factory: ThemesService.ɵfac\n  });\n  return ThemesService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Map of keyCodes and their corresponding \"key\" values */\nconst keyMap = new Map([[RIGHT_ARROW, ['ArrowRight', 'Right']], [DOWN_ARROW, ['ArrowDown', 'Down']], [LEFT_ARROW, ['ArrowLeft', 'Left']], [UP_ARROW, ['ArrowUp', 'Up']], [SPACE, ['Space', 'Spacebar', ' ']], [ESCAPE, ['Escape', 'Esc']], [DELETE, ['Delete', 'Del']], [ENTER, ['Enter']], [MAC_ENTER, ['Enter']], [TAB, ['Tab']], [HOME, ['Home']], [END, ['End']], [ALT, ['Alt']], [CONTROL, ['Ctrl', 'Control', 'Meta']], [META, ['Meta']], [SHIFT, ['Shift']], [BACKSPACE, ['Backspace']], [A, ['KeyA']], [C, ['KeyC']], [V, ['KeyV']], [X, ['KeyX']], [PAGE_UP, ['PageUp']], [PAGE_DOWN, ['PageDown']], [DASH, ['-']], [NUMPAD_MINUS, ['-']], [NUMPAD_ZERO, ['NumPad0']], [NUMPAD_ONE, ['NumPad1']], [NUMPAD_TWO, ['NumPad2']], [NUMPAD_THREE, ['NumPad3']], [NUMPAD_FOUR, ['NumPad4']], [NUMPAD_FIVE, ['NumPad5']], [NUMPAD_SIX, ['NumPad6']], [NUMPAD_SEVEN, ['NumPad7']], [NUMPAD_EIGHT, ['NumPad8']], [NUMPAD_NINE, ['NumPad9']], [F2, ['F2']]]);\nclass KeyUtil {\n  /**\n   * Function used to unify key identification across different browsers using KeyCodes\n   *\n   * @param event     - KeyboardEvent\n   * @param keyCode   - event.key name matching W3C specification / (ASSCI char. codes)\n   * */\n  static isKeyCode(event, keyCode) {\n    if (Array.isArray(keyCode)) {\n      return keyCode.some(key => this.isKeyCode(event, key));\n    }\n    if (event && keyMap.get(keyCode)) {\n      return keyMap.get(keyCode)?.some(alias => alias === event.key) || keyCode === event.keyCode;\n    }\n    if (isDevMode()) {\n      throw new Error(`Invalid function arguments. Check if \"event\" is a KeyboardEvent or \"key\" is defined in keyMap`);\n    }\n    return false;\n  }\n  /**\n   * Function used to unify key identification across different browsers\n   *\n   * @param event     - KeyboardEvent\n   * @param keyType   - Type of key\n   * */\n  static isKeyType(event, keyType) {\n    if (event && keyType) {\n      switch (keyType) {\n        case 'numeric':\n          return event.code ? event.code.toLowerCase().includes('digit') : event.keyCode >= 48 && event.keyCode <= 57 || event.keyCode >= 96 && event.keyCode <= 105;\n        case 'alphabetical':\n          return event.code ? event.code.toLowerCase().includes('key') : event.keyCode >= 65 && event.keyCode <= 90;\n        // some service commands as alt, ctr, insert, print, f4 etc. All except letters, numbers and symbols\n        case 'control':\n          return event.keyCode < 48 || event.keyCode >= 112 && event.keyCode <= 123;\n      }\n    }\n    if (isDevMode()) {\n      throw new Error(`Invalid function arguments.`);\n    }\n    return false;\n  }\n}\n\n/** @hidden */\nfunction getDeprecatedModel(current, deprecated) {\n  return {\n    current,\n    deprecated\n  };\n}\nconst FD_DEPRECATED_DIRECTIVE_SELECTOR = new InjectionToken('FdDeprecatedDirectiveSelector');\nclass DeprecatedSelector {\n  /** @hidden */\n  constructor() {\n    /** @hidden */\n    this._selectors = inject(FD_DEPRECATED_DIRECTIVE_SELECTOR, {\n      optional: true\n    });\n    if (isDevMode() && this._selectors) {\n      console.warn(`${this._selectors.deprecated} selector(s) are deprecated and may affect input properties. Use ${this._selectors.current} instead.`);\n    }\n  }\n}\nlet DeprecatedAutoCompleteDirective = /*#__PURE__*/(() => {\n  class DeprecatedAutoCompleteDirective extends DeprecatedSelector {}\n  DeprecatedAutoCompleteDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedAutoCompleteDirective_BaseFactory;\n    return function DeprecatedAutoCompleteDirective_Factory(t) {\n      return (ɵDeprecatedAutoCompleteDirective_BaseFactory || (ɵDeprecatedAutoCompleteDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedAutoCompleteDirective)))(t || DeprecatedAutoCompleteDirective);\n    };\n  }();\n  DeprecatedAutoCompleteDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedAutoCompleteDirective,\n    selectors: [[\"\", \"fdAutoComplete\", \"\"], [\"\", \"fd-auto-complete\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkAutoComplete]', '[fdAutoComplete], [fd-auto-complete]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedAutoCompleteDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AutoCompleteDirective = /*#__PURE__*/(() => {\n  class AutoCompleteDirective {\n    /** @hidden */\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n      /** Whether the auto complete directive should be enabled */\n      this.enable = true;\n      /** Display function. Accepts an object of the same type as the\n       * items passed to dropdownValues as argument, and outputs a string.\n       * An arrow function can be used to access the *this* keyword in the calling component.\n       * See search input examples for details. */\n      this.displayFn = this._defaultDisplay;\n      /** Event thrown, when the auto ahead text is accepted */\n      this.onComplete = new EventEmitter();\n      /** @hidden */\n      this._completeKeys = [ENTER];\n      /** @hidden */\n      this._fillKeys = [LEFT_ARROW, RIGHT_ARROW];\n      /** @hidden */\n      this._stopKeys = [BACKSPACE, DELETE, ESCAPE];\n    }\n    /** @hidden */\n    handleKeyboardEvent(event) {\n      if (this.enable) {\n        if (KeyUtil.isKeyCode(event, this._stopKeys)) {\n          this._elementRef.nativeElement.value = this.inputText;\n        } else if (KeyUtil.isKeyCode(event, this._completeKeys)) {\n          this._sendCompleteEvent(true);\n          this._moveIndicatorToLastCharacter();\n        } else if (KeyUtil.isKeyCode(event, this._fillKeys)) {\n          this._sendCompleteEvent(false);\n        } else if (!this._isControlKey(event) && this.inputText) {\n          /** Prevention from triggering typeahead, when having crtl/cmd + keys */\n          if (!this._triggerTypeAhead()) {\n            return;\n          }\n          this.oldValue = this.inputText;\n          const item = this.options.find(option => this.displayFn(option).toLocaleLowerCase().startsWith(this.inputText.toLocaleLowerCase()));\n          if (item) {\n            this._typeahead(this.displayFn(item));\n          }\n        }\n      }\n      this.lastKeyUpEvent = event;\n    }\n    /** @hidden */\n    _typeahead(displayedValue) {\n      this._elementRef.nativeElement.value = displayedValue;\n      const selectionStartIndex = this.inputText.length;\n      this._elementRef.nativeElement.setSelectionRange(selectionStartIndex, displayedValue.length);\n    }\n    /** @hidden */\n    _isControlKey(event) {\n      return KeyUtil.isKeyCode(event, CONTROL) || event.ctrlKey;\n    }\n    /** @hidden */\n    _defaultDisplay(value) {\n      return value;\n    }\n    /** @hidden */\n    _triggerTypeAhead() {\n      if (this.lastKeyUpEvent && KeyUtil.isKeyCode(this.lastKeyUpEvent, CONTROL) && this.inputText === this.oldValue) {\n        return false;\n      } else {\n        return true;\n      }\n    }\n    /** @hidden */\n    _sendCompleteEvent(forceClose) {\n      this.onComplete.emit({\n        term: this._elementRef.nativeElement.value,\n        forceClose\n      });\n    }\n    /** @hidden */\n    _moveIndicatorToLastCharacter() {\n      const inputTextLength = this.inputText?.length ?? 0;\n      this._elementRef.nativeElement.setSelectionRange(inputTextLength, inputTextLength);\n    }\n  }\n  AutoCompleteDirective.ɵfac = function AutoCompleteDirective_Factory(t) {\n    return new (t || AutoCompleteDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  AutoCompleteDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AutoCompleteDirective,\n    selectors: [[\"\", \"fdkAutoComplete\", \"\"], [\"\", \"fdAutoComplete\", \"\"], [\"\", \"fd-auto-complete\", \"\"]],\n    hostBindings: function AutoCompleteDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keyup\", function AutoCompleteDirective_keyup_HostBindingHandler($event) {\n          return ctx.handleKeyboardEvent($event);\n        });\n      }\n    },\n    inputs: {\n      options: \"options\",\n      inputText: \"inputText\",\n      enable: \"enable\",\n      displayFn: \"displayFn\"\n    },\n    outputs: {\n      onComplete: \"onComplete\"\n    },\n    standalone: true\n  });\n  return AutoCompleteDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AutoCompleteModule = /*#__PURE__*/(() => {\n  class AutoCompleteModule {}\n  AutoCompleteModule.ɵfac = function AutoCompleteModule_Factory(t) {\n    return new (t || AutoCompleteModule)();\n  };\n  AutoCompleteModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AutoCompleteModule\n  });\n  AutoCompleteModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return AutoCompleteModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FOCUSABLE_ITEM = new InjectionToken('Focusable Option');\nlet DeprecatedFocusKeyManagerListDirective = /*#__PURE__*/(() => {\n  class DeprecatedFocusKeyManagerListDirective extends DeprecatedSelector {}\n  DeprecatedFocusKeyManagerListDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedFocusKeyManagerListDirective_BaseFactory;\n    return function DeprecatedFocusKeyManagerListDirective_Factory(t) {\n      return (ɵDeprecatedFocusKeyManagerListDirective_BaseFactory || (ɵDeprecatedFocusKeyManagerListDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedFocusKeyManagerListDirective)))(t || DeprecatedFocusKeyManagerListDirective);\n    };\n  }();\n  DeprecatedFocusKeyManagerListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedFocusKeyManagerListDirective,\n    selectors: [[\"\", \"fd-focus-key-manager-list\", \"\"], [\"\", \"fdFocusKeyManagerList\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkFocusKeyManagerList]', '[fd-focus-key-manager-list], [fdFocusKeyManagerList]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedFocusKeyManagerListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Directive to apply Angular Material FocusKeyManager to lists.\n * To be used with FocusKeyManagerItemDirective\n */\nlet FocusKeyManagerListDirective = /*#__PURE__*/(() => {\n  class FocusKeyManagerListDirective {\n    /** @hidden */\n    get focusKeyManager() {\n      return this._focusKeyManager;\n    }\n    /** @hidden */\n    constructor(_rtlService, _cdr) {\n      this._rtlService = _rtlService;\n      this._cdr = _cdr;\n      /** @hidden */\n      this._onDestroy$ = new Subject();\n    }\n    /** @hidden */\n    ngOnChanges(changes) {\n      if (!this._focusKeyManager) {\n        return;\n      }\n      if ('orientation' in changes) {\n        this._applyOrientation();\n      }\n      if ('skiPredicate' in changes) {\n        this._focusKeyManager.skipPredicate(this.skipPredicate);\n      }\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      this._focusKeyManager = new FocusKeyManager(this._items).skipPredicate(this.skipPredicate);\n      this._applyOrientation();\n      this._cdr.detectChanges();\n      this._rtlService?.rtl.pipe(filter(() => this.orientation === 'horizontal'), takeUntil(this._onDestroy$)).subscribe(() => this._applyOrientation());\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n      this._focusKeyManager.destroy();\n    }\n    /** Focus certain list's item */\n    focusItem(item) {\n      if (typeof item === 'number') {\n        this._focusKeyManager.setActiveItem(item);\n      } else {\n        this._focusKeyManager.setActiveItem(item);\n      }\n    }\n    /** @hidden */\n    _applyOrientation() {\n      switch (this.orientation) {\n        case 'horizontal':\n          this._focusKeyManager.withHorizontalOrientation(this._rtlService?.rtl.value ? 'rtl' : 'ltr');\n          break;\n        case 'vertical':\n          this._focusKeyManager.withVerticalOrientation(true);\n          break;\n      }\n    }\n  }\n  FocusKeyManagerListDirective.ɵfac = function FocusKeyManagerListDirective_Factory(t) {\n    return new (t || FocusKeyManagerListDirective)(i0.ɵɵdirectiveInject(RtlService, 8), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  FocusKeyManagerListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusKeyManagerListDirective,\n    selectors: [[\"\", \"fdkFocusKeyManagerList\", \"\"], [\"\", \"fd-focus-key-manager-list\", \"\"], [\"\", \"fdFocusKeyManagerList\", \"\"]],\n    contentQueries: function FocusKeyManagerListDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FOCUSABLE_ITEM, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._items = _t);\n      }\n    },\n    inputs: {\n      orientation: \"orientation\",\n      skipPredicate: \"skipPredicate\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return FocusKeyManagerListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedFocusKeyManagerItemDirective = /*#__PURE__*/(() => {\n  class DeprecatedFocusKeyManagerItemDirective extends DeprecatedSelector {}\n  DeprecatedFocusKeyManagerItemDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedFocusKeyManagerItemDirective_BaseFactory;\n    return function DeprecatedFocusKeyManagerItemDirective_Factory(t) {\n      return (ɵDeprecatedFocusKeyManagerItemDirective_BaseFactory || (ɵDeprecatedFocusKeyManagerItemDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedFocusKeyManagerItemDirective)))(t || DeprecatedFocusKeyManagerItemDirective);\n    };\n  }();\n  DeprecatedFocusKeyManagerItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedFocusKeyManagerItemDirective,\n    selectors: [[\"\", \"fd-focus-key-manager-item\", \"\"], [\"\", \"fdFocusKeyManagerItem\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkFocusKeyManagerItem]', '[fd-focus-key-manager-item], [fdFocusKeyManagerItem]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedFocusKeyManagerItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/** Directive to apply Angular Material FocusKeyManager to lists.\n * To be used with FocusKeyManagerItemDirective\n */\nlet FocusKeyManagerItemDirective = /*#__PURE__*/(() => {\n  class FocusKeyManagerItemDirective {\n    /** Whether item should be initially focused */\n    set initialFocus(value) {\n      this._initialFocus = coerceBooleanProperty(value);\n    }\n    /** @hidden */\n    get _tabindex() {\n      if (this._initialFocus) {\n        return 0;\n      }\n      return this.nativeElement?.tabIndex ?? -1;\n    }\n    /** Native element of the item */\n    get nativeElement() {\n      return this._elRef?.nativeElement;\n    }\n    /** @hidden */\n    get _focusKeyManager() {\n      return this._list.focusKeyManager;\n    }\n    /** @hidden */\n    constructor(_list, _elRef) {\n      this._list = _list;\n      this._elRef = _elRef;\n      /** @hidden */\n      this._initialFocus = false;\n    }\n    /** @hidden */\n    _onFocus() {\n      // For cases where initially selected item doesn't have 0 index\n      this._focusKeyManager?.updateActiveItem(this);\n    }\n    /** @hidden */\n    _onKeydown(event) {\n      this._focusKeyManager?.onKeydown(event);\n    }\n    /** Focus current item native element */\n    focus() {\n      this._elRef?.nativeElement.focus();\n    }\n  }\n  FocusKeyManagerItemDirective.ɵfac = function FocusKeyManagerItemDirective_Factory(t) {\n    return new (t || FocusKeyManagerItemDirective)(i0.ɵɵdirectiveInject(FocusKeyManagerListDirective), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  FocusKeyManagerItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusKeyManagerItemDirective,\n    selectors: [[\"\", \"fdkFocusKeyManagerItem\", \"\"], [\"\", \"fd-focus-key-manager-item\", \"\"], [\"\", \"fdFocusKeyManagerItem\", \"\"]],\n    hostVars: 1,\n    hostBindings: function FocusKeyManagerItemDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function FocusKeyManagerItemDirective_focus_HostBindingHandler() {\n          return ctx._onFocus();\n        })(\"keydown\", function FocusKeyManagerItemDirective_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx._tabindex);\n      }\n    },\n    inputs: {\n      initialFocus: \"initialFocus\",\n      _tabindex: \"_tabindex\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FOCUSABLE_ITEM,\n      useExisting: forwardRef(() => FocusKeyManagerItemDirective)\n    }])]\n  });\n  return FocusKeyManagerItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusKeyManagerHelpersModule = /*#__PURE__*/(() => {\n  class FocusKeyManagerHelpersModule {}\n  FocusKeyManagerHelpersModule.ɵfac = function FocusKeyManagerHelpersModule_Factory(t) {\n    return new (t || FocusKeyManagerHelpersModule)();\n  };\n  FocusKeyManagerHelpersModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FocusKeyManagerHelpersModule\n  });\n  FocusKeyManagerHelpersModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return FocusKeyManagerHelpersModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst IgnoreClickOnSelectionDirectiveToken = new InjectionToken('Ignore click on selection directive');\nlet DeprecatedIgnoreClickOnSelectionDirective = /*#__PURE__*/(() => {\n  class DeprecatedIgnoreClickOnSelectionDirective extends DeprecatedSelector {}\n  DeprecatedIgnoreClickOnSelectionDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedIgnoreClickOnSelectionDirective_BaseFactory;\n    return function DeprecatedIgnoreClickOnSelectionDirective_Factory(t) {\n      return (ɵDeprecatedIgnoreClickOnSelectionDirective_BaseFactory || (ɵDeprecatedIgnoreClickOnSelectionDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedIgnoreClickOnSelectionDirective)))(t || DeprecatedIgnoreClickOnSelectionDirective);\n    };\n  }();\n  DeprecatedIgnoreClickOnSelectionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedIgnoreClickOnSelectionDirective,\n    selectors: [[\"\", \"fdIgnoreClickOnSelection\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkIgnoreClickOnSelection]', '[fdIgnoreClickOnSelection]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedIgnoreClickOnSelectionDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Directive will stop propagation and prevent default of click, if selected area is coming from\n * directive's host element. This gives ability to not cancel all clicks on element, just the ones\n * which include selection\n */\nlet IgnoreClickOnSelectionDirective = /*#__PURE__*/(() => {\n  class IgnoreClickOnSelectionDirective {\n    /** @hidden */\n    constructor(document, _elementRef) {\n      this.document = document;\n      this._elementRef = _elementRef;\n    }\n    /** Host click listener. Checks for selection existence and if finds one, checks anchor */\n    clicked($event) {\n      const selection = this.document.getSelection();\n      if (selection?.toString()) {\n        if (selection.anchorNode && (this._elementRef.nativeElement.isSameNode(selection.anchorNode) || this._elementRef.nativeElement.isSameNode(selection.anchorNode.parentElement))) {\n          $event.stopPropagation();\n          $event.preventDefault();\n        }\n      }\n    }\n  }\n  IgnoreClickOnSelectionDirective.ɵfac = function IgnoreClickOnSelectionDirective_Factory(t) {\n    return new (t || IgnoreClickOnSelectionDirective)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  IgnoreClickOnSelectionDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: IgnoreClickOnSelectionDirective,\n    selectors: [[\"\", \"fdkIgnoreClickOnSelection\", \"\"], [\"\", \"fdIgnoreClickOnSelection\", \"\"]],\n    hostBindings: function IgnoreClickOnSelectionDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function IgnoreClickOnSelectionDirective_click_HostBindingHandler($event) {\n          return ctx.clicked($event);\n        });\n      }\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: IgnoreClickOnSelectionDirectiveToken,\n      useExisting: IgnoreClickOnSelectionDirective\n    }])]\n  });\n  return IgnoreClickOnSelectionDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IgnoreClickOnSelectionModule = /*#__PURE__*/(() => {\n  class IgnoreClickOnSelectionModule {}\n  IgnoreClickOnSelectionModule.ɵfac = function IgnoreClickOnSelectionModule_Factory(t) {\n    return new (t || IgnoreClickOnSelectionModule)();\n  };\n  IgnoreClickOnSelectionModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: IgnoreClickOnSelectionModule\n  });\n  IgnoreClickOnSelectionModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return IgnoreClickOnSelectionModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TabbableElementService = /*#__PURE__*/(() => {\n  class TabbableElementService {\n    /** @hidden */\n    constructor(_checker, _document) {\n      this._checker = _checker;\n      this._document = _document;\n    }\n    /** Get the first tabbable element from a DOM subtree (inclusive). */\n    getTabbableElement(root, focusLastElement = false, skipSelf = false) {\n      if (!skipSelf && this._checker.isFocusable(root) && this._checker.isTabbable(root)) {\n        return root;\n      }\n      // Iterate in DOM order. Note that IE doesn't have `children` for SVG, so we fall\n      // back to `childNodes` which includes text nodes, comments etc.\n      const rootChildren = root.children || root.childNodes;\n      const children = focusLastElement ? Array.from(rootChildren).reverse() : rootChildren;\n      for (let i = 0; i < children.length; i++) {\n        const tabbableChild = children[i].nodeType === this._document?.ELEMENT_NODE ? this.getTabbableElement(children[i], focusLastElement) : null;\n        if (tabbableChild) {\n          return tabbableChild;\n        }\n      }\n      return null;\n    }\n  }\n  TabbableElementService.ɵfac = function TabbableElementService_Factory(t) {\n    return new (t || TabbableElementService)(i0.ɵɵinject(i1$1.InteractivityChecker), i0.ɵɵinject(DOCUMENT, 8));\n  };\n  TabbableElementService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: TabbableElementService,\n    factory: TabbableElementService.ɵfac,\n    providedIn: 'root'\n  });\n  return TabbableElementService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedInitialFocusDirective = /*#__PURE__*/(() => {\n  class DeprecatedInitialFocusDirective extends DeprecatedSelector {}\n  DeprecatedInitialFocusDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedInitialFocusDirective_BaseFactory;\n    return function DeprecatedInitialFocusDirective_Factory(t) {\n      return (ɵDeprecatedInitialFocusDirective_BaseFactory || (ɵDeprecatedInitialFocusDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedInitialFocusDirective)))(t || DeprecatedInitialFocusDirective);\n    };\n  }();\n  DeprecatedInitialFocusDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedInitialFocusDirective,\n    selectors: [[\"\", \"fdInitialFocus\", \"\"], [\"\", \"fd-initial-focus\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkInitialFocus]', '[fdInitialFocus], [fd-initial-focus]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedInitialFocusDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InitialFocusDirective = /*#__PURE__*/(() => {\n  class InitialFocusDirective {\n    /** @hidden */\n    constructor(_elmRef, _ngZone, _tabbableService) {\n      this._elmRef = _elmRef;\n      this._ngZone = _ngZone;\n      this._tabbableService = _tabbableService;\n      /**\n       * CSS selector of element that should be focused.\n       */\n      this.focusableItem = '.fd-initial-focus-item';\n      /**\n       * Whether initial focus enabled for current element.\n       */\n      this.enabled = true;\n      /**\n       * Whether to focus last element in found array of elements.\n       */\n      this.focusLastElement = false;\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._executeOnEmpty(() => this._focus());\n    }\n    /**\n     * @hidden\n     * Executes a function when the zone is stable.\n     */\n    _executeOnEmpty(fn) {\n      if (!this._ngZone.hasPendingMicrotasks) {\n        fn();\n      } else {\n        this._ngZone.onMicrotaskEmpty.pipe(take(1)).subscribe(fn);\n      }\n    }\n    /**\n     * @hidden\n     * Searches for appropriate focusable element\n     */\n    _getFocusableElement() {\n      if (!this.focusableItem) {\n        return this._tabbableService.getTabbableElement(this._elmRef.nativeElement, this.focusLastElement);\n      }\n      const autoFocusableItems = this._elmRef.nativeElement.querySelectorAll(this.focusableItem);\n      if (autoFocusableItems.length > 0) {\n        return !this.focusLastElement ? autoFocusableItems[0] : autoFocusableItems[autoFocusableItems.length - 1];\n      }\n      // If no elements found, fallback to first tabbable element.\n      return this._tabbableService.getTabbableElement(this._elmRef.nativeElement, this.focusLastElement);\n    }\n    /** @hidden */\n    _focus() {\n      if (!this.enabled) {\n        return;\n      }\n      this._getFocusableElement()?.focus();\n    }\n  }\n  InitialFocusDirective.ɵfac = function InitialFocusDirective_Factory(t) {\n    return new (t || InitialFocusDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(TabbableElementService));\n  };\n  InitialFocusDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: InitialFocusDirective,\n    selectors: [[\"\", \"fdkInitialFocus\", \"\"], [\"\", \"fdInitialFocus\", \"\"], [\"\", \"fd-initial-focus\", \"\"]],\n    inputs: {\n      focusableItem: [\"fd-initial-focus\", \"focusableItem\"],\n      enabled: \"enabled\",\n      focusLastElement: \"focusLastElement\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([TabbableElementService, {\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkInitialFocus]', '[fdInitialFocus], [fd-initial-focus]')\n    }])]\n  });\n  return InitialFocusDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet InitialFocusModule = /*#__PURE__*/(() => {\n  class InitialFocusModule {}\n  InitialFocusModule.ɵfac = function InitialFocusModule_Factory(t) {\n    return new (t || InitialFocusModule)();\n  };\n  InitialFocusModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: InitialFocusModule\n  });\n  InitialFocusModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return InitialFocusModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedLineClampTargetDirective = /*#__PURE__*/(() => {\n  class DeprecatedLineClampTargetDirective extends DeprecatedSelector {}\n  DeprecatedLineClampTargetDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedLineClampTargetDirective_BaseFactory;\n    return function DeprecatedLineClampTargetDirective_Factory(t) {\n      return (ɵDeprecatedLineClampTargetDirective_BaseFactory || (ɵDeprecatedLineClampTargetDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedLineClampTargetDirective)))(t || DeprecatedLineClampTargetDirective);\n    };\n  }();\n  DeprecatedLineClampTargetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedLineClampTargetDirective,\n    selectors: [[\"\", \"fdLineClampTarget\", \"\"], [\"\", \"fd-lineclamp-target\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkLineClampTarget]', '[fdLineClampTarget], [fd-lineclamp-target]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedLineClampTargetDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedLineClampDirective = /*#__PURE__*/(() => {\n  class DeprecatedLineClampDirective extends DeprecatedSelector {}\n  DeprecatedLineClampDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedLineClampDirective_BaseFactory;\n    return function DeprecatedLineClampDirective_Factory(t) {\n      return (ɵDeprecatedLineClampDirective_BaseFactory || (ɵDeprecatedLineClampDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedLineClampDirective)))(t || DeprecatedLineClampDirective);\n    };\n  }();\n  DeprecatedLineClampDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedLineClampDirective,\n    selectors: [[\"\", \"fdLineClamp\", \"\"], [\"\", \"fd-lineclamp\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkLineClampTarget]', '[fdLineClamp], [fd-lineclamp]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedLineClampDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LineClampTargetDirective = /*#__PURE__*/(() => {\n  class LineClampTargetDirective {\n    /** @hidden */\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n      /**\n       * Event with target instance for clamping\n       */\n      this.update = new EventEmitter();\n    }\n    /**\n     * Native element of clamping target\n     */\n    get targetElement() {\n      return this._elementRef.nativeElement;\n    }\n    /** @hidden */\n    ngOnChanges() {\n      this.update.emit(this);\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this.update.emit(this);\n    }\n  }\n  LineClampTargetDirective.ɵfac = function LineClampTargetDirective_Factory(t) {\n    return new (t || LineClampTargetDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  LineClampTargetDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LineClampTargetDirective,\n    selectors: [[\"\", \"fdkLineClampTarget\", \"\"], [\"\", \"fdLineClampTarget\", \"\"], [\"\", \"fd-lineclamp-target\", \"\"]],\n    inputs: {\n      fdLineClampTargetText: \"fdLineClampTargetText\"\n    },\n    outputs: {\n      update: \"update\"\n    },\n    exportAs: [\"fdLineClampTarget\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return LineClampTargetDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LineClampDirective = /*#__PURE__*/(() => {\n  class LineClampDirective {\n    /**\n     * Count lines for clamping\n     */\n    set fdLineClampLines(value) {\n      this._lineCount = coerceNumberProperty(value);\n    }\n    /** @hidden */\n    /**\n     * Root native element of clamping box\n     */\n    get rootElement() {\n      return this._elementRef.nativeElement;\n    }\n    /** @hidden */\n    constructor(_elementRef, _renderer, _cdRef) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._cdRef = _cdRef;\n      /**\n       * Clamping state\n       */\n      this.fdLineclampState = false;\n      /**\n       * Event return count of lines from the target\n       */\n      this.lineCountUpdate = new EventEmitter();\n      /** @hidden */\n      this._isNativeSupport = true;\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._isNativeSupport = typeof this.rootElement.style.webkitLineClamp !== 'undefined';\n      // need to use setTimeout to force recheck of parent elements\n      setTimeout(() => {\n        this._checkLineCount();\n      });\n      this.windowResize$ = fromEvent(window, 'resize').pipe(distinctUntilChanged(), debounceTime(200)).subscribe({\n        next: () => this._checkLineCount()\n      });\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      if (this.windowResize$) {\n        this.windowResize$.unsubscribe();\n      }\n    }\n    /** @hidden */\n    ngOnChanges() {\n      this.reset();\n      this.refreshClamp();\n    }\n    /** @hidden */\n    reset() {\n      if (this._lineClampTarget && this._originalText) {\n        this._lineClampTarget.textContent = this._originalText;\n      }\n      if (this._isNativeSupport) {\n        this._resetNative();\n      }\n    }\n    /** @hidden */\n    refreshTarget(event) {\n      this._lineClampTarget = event.targetElement;\n      this._originalText = event.fdLineClampTargetText;\n      this._checkLineCount();\n    }\n    /** @hidden */\n    refreshClamp() {\n      if (this.fdLineclampState && this._lineCount) {\n        this.native();\n        if (!this._isNativeSupport) {\n          this._truncate();\n        }\n      }\n    }\n    /** @hidden\n     * Truncate text in the target box, if browser not support lineclamp style\n     */\n    _truncate() {\n      if (!this._lineClampTarget) {\n        return;\n      }\n      const lineClampHeight = Math.ceil(this.getLineHeight() * this._lineCount);\n      const ellipsisTextArray = this._originalText.split(' ');\n      const ellipsisText = () => {\n        if (this.rootElement.scrollHeight > lineClampHeight) {\n          ellipsisTextArray.pop();\n          this._lineClampTarget.textContent = ellipsisTextArray.join(' ') + '...';\n          ellipsisText.call(this);\n        }\n      };\n      ellipsisText();\n    }\n    /** @hidden\n     * Get lineheight for rootelement, if browser not support lineclamp style\n     */\n    getLineHeight() {\n      const lineHeight = window.getComputedStyle(this.rootElement, null).getPropertyValue('line-height');\n      if (lineHeight === 'normal') {\n        return parseInt(window.getComputedStyle(this.rootElement, null).getPropertyValue('font-size'), 10) * 1.25;\n      }\n      return parseFloat(lineHeight);\n    }\n    /** @hidden\n     * Setup native styles for lineclamp text\n     */\n    native() {\n      if (this._isNativeSupport) {\n        this._renderer.setStyle(this.rootElement, 'display', '-webkit-box');\n        this._renderer.setStyle(this.rootElement, 'overflow', 'hidden');\n        this._renderer.setStyle(this.rootElement, 'text-overflow', 'ellipsis');\n        this._renderer.setStyle(this.rootElement, '-webkit-box-orient', 'vertical');\n        this._renderer.setStyle(this.rootElement, '-webkit-line-clamp', `${this._lineCount}`);\n      }\n    }\n    /** @hidden\n     * Reset native styles for lineclamp text\n     */\n    _resetNative() {\n      if (this._isNativeSupport) {\n        this._renderer.setStyle(this.rootElement, 'display', '');\n        this._renderer.setStyle(this.rootElement, 'overflow', '');\n        this._renderer.setStyle(this.rootElement, 'text-overflow', '');\n        this._renderer.setStyle(this.rootElement, '-webkit-box-orient', '');\n        this._renderer.setStyle(this.rootElement, '-webkit-line-clamp', '');\n      }\n    }\n    /** @hidden */\n    _checkLineCount() {\n      if (!this.rootElement) {\n        return;\n      }\n      const style = window.getComputedStyle(this.rootElement, null);\n      this.reset();\n      const fontSize = parseInt(style.getPropertyValue('font-size'), 10);\n      const boxSizing = style.getPropertyValue('box-sizing');\n      let height = parseInt(style.getPropertyValue('height'), 10);\n      let lineHeight = parseFloat(style.getPropertyValue('line-height'));\n      if (isNaN(lineHeight)) {\n        lineHeight = fontSize * 1.2;\n      }\n      if (boxSizing === 'border-box') {\n        const padding_top = parseInt(style.getPropertyValue('padding-top'), 10);\n        const padding_bottom = parseInt(style.getPropertyValue('padding-bottom'), 10);\n        const border_top = parseInt(style.getPropertyValue('border-top-width'), 10);\n        const border_bottom = parseInt(style.getPropertyValue('border-bottom-width'), 10);\n        height = height - padding_top - padding_bottom - border_top - border_bottom;\n      }\n      this.refreshClamp();\n      this.lineCountUpdate.emit(Math.ceil(height / lineHeight));\n    }\n  }\n  LineClampDirective.ɵfac = function LineClampDirective_Factory(t) {\n    return new (t || LineClampDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n  LineClampDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: LineClampDirective,\n    selectors: [[\"\", \"fdkLineClamp\", \"\"], [\"\", \"fdLineClamp\", \"\"], [\"\", \"fd-lineclamp\", \"\"]],\n    inputs: {\n      fdLineClampLines: \"fdLineClampLines\",\n      fdLineclampState: \"fdLineclampState\"\n    },\n    outputs: {\n      lineCountUpdate: \"lineCountUpdate\"\n    },\n    exportAs: [\"fdLineClamp\"],\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return LineClampDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet LineClampModule = /*#__PURE__*/(() => {\n  class LineClampModule {}\n  LineClampModule.ɵfac = function LineClampModule_Factory(t) {\n    return new (t || LineClampModule)();\n  };\n  LineClampModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: LineClampModule\n  });\n  LineClampModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return LineClampModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst pxToNum = pixels => Number(pixels.replace('px', '')) || 0;\nconst toNativeElement = element => element instanceof ElementRef ? element.nativeElement : element;\n/** Return elements capacity (width subtract by element padding)\n * @param element - HTMLelement or element reference\n * */\nfunction getElementCapacity(element) {\n  const _element = toNativeElement(element);\n  const computedStyle = window.getComputedStyle(_element);\n  return pxToNum(computedStyle.width) - pxToNum(computedStyle.paddingLeft) - pxToNum(computedStyle.paddingRight);\n}\n/** Return elements width\n * @param element - HTMLelement or element reference\n * @param withMargin - weather to add element margins to width\n * */\nfunction getElementWidth(element, withMargin) {\n  const _element = toNativeElement(element);\n  const computedStyle = getComputedStyle(_element);\n  return withMargin ? pxToNum(computedStyle.width) + pxToNum(computedStyle.marginLeft) + pxToNum(computedStyle.marginRight) : pxToNum(computedStyle.width);\n}\n\n/** Generate a UUID v4 */\nfunction uuidv4() {\n  const modifier = 16;\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    // eslint-disable-next-line no-bitwise\n    const r = Math.random() * modifier | 0,\n      // eslint-disable-next-line no-bitwise\n      v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(modifier);\n  });\n}\nconst fileSizeMap = new Map([['KB', 1024], ['MB', 1048576], ['GB', 1073741824], ['TB', 1099511627776]]);\n/** Parse file size to bytes */\nfunction parserFileSize(fileSize) {\n  if (fileSize === '') {\n    return 0;\n  }\n  const sizes = fileSize.match(/[\\d.]+|\\D+/g);\n  if (sizes && sizes.length > 1) {\n    const size = Number(sizes[0].replace(/ +/g, ''));\n    const unit = sizes[1].replace(/ +/g, '').toUpperCase();\n    const unitSize = fileSizeMap.get(unit);\n    if (isNaN(size)) {\n      throw new Error('FileSizeError - Invalid File size please check.');\n    }\n    if (unit === 'B' || unit === 'BYTE' || unit === 'BYTES') {\n      return size;\n    }\n    if (!unitSize) {\n      throw new Error('FileSizeError - Invalid File size please check.');\n    } else {\n      return unitSize * size;\n    }\n  } else {\n    if (isNaN(Number(sizes))) {\n      throw new Error('FileSizeError - Invalid File size please check.');\n    }\n    return Number(sizes);\n  }\n}\n\n/**\n * Function used to scroll specified element by some distance\n *\n * @param containerElement     - Container element scrolled\n * @param distanceToScroll     - Distance of scroll in px\n * */\nfunction scrollTop(containerElement, distanceToScroll) {\n  // Check if scrollTo method is supported by current browser\n  if (containerElement.scrollTo && containerElement.scrollTo instanceof Function) {\n    containerElement.scrollTo({\n      top: distanceToScroll,\n      behavior: 'smooth'\n    });\n  } else {\n    containerElement.scrollTop = distanceToScroll;\n  }\n}\n\n/** Get random number from 1 to 10. */\nfunction getRandomColorAccent() {\n  return Math.floor(Math.random() * 10) + 1;\n}\n\n/**\n * RxJS wrapper for ResizeObserver class.\n * @param target HTML element to spy on.\n * @param options @see {ResizeObserverOptions}\n * @returns {Observable} with observer entries.\n */\nfunction resizeObservable(target, options) {\n  if ('ResizeObserver' in window) {\n    return new Observable(subscriber => {\n      let animationFrame;\n      const ro = new ResizeObserver(entries => {\n        animationFrame = window.requestAnimationFrame(() => {\n          subscriber.next(entries);\n        });\n      });\n      ro.observe(target, options);\n      return function unsubscribe() {\n        if (animationFrame) {\n          window.cancelAnimationFrame(animationFrame);\n        }\n        ro.unobserve(target);\n        ro.disconnect();\n      };\n    });\n  } else {\n    // If current browser does not support resizeObserver, rely on window resize and return empty array of items.\n    return fromEvent(window, 'resize').pipe(map(() => []));\n  }\n}\n\n/**\n * RxJS wrapper for IntersectionObserver class.\n * @param target HTML element to spy on.\n * @param options @see {IntersectionObserverInit}\n * @returns {Observable} with observer entries.\n */\nfunction intersectionObservable(target, options) {\n  if ('IntersectionObserver' in window) {\n    return new Observable(subscriber => {\n      const io = new IntersectionObserver(entries => {\n        subscriber.next(entries);\n      }, options);\n      io.observe(target);\n      return function unsubscribe() {\n        io.disconnect();\n      };\n    });\n  } else {\n    // If browser doesn't support IntersectionObserver API never emit a value\n    // since we're not supporting IE11 and any other browser should have it.\n    return NEVER;\n  }\n}\n\n/** Determines whether provided value is valid content density */\nfunction isValidContentDensity(size) {\n  return size === 'cozy' || size === 'compact' || size === 'condensed';\n}\n/**\n * Determines if \"compact\" styles should be applied based on provided content density\n */\nfunction isCompactDensity(size) {\n  return isValidContentDensity(size) && size !== 'cozy';\n}\nconst ModuleDeprecations = new InjectionToken('ModuleDeprecations');\n\n/** Module deprecations provider */\nfunction moduleDeprecationsProvider(classRef) {\n  return {\n    provide: ModuleDeprecations,\n    useClass: classRef,\n    multi: true\n  };\n}\n/** Module deprecations provider factory */\nfunction moduleDeprecationsFactory(factory) {\n  return {\n    provide: ModuleDeprecations,\n    ...factory,\n    multi: true\n  };\n}\n\n/**\n * Creates provider for ConsumerClass\n */\nfunction consumerProviderFactory(ConsumerClass, providedConfiguration) {\n  return {\n    provide: ConsumerClass,\n    useFactory: injector => new ConsumerClass(injector, providedConfiguration),\n    deps: [INJECTOR]\n  };\n}\n\n/** Get document font size in pixels. */\nfunction getDocumentFontSize() {\n  return document?.documentElement ? parseFloat(getComputedStyle(document.documentElement).fontSize) : 16;\n}\n\n/**\n * Function checks whether the passed number is odd.\n * @param number number to check.\n * @returns Boolean whether the number is odd.\n */\nfunction isOdd(number) {\n  return number % 2 === 1;\n}\nlet DeprecatedOnlyDigitsDirective = /*#__PURE__*/(() => {\n  class DeprecatedOnlyDigitsDirective extends DeprecatedSelector {}\n  DeprecatedOnlyDigitsDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedOnlyDigitsDirective_BaseFactory;\n    return function DeprecatedOnlyDigitsDirective_Factory(t) {\n      return (ɵDeprecatedOnlyDigitsDirective_BaseFactory || (ɵDeprecatedOnlyDigitsDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedOnlyDigitsDirective)))(t || DeprecatedOnlyDigitsDirective);\n    };\n  }();\n  DeprecatedOnlyDigitsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedOnlyDigitsDirective,\n    selectors: [[\"\", \"fdOnlyDigits\", \"\"], [\"\", \"fd-only-digits\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkOnlyDigits]', '[fdOnlyDigits], [fd-only-digits]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedOnlyDigitsDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OnlyDigitsDirective = /*#__PURE__*/(() => {\n  class OnlyDigitsDirective {\n    /** @hidden */\n    constructor(_el) {\n      this._el = _el;\n      /** Allow using decimal */\n      this.decimal = false;\n      /** Define decimal separator\n       * Default: .(dot)\n       */\n      this.decimalSeparator = '.';\n      /** @hidden */\n      this._hasDecimalPoint = false;\n      this._inputElement = this._el.nativeElement;\n    }\n    /** @hidden */\n    onKeyDown(e) {\n      if (\n      // Allow: Delete, Backspace, Tab, Escape, Enter, End, Home, Arrow Left, Arrow Right\n      KeyUtil.isKeyCode(e, [DELETE, BACKSPACE, TAB, ESCAPE, ENTER, END, HOME, LEFT_ARROW, RIGHT_ARROW]) ||\n      // Allow: Ctrl+(A/C/V/X) and Cmd+(A/C/V/X) (Mac)\n      KeyUtil.isKeyCode(e, [A, C, V, X]) && (e.ctrlKey || e.metaKey)) {\n        return; // let it happen, don't do anything\n      }\n\n      if (KeyUtil.isKeyCode(e, [DASH, NUMPAD_MINUS])) {\n        const newValue = this._forecastValue(e.key);\n        if (this._inputElement.value[0] === '-' || newValue[0] !== '-') {\n          e.preventDefault();\n          return; // has DASH point\n        } else {\n          return; // Allow: only one DASH point\n        }\n      }\n\n      if (this.decimal && e.key === this.decimalSeparator) {\n        const newValue = this._forecastValue(e.key);\n        if (newValue.split(this.decimalSeparator).length > 2) {\n          // has two or more decimal points\n          e.preventDefault();\n          return;\n        } else {\n          this._hasDecimalPoint = newValue.indexOf(this.decimalSeparator) > -1;\n          return; // Allow: only one decimal point\n        }\n      }\n      // Ensure that it is a number and stop the keypress\n      if (e.key === ' ' || isNaN(Number(e.key))) {\n        e.preventDefault();\n        return;\n      }\n    }\n    /** @hidden */\n    onPaste(event) {\n      if (window['clipboardData']) {\n        // Browser is IE\n        this._pasteData(window['clipboardData'].getData('text'));\n      } else if (event.clipboardData && event.clipboardData.getData) {\n        // Other browsers\n        this._pasteData(event.clipboardData.getData('text/plain'));\n      }\n      event.preventDefault();\n    }\n    /** @hidden */\n    onDrop(event) {\n      const textData = event.dataTransfer?.getData('text') ?? '';\n      this._inputElement.focus();\n      this._pasteData(textData);\n      event.preventDefault();\n    }\n    /** @hidden */\n    _pasteData(pastedContent) {\n      const sanitizedContent = this._sanitizeInput(pastedContent);\n      const pasted = document.execCommand('insertText', false, sanitizedContent);\n      if (!pasted) {\n        if (this._inputElement.setRangeText) {\n          const {\n            selectionStart: start,\n            selectionEnd: end\n          } = this._inputElement;\n          this._inputElement.setRangeText(sanitizedContent, start ?? 0, end ?? 0, 'end');\n          // Angular's Reactive Form relies on \"input\" event, but on Firefox, the setRangeText method doesn't trigger it\n          // so we have to trigger it ourself.\n          if (typeof window['InstallTrigger'] !== 'undefined') {\n            this._inputElement.dispatchEvent(new Event('input', {\n              cancelable: true\n            }));\n          }\n        } else {\n          // Browser does not support setRangeText, e.g. IE\n          this._insertAtCursor(this._inputElement, sanitizedContent);\n        }\n      }\n      if (this.decimal) {\n        this._hasDecimalPoint = this._inputElement.value.indexOf(this.decimalSeparator) > -1;\n      }\n    }\n    // The following 2 methods were added from the below article for browsers that do not support setRangeText\n    // https://stackoverflow.com/questions/11076975/how-to-insert-text-into-the-textarea-at-the-current-cursor-position\n    /** @hidden */\n    _insertAtCursor(myField, myValue) {\n      const startPos = myField.selectionStart ?? 0;\n      const endPos = myField.selectionEnd ?? 0;\n      myField.value = myField.value.substring(0, startPos) + myValue + myField.value.substring(endPos, myField.value.length);\n      const pos = startPos + myValue.length;\n      myField.focus();\n      myField.setSelectionRange(pos, pos);\n      this._triggerEvent(myField, 'input');\n    }\n    /** @hidden */\n    _triggerEvent(el, type) {\n      if ('createEvent' in document) {\n        // modern browsers, IE9+\n        const e = document.createEvent('HTMLEvents');\n        e.initEvent(type, false, true);\n        el.dispatchEvent(e);\n      }\n    }\n    // end stack overflow code\n    /** @hidden */\n    _sanitizeInput(input) {\n      let result = '';\n      if (this.decimal && this._isValidDecimal(input)) {\n        const regex = new RegExp(`[^0-9${this.decimalSeparator}]`, 'g');\n        result = input.replace(regex, '');\n      } else {\n        result = input.replace(/[^0-9]/g, '');\n      }\n      if (input[0] === '-') {\n        result = `-${result}`;\n      }\n      const maxLength = this._inputElement.maxLength;\n      if (maxLength > 0) {\n        // the input element has maxLength limit\n        const allowedLength = maxLength - this._inputElement.value.length;\n        result = allowedLength > 0 ? result.substring(0, allowedLength) : '';\n      }\n      return result;\n    }\n    /** @hidden */\n    _isValidDecimal(string) {\n      if (!this._hasDecimalPoint) {\n        return string.split(this.decimalSeparator).length <= 2;\n      } else {\n        // the input element already has a decimal separator\n        const selectedText = this._getSelection;\n        if (selectedText && selectedText.indexOf(this.decimalSeparator) > -1) {\n          return string.split(this.decimalSeparator).length <= 2;\n        } else {\n          return string.indexOf(this.decimalSeparator) < 0;\n        }\n      }\n    }\n    /** @hidden */\n    get _getSelection() {\n      const {\n        selectionStart,\n        selectionEnd\n      } = this._inputElement;\n      return this._inputElement.value.substring(selectionStart ?? 0, selectionEnd ?? 0);\n    }\n    /** @hidden */\n    _forecastValue(key) {\n      const {\n        selectionStart,\n        selectionEnd,\n        value: oldValue\n      } = this._inputElement;\n      const selection = oldValue.substring(selectionStart ?? 0, selectionEnd ?? 0);\n      return selection ? oldValue.replace(selection, key) : oldValue.substring(0, selectionStart ?? 0) + key + oldValue.substring(selectionStart ?? 0);\n    }\n  }\n  OnlyDigitsDirective.ɵfac = function OnlyDigitsDirective_Factory(t) {\n    return new (t || OnlyDigitsDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  OnlyDigitsDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OnlyDigitsDirective,\n    selectors: [[\"\", \"fdkOnlyDigits\", \"\"], [\"\", \"fdOnlyDigits\", \"\"], [\"\", \"fd-only-digits\", \"\"]],\n    hostBindings: function OnlyDigitsDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function OnlyDigitsDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        })(\"paste\", function OnlyDigitsDirective_paste_HostBindingHandler($event) {\n          return ctx.onPaste($event);\n        })(\"drop\", function OnlyDigitsDirective_drop_HostBindingHandler($event) {\n          return ctx.onDrop($event);\n        });\n      }\n    },\n    inputs: {\n      decimal: \"decimal\",\n      decimalSeparator: \"decimalSeparator\"\n    },\n    standalone: true\n  });\n  return OnlyDigitsDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OnlyDigitsModule = /*#__PURE__*/(() => {\n  class OnlyDigitsModule {}\n  OnlyDigitsModule.ɵfac = function OnlyDigitsModule_Factory(t) {\n    return new (t || OnlyDigitsModule)();\n  };\n  OnlyDigitsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OnlyDigitsModule\n  });\n  OnlyDigitsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return OnlyDigitsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedOverflowListItemDirective = /*#__PURE__*/(() => {\n  class DeprecatedOverflowListItemDirective extends DeprecatedSelector {}\n  DeprecatedOverflowListItemDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedOverflowListItemDirective_BaseFactory;\n    return function DeprecatedOverflowListItemDirective_Factory(t) {\n      return (ɵDeprecatedOverflowListItemDirective_BaseFactory || (ɵDeprecatedOverflowListItemDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedOverflowListItemDirective)))(t || DeprecatedOverflowListItemDirective);\n    };\n  }();\n  DeprecatedOverflowListItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedOverflowListItemDirective,\n    selectors: [[\"\", \"fdOverflowListItem\", \"\"], [\"\", \"fd-overflow-list-item\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkOverflowListItem]', '[fdOverflowListItem], [fd-overflow-list-item]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedOverflowListItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OverflowListItemDirective = /*#__PURE__*/(() => {\n  class OverflowListItemDirective {\n    /** @hidden */\n    constructor(el) {\n      this.el = el;\n    }\n  }\n  OverflowListItemDirective.ɵfac = function OverflowListItemDirective_Factory(t) {\n    return new (t || OverflowListItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  OverflowListItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowListItemDirective,\n    selectors: [[\"\", \"fdkOverflowListItem\", \"\"], [\"\", \"fdOverflowListItem\", \"\"], [\"\", \"fd-overflow-list-item\", \"\"]],\n    standalone: true\n  });\n  return OverflowListItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedOverflowListDirective = /*#__PURE__*/(() => {\n  class DeprecatedOverflowListDirective extends DeprecatedSelector {}\n  DeprecatedOverflowListDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedOverflowListDirective_BaseFactory;\n    return function DeprecatedOverflowListDirective_Factory(t) {\n      return (ɵDeprecatedOverflowListDirective_BaseFactory || (ɵDeprecatedOverflowListDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedOverflowListDirective)))(t || DeprecatedOverflowListDirective);\n    };\n  }();\n  DeprecatedOverflowListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedOverflowListDirective,\n    selectors: [[\"\", \"fdOverflowList\", \"\"], [\"\", \"fd-overflow-list\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkOverflowList]', '[fdOverflowList], [fd-overflow-list]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedOverflowListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OverflowListDirective = /*#__PURE__*/(() => {\n  class OverflowListDirective {\n    /** @hidden */\n    constructor(_el, _viewportRuler, _ngZone) {\n      this._el = _el;\n      this._viewportRuler = _viewportRuler;\n      this._ngZone = _ngZone;\n      /**\n       * @description Offset to calculate correct position\n       */\n      this.overflowOffset = 0;\n      /**\n       * @description value of display property of existed list items\n       */\n      this.itemCssBlockValue = 'flex';\n      /**\n       * @description Emits when changed amount of extra items\n       */\n      this.overflowChanged = new EventEmitter();\n      /** @hidden */\n      this._onDestroy$ = new Subject();\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._viewportRuler.change(50).pipe(takeUntil(this._onDestroy$))\n      // ViewportRuler invoked out of zone, that is why I need to invoke function in zone\n      .subscribe(() => this._ngZone.run(() => this._calculateAmountOfOverflowedItems()));\n      this._calculateAmountOfOverflowedItems();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n    }\n    /**\n     * @description Get amount of extra items in current list\n     * */\n    getAmountOfExtraItems() {\n      const elements = this.overflowItems.toArray().map(item => item.el.nativeElement);\n      const computed = getComputedStyle(this._el.nativeElement);\n      const contentWidth = this._el.nativeElement.clientWidth - parseFloat(computed.paddingLeft) - parseFloat(computed.paddingRight);\n      return this._checkWidthWithOffset(elements, contentWidth);\n    }\n    /** @hidden */\n    _calculateAmountOfOverflowedItems() {\n      const extra = this.getAmountOfExtraItems();\n      this.overflowChanged.emit(extra);\n    }\n    /**\n     * @hidden\n     * @param arrItems\n     * @param containerWidth\n     * @param checkWithOffset\n     * */\n    _checkWidthWithOffset(arrItems, containerWidth, checkWithOffset = false) {\n      let itemsTotalWidth = 0;\n      const parentWidth = checkWithOffset ? containerWidth - this.overflowOffset : containerWidth;\n      arrItems.forEach(item => {\n        item.hidden = true;\n        item.style.display = this.itemCssBlockValue;\n      });\n      for (let i = 0; i < arrItems.length; i++) {\n        const item = arrItems[i];\n        itemsTotalWidth += this.isRtl ? containerWidth - item.offsetLeft - itemsTotalWidth : item.offsetWidth + item.offsetLeft - itemsTotalWidth;\n        if (parentWidth < itemsTotalWidth) {\n          this._clearTempStyles(arrItems);\n          return checkWithOffset ? arrItems.length - i : this._checkWidthWithOffset(arrItems, containerWidth, true);\n        }\n      }\n      this._clearTempStyles(arrItems);\n      return 0;\n    }\n    /**\n     * @param arrItems\n     * @hidden\n     * */\n    _clearTempStyles(arrItems) {\n      arrItems.forEach(item => {\n        item.hidden = false;\n        item.style.removeProperty('display');\n      });\n    }\n  }\n  OverflowListDirective.ɵfac = function OverflowListDirective_Factory(t) {\n    return new (t || OverflowListDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$2.ViewportRuler), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n  OverflowListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: OverflowListDirective,\n    selectors: [[\"\", \"fdkOverflowList\", \"\"], [\"\", \"fdOverflowList\", \"\"], [\"\", \"fd-overflow-list\", \"\"]],\n    contentQueries: function OverflowListDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, OverflowListItemDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.overflowItems = _t);\n      }\n    },\n    inputs: {\n      overflowOffset: \"overflowOffset\",\n      isRtl: \"isRtl\",\n      itemCssBlockValue: \"itemCssBlockValue\"\n    },\n    outputs: {\n      overflowChanged: \"overflowChanged\"\n    },\n    standalone: true\n  });\n  return OverflowListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet OverflowListModule = /*#__PURE__*/(() => {\n  class OverflowListModule {}\n  OverflowListModule.ɵfac = function OverflowListModule_Factory(t) {\n    return new (t || OverflowListModule)();\n  };\n  OverflowListModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: OverflowListModule\n  });\n  OverflowListModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return OverflowListModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedRepeatDirective = /*#__PURE__*/(() => {\n  class DeprecatedRepeatDirective extends DeprecatedSelector {}\n  DeprecatedRepeatDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedRepeatDirective_BaseFactory;\n    return function DeprecatedRepeatDirective_Factory(t) {\n      return (ɵDeprecatedRepeatDirective_BaseFactory || (ɵDeprecatedRepeatDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedRepeatDirective)))(t || DeprecatedRepeatDirective);\n    };\n  }();\n  DeprecatedRepeatDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedRepeatDirective,\n    selectors: [[\"\", \"fdRepeat\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkRepeat]', '[fdRepeat]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedRepeatDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Directive to repeatably render template N times.\n */\nlet RepeatDirective = /*#__PURE__*/(() => {\n  class RepeatDirective {\n    /** @hidden */\n    get _repeatCount() {\n      return this.count || this.deprecatedCount;\n    }\n    /** @hidden */\n    constructor(_templateRef, _viewContainerRef) {\n      this._templateRef = _templateRef;\n      this._viewContainerRef = _viewContainerRef;\n    }\n    /** @hidden */\n    ngOnChanges(changes) {\n      if ((changes['count'] || changes['deprecatedCount']) && Number.isInteger(this._repeatCount)) {\n        this._viewContainerRef.clear();\n        for (let index = 0; index < Math.max(0, this._repeatCount); index++) {\n          this._viewContainerRef.createEmbeddedView(this._templateRef, {\n            index\n          });\n        }\n      }\n    }\n  }\n  RepeatDirective.ɵfac = function RepeatDirective_Factory(t) {\n    return new (t || RepeatDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  RepeatDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: RepeatDirective,\n    selectors: [[\"\", \"fdkRepeat\", \"\"], [\"\", \"fdRepeat\", \"\"]],\n    inputs: {\n      count: [\"fdkRepeat\", \"count\"],\n      deprecatedCount: [\"fdRepeat\", \"deprecatedCount\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return RepeatDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet RepeatModule = /*#__PURE__*/(() => {\n  class RepeatModule {}\n  RepeatModule.ɵfac = function RepeatModule_Factory(t) {\n    return new (t || RepeatModule)();\n  };\n  RepeatModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: RepeatModule\n  });\n  RepeatModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return RepeatModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedResizeHandleDirective = /*#__PURE__*/(() => {\n  class DeprecatedResizeHandleDirective extends DeprecatedSelector {}\n  DeprecatedResizeHandleDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedResizeHandleDirective_BaseFactory;\n    return function DeprecatedResizeHandleDirective_Factory(t) {\n      return (ɵDeprecatedResizeHandleDirective_BaseFactory || (ɵDeprecatedResizeHandleDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedResizeHandleDirective)))(t || DeprecatedResizeHandleDirective);\n    };\n  }();\n  DeprecatedResizeHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedResizeHandleDirective,\n    selectors: [[\"\", \"fdResizeHandle\", \"\"], [\"\", \"fd-resize-handle\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkResizeHandle]', '[fdResizeHandle], [fd-resize-handle]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedResizeHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ResizeHandleDirective = /*#__PURE__*/(() => {\n  class ResizeHandleDirective {\n    /** @hidden */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n  }\n  ResizeHandleDirective.ɵfac = function ResizeHandleDirective_Factory(t) {\n    return new (t || ResizeHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  ResizeHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ResizeHandleDirective,\n    selectors: [[\"\", \"fdkResizeHandle\", \"\"], [\"\", \"fdResizeHandle\", \"\"], [\"\", \"fd-resize-handle\", \"\"]],\n    standalone: true\n  });\n  return ResizeHandleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedResizeDirective = /*#__PURE__*/(() => {\n  class DeprecatedResizeDirective extends DeprecatedSelector {}\n  DeprecatedResizeDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedResizeDirective_BaseFactory;\n    return function DeprecatedResizeDirective_Factory(t) {\n      return (ɵDeprecatedResizeDirective_BaseFactory || (ɵDeprecatedResizeDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedResizeDirective)))(t || DeprecatedResizeDirective);\n    };\n  }();\n  DeprecatedResizeDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedResizeDirective,\n    selectors: [[\"\", \"fdResize\", \"\"], [\"\", \"fd-resize\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkResize]', '[fdResize], [fd-resize]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedResizeDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ResizeDirective = /*#__PURE__*/(() => {\n  class ResizeDirective {\n    /** Resize handle reference - should be used if Resize handle is not a ContentChild of resizable container */\n    // eslint-disable-next-line @angular-eslint/no-input-rename\n    set setResizeHandleReference(value) {\n      this.resizeHandleReference = value;\n    }\n    /** @hidden */\n    constructor(_elementRef, _rtlService) {\n      this._elementRef = _elementRef;\n      this._rtlService = _rtlService;\n      /** Element limiting resizable container growth */\n      // eslint-disable-next-line @angular-eslint/no-input-rename\n      this.resizeBoundary = 'body';\n      /** Whether resizable behaviour should be disabled */\n      // eslint-disable-next-line @angular-eslint/no-input-rename\n      this.disabled = false;\n      /** Localization of resize handle inside resizable container */\n      // eslint-disable-next-line @angular-eslint/no-input-rename\n      this.resizeHandleLocation = 'bottom-right';\n      /** Emits event when resizing has tarted */\n      // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n      this.onResizeStart = new EventEmitter();\n      /** Emits event when resizing has ended */\n      // eslint-disable-next-line @angular-eslint/no-output-on-prefix\n      this.onResizeEnd = new EventEmitter();\n      /** @hidden */\n      this._subscriptions = new Subscription();\n      /** @hidden */\n      this._isRtl = false;\n    }\n    /** @hidden */\n    ngOnChanges(changes) {\n      if (changes['disabled']) {\n        if (changes['disabled'].previousValue === false && changes['disabled'].currentValue === true) {\n          this._subscriptions.unsubscribe();\n        } else if (changes['disabled'].previousValue === true && changes['disabled'].currentValue === false) {\n          this._setResizeListeners();\n        }\n      }\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      if (this._rtlService) {\n        this._subscriptions.add(this._rtlService.rtl.subscribe(isRtl => this._isRtl = isRtl));\n      }\n      if (!this.disabled) {\n        this._setResizeListeners();\n      }\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscriptions.unsubscribe();\n    }\n    /** @hidden */\n    get _direction() {\n      return this._isRtl ? -1 : 1;\n    }\n    /** @hidden Sets Resize listeners */\n    _setResizeListeners() {\n      const resize = this._getResizeFunction();\n      const moveOffset = this._getMoveOffsetFunction();\n      const resizeContainer = this._findResizeContainer();\n      if (!resizeContainer) {\n        return;\n      }\n      const isBoundaryOverflow = this._getBoundaryOverflowFunction(resizeContainer);\n      const mouseUpEvent$ = fromEvent(window, 'mouseup');\n      const mouseMoveEvent$ = fromEvent(resizeContainer, 'mousemove');\n      const mouseDownEvent$ = fromEvent(this.resizeHandleReference.elementRef.nativeElement, 'mousedown');\n      const resizeActive$ = merge(mouseDownEvent$.pipe(mapTo(true)), mouseUpEvent$.pipe(mapTo(false)));\n      const emitResizableEvents$ = this._getResizeEventsNotifiers(resizeActive$);\n      const preventOtherPointerEvents$ = this._blockOtherPointerEvents(resizeActive$);\n      const resizingCursorMovement$ = mouseMoveEvent$.pipe(pairwise(), map(([event1, event2]) => moveOffset(event1, event2)), filter(move => isBoundaryOverflow(move)));\n      const setupResizer = () => {\n        resizingCursorMovement$.pipe(takeUntil(mouseUpEvent$)).subscribe(event => resize(event));\n      };\n      const setupResize$ = resizeActive$.pipe(filter(isActive => isActive), tap(() => setupResizer()));\n      this._subscriptions.add(setupResize$.subscribe());\n      this._subscriptions.add(emitResizableEvents$.subscribe());\n      this._subscriptions.add(preventOtherPointerEvents$.subscribe());\n    }\n    /** @hidden Creates resize function*/\n    _getResizeFunction() {\n      return move => {\n        this._elementRef.nativeElement.style.width = `${this._elementRef.nativeElement.offsetWidth + move.x}px`;\n        this._elementRef.nativeElement.style.height = `${this._elementRef.nativeElement.offsetHeight + move.y}px`;\n      };\n    }\n    /** @hidden Creates move function */\n    _getMoveOffsetFunction() {\n      let verticalModifier;\n      let horizontalModifier;\n      switch (this.resizeHandleLocation) {\n        case 'top-left':\n          horizontalModifier = -1;\n          verticalModifier = -1;\n          break;\n        case 'top-right':\n          horizontalModifier = -1;\n          verticalModifier = 1;\n          break;\n        case 'bottom-left':\n          horizontalModifier = 1;\n          verticalModifier = -1;\n          break;\n        case 'bottom-right':\n          horizontalModifier = 1;\n          verticalModifier = 1;\n          break;\n      }\n      return (event1, event2) => {\n        const x = (event2.screenX - event1.screenX) * this._direction;\n        const y = event2.screenY - event1.screenY;\n        return {\n          x: x * verticalModifier,\n          y: y * horizontalModifier\n        };\n      };\n    }\n    /** @hidden Return boundary container */\n    _findResizeContainer() {\n      let resizeContainer;\n      if (typeof this.resizeBoundary === 'string') {\n        resizeContainer = this._elementRef.nativeElement.closest(this.resizeBoundary);\n      } else {\n        resizeContainer = this.resizeBoundary;\n      }\n      if (resizeContainer) {\n        return resizeContainer;\n      } else {\n        console.warn(`fdResize - Cannot find \"${this.resizeBoundary}\", falling back to \"body\"`);\n        return document.querySelector('body');\n      }\n    }\n    /** @hidden Check whether resizable container is overflowing boundary container */\n    _getBoundaryOverflowFunction(resizeContainer) {\n      return move => {\n        const containerPosition = resizeContainer.getBoundingClientRect();\n        const elementPosition = this._elementRef.nativeElement.getBoundingClientRect();\n        switch (this.resizeHandleLocation) {\n          case 'top-left':\n            return containerPosition.top < elementPosition.top + move.y && containerPosition.left < elementPosition.left + move.x;\n          case 'top-right':\n            return containerPosition.top < elementPosition.top + move.y && containerPosition.right > elementPosition.right + move.x;\n          case 'bottom-left':\n            return containerPosition.bottom > elementPosition.bottom + move.y && containerPosition.left < elementPosition.left + move.x;\n          case 'bottom-right':\n            return containerPosition.bottom > elementPosition.bottom + move.y && containerPosition.right > elementPosition.right + move.x;\n        }\n      };\n    }\n    /** @hidden Create Observable notifying on resize actions */\n    _getResizeEventsNotifiers(trigger$) {\n      const emitResizableStart$ = trigger$.pipe(filter(isActive => isActive), tap(() => this.onResizeStart.emit()));\n      const emitResizableEnd$ = trigger$.pipe(filter(isActive => !isActive), tap(() => this.onResizeEnd.emit()));\n      return merge(emitResizableStart$, emitResizableEnd$);\n    }\n    /** @hidden Block resizable container pointer events when resizing  */\n    _blockOtherPointerEvents(trigger$) {\n      return trigger$.pipe(map(isActive => isActive ? 'none' : 'auto'), tap(value => this._elementRef.nativeElement.style.pointerEvents = value));\n    }\n  }\n  ResizeDirective.ɵfac = function ResizeDirective_Factory(t) {\n    return new (t || ResizeDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(RtlService, 8));\n  };\n  ResizeDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ResizeDirective,\n    selectors: [[\"\", \"fdkResize\", \"\"], [\"\", \"fdResize\", \"\"], [\"\", \"fd-resize\", \"\"]],\n    contentQueries: function ResizeDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, ResizeHandleDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.resizeHandleReference = _t.first);\n      }\n    },\n    inputs: {\n      resizeBoundary: [\"fdkResizeBoundary\", \"resizeBoundary\"],\n      disabled: [\"fdkResizeDisabled\", \"disabled\"],\n      resizeHandleLocation: [\"fdkResizeHandleLocation\", \"resizeHandleLocation\"],\n      setResizeHandleReference: [\"fdkResizeResizeHandleRef\", \"setResizeHandleReference\"]\n    },\n    outputs: {\n      onResizeStart: \"onResizeStart\",\n      onResizeEnd: \"onResizeEnd\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return ResizeDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ResizeModule = /*#__PURE__*/(() => {\n  class ResizeModule {}\n  ResizeModule.ɵfac = function ResizeModule_Factory(t) {\n    return new (t || ResizeModule)();\n  };\n  ResizeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ResizeModule\n  });\n  ResizeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ResizeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedTemplateSelectorDirective = /*#__PURE__*/(() => {\n  class DeprecatedTemplateSelectorDirective extends DeprecatedSelector {}\n  DeprecatedTemplateSelectorDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedTemplateSelectorDirective_BaseFactory;\n    return function DeprecatedTemplateSelectorDirective_Factory(t) {\n      return (ɵDeprecatedTemplateSelectorDirective_BaseFactory || (ɵDeprecatedTemplateSelectorDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedTemplateSelectorDirective)))(t || DeprecatedTemplateSelectorDirective);\n    };\n  }();\n  DeprecatedTemplateSelectorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedTemplateSelectorDirective,\n    selectors: [[\"\", \"fdTemplate\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkTemplate]', '[fdTemplate]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedTemplateSelectorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TemplateDirective = /*#__PURE__*/(() => {\n  class TemplateDirective {\n    /** @hidden */\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n    /** @hidden */\n    getName() {\n      return this.name;\n    }\n  }\n  TemplateDirective.ɵfac = function TemplateDirective_Factory(t) {\n    return new (t || TemplateDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef));\n  };\n  TemplateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TemplateDirective,\n    selectors: [[\"\", \"fdkTemplate\", \"\"], [\"\", \"fdTemplate\", \"\"]],\n    inputs: {\n      name: [\"fdkTemplate\", \"name\"]\n    },\n    standalone: true\n  });\n  return TemplateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TemplateModule = /*#__PURE__*/(() => {\n  class TemplateModule {}\n  TemplateModule.ɵfac = function TemplateModule_Factory(t) {\n    return new (t || TemplateModule)();\n  };\n  TemplateModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TemplateModule\n  });\n  TemplateModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TemplateModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedTruncateSelectorDirective = /*#__PURE__*/(() => {\n  class DeprecatedTruncateSelectorDirective extends DeprecatedSelector {}\n  DeprecatedTruncateSelectorDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedTruncateSelectorDirective_BaseFactory;\n    return function DeprecatedTruncateSelectorDirective_Factory(t) {\n      return (ɵDeprecatedTruncateSelectorDirective_BaseFactory || (ɵDeprecatedTruncateSelectorDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedTruncateSelectorDirective)))(t || DeprecatedTruncateSelectorDirective);\n    };\n  }();\n  DeprecatedTruncateSelectorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedTruncateSelectorDirective,\n    selectors: [[\"\", \"fdTruncate\", \"\"], [\"\", \"fd-truncate\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkTemplate]', '[fdTruncate], [fd-truncate]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedTruncateSelectorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TruncateDirective = /*#__PURE__*/(() => {\n  class TruncateDirective {\n    /**\n     * Width in pixel for truncation of an element , by default\n     */\n    set fdkTruncateWidth(value) {\n      this._customWidthCount = coerceNumberProperty(value);\n    }\n    /** @hidden */\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n      /**\n       * Truncating state\n       */\n      this.fdkTruncateState = false;\n      /** @hidden */\n      this._customWidthCount = 200;\n      /** @hidden */\n      this.takeDefaultStyleOnce = true;\n    }\n    /**\n     * Root native element\n     */\n    get rootElement() {\n      return this._elementRef.nativeElement;\n    }\n    /**\n     * Method saves default style of target element before first truncate.\n     */\n    setDefaultStyle() {\n      if (this.takeDefaultStyleOnce) {\n        this._defaultStyle = this._truncateTarget.style.cssText;\n        this.takeDefaultStyleOnce = false;\n      }\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      if (this.rootElement) {\n        this._truncate();\n      }\n    }\n    /** @hidden */\n    ngOnChanges() {\n      this._truncate();\n    }\n    /** @hidden */\n    _truncate() {\n      this._truncateTarget = this.rootElement;\n      if (!this._truncateTarget) {\n        return;\n      }\n      this.setDefaultStyle();\n      this._truncationStyle = `${this._defaultStyle} max-width: ${this._customWidthCount}px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;`;\n      this._truncateTarget.style.cssText = this.fdkTruncateState ? this._truncationStyle : this._defaultStyle;\n    }\n  }\n  TruncateDirective.ɵfac = function TruncateDirective_Factory(t) {\n    return new (t || TruncateDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  TruncateDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: TruncateDirective,\n    selectors: [[\"\", \"fdkTruncate\", \"\"], [\"\", \"fdTruncate\", \"\"], [\"\", \"fd-truncate\", \"\"]],\n    inputs: {\n      fdkTruncateWidth: \"fdkTruncateWidth\",\n      fdkTruncateState: \"fdkTruncateState\"\n    },\n    standalone: true,\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return TruncateDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TruncateModule = /*#__PURE__*/(() => {\n  class TruncateModule {}\n  TruncateModule.ɵfac = function TruncateModule_Factory(t) {\n    return new (t || TruncateModule)();\n  };\n  TruncateModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: TruncateModule\n  });\n  TruncateModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return TruncateModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FDK_FOCUSABLE_ITEM_DIRECTIVE = new InjectionToken('Focusable directive token');\nconst DEFAULT_CONTENT_DENSITY = 'cozy';\n/**\n * Service taking care of ContentDensity\n */\nlet ContentDensityService = /*#__PURE__*/(() => {\n  class ContentDensityService {\n    /** @hidden */\n    constructor() {\n      /** Content Density BehaviourSubject */\n      this.contentDensity = new BehaviorSubject(DEFAULT_CONTENT_DENSITY);\n      if (isDevMode()) {\n        console.warn(`[Deprecated] ContentDensityService is deprecated and will be removed in the next major version.\n                 Please use ContentDensityControllerService instead, or use the ContentDensityModule forRoot method.`);\n      }\n    }\n    /** @hidden */\n    get _contentDensityListener() {\n      return this.contentDensity.pipe(distinctUntilChanged(), startWith(this.contentDensity.getValue()));\n    }\n    /** @hidden */\n    get _isCompactDensity() {\n      return this._contentDensityListener.pipe(map(density => isCompactDensity(density)));\n    }\n  }\n  ContentDensityService.ɵfac = function ContentDensityService_Factory(t) {\n    return new (t || ContentDensityService)();\n  };\n  ContentDensityService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ContentDensityService,\n    factory: ContentDensityService.ɵfac\n  });\n  return ContentDensityService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DestroyedService = /*#__PURE__*/(() => {\n  class DestroyedService extends ReplaySubject {\n    /** @hidden */\n    constructor() {\n      super(1);\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.next();\n      this.complete();\n    }\n  }\n  DestroyedService.ɵfac = function DestroyedService_Factory(t) {\n    return new (t || DestroyedService)();\n  };\n  DestroyedService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DestroyedService,\n    factory: DestroyedService.ɵfac\n  });\n  return DestroyedService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusTrapService = /*#__PURE__*/(() => {\n  class FocusTrapService {\n    constructor() {\n      /** @hidden */\n      this._focusTrapInstances = new Map();\n    }\n    /**\n     * Creates focus trap instance for defined element\n     * @param element Container for which to create focus trap\n     * @param userOptions Focus-trap specific configuration\n     * @returns {string} Unique ID of focus trap instance\n     */\n    createFocusTrap(element, userOptions) {\n      const uid = uuidv4();\n      const trap = createFocusTrap(element, userOptions);\n      this._focusTrapInstances.set(uid, trap);\n      this.activateFocusTrap(uid);\n      return uid;\n    }\n    /**\n     * Activates focus trap for defined ID\n     * @param id Unique ID of focus trap instance\n     */\n    activateFocusTrap(id) {\n      if (!this._focusTrapExists(id)) {\n        return;\n      }\n      const trap = this.getFocusTrapInstance(id);\n      trap?.activate();\n    }\n    /**\n     * Deactivates focus trap for defined ID\n     * @param id Unique ID of focus trap instance\n     */\n    deactivateFocusTrap(id) {\n      if (!this._focusTrapExists(id)) {\n        return;\n      }\n      const trap = this.getFocusTrapInstance(id);\n      trap?.deactivate();\n      this._focusTrapInstances.delete(id);\n    }\n    /**\n     * Pauses current focus trap.\n     */\n    pauseCurrentFocusTrap() {\n      if (this._focusTrapInstances.size === 0) {\n        return;\n      }\n      const trapItem = this._getLastTrapedItem();\n      trapItem?.pause();\n    }\n    /**\n     * Unpauses current focus trap.\n     */\n    unpauseCurrentFocusTrap() {\n      if (this._focusTrapInstances.size === 0) {\n        return;\n      }\n      const trapItem = this._getLastTrapedItem();\n      trapItem?.unpause();\n    }\n    /**\n     * Get focus trap instance by ID.\n     * @param id ID of the instance.\n     * @returns Focus trap instance if exists.\n     */\n    getFocusTrapInstance(id) {\n      return this._focusTrapInstances.get(id);\n    }\n    /** @hidden */\n    _getLastTrapedItem() {\n      const lastItem = Array.from(this._focusTrapInstances).pop();\n      return lastItem ? lastItem[1] : undefined;\n    }\n    /** @hidden */\n    _focusTrapExists(id) {\n      return this._focusTrapInstances.has(id);\n    }\n  }\n  FocusTrapService.ɵfac = function FocusTrapService_Factory(t) {\n    return new (t || FocusTrapService)();\n  };\n  FocusTrapService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FocusTrapService,\n    factory: FocusTrapService.ɵfac,\n    providedIn: 'root'\n  });\n  return FocusTrapService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet KeyboardSupportService = /*#__PURE__*/(() => {\n  class KeyboardSupportService {\n    constructor() {\n      /** Subject that is thrown, when focus escapes the list */\n      this.focusEscapeList = new Subject();\n      /** An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)  */\n      this._onDestroy$ = new Subject();\n      /** An RxJS Subject that will kill the data stream upon queryList changes (for unsubscribing)  */\n      this._onRefresh$ = new Subject();\n      /** @hidden\n       * allow tab key navigation. default is true.\n       */\n      this._tabKeyNavigation = true;\n    }\n    /** @hidden */\n    get keyManager() {\n      return this._keyManager;\n    }\n    /** @hidden */\n    setKeyboardService(queryList, wrap, tabKeyNavigation = true) {\n      this._itemList = queryList;\n      this._tabKeyNavigation = tabKeyNavigation;\n      this._keyManager = new FocusKeyManager(queryList).withWrap(wrap).withHomeAndEnd();\n      queryList.changes.pipe(takeUntil(this._onDestroy$), startWith(0)).subscribe(() => this._refreshEscapeLogic(queryList));\n    }\n    /** @hidden */\n    onKeyDown(event) {\n      this._keyManager.onKeydown(event);\n      if (KeyUtil.isKeyCode(event, TAB)) {\n        if (KeyUtil.isKeyCode(event, TAB) && this._tabKeyNavigation) {\n          event.preventDefault();\n          hasModifierKey(event, 'shiftKey') ? this.keyManager.setPreviousItemActive() : this.keyManager.setNextItemActive();\n        }\n      }\n    }\n    /** Destroys KeyboardSupportService dependencies */\n    onDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n      this._keyManager.destroy();\n    }\n    /** @hidden */\n    _refreshEscapeLogic(queryList) {\n      const createEscapeListener = (listItem, onKeyCode, escapeDirection) => {\n        listItem.keyDown.pipe(takeUntil(unsubscribe$), filter(event => KeyUtil.isKeyCode(event, onKeyCode)), tap(event => event.preventDefault())).subscribe(() => this.focusEscapeList.next(escapeDirection));\n      };\n      /** Finish all of the streams, form before */\n      this._onRefresh$.next();\n      const unsubscribe$ = merge(this._onRefresh$, this._onDestroy$);\n      if (queryList.length) {\n        createEscapeListener(queryList.last, DOWN_ARROW, 'down');\n        createEscapeListener(queryList.first, UP_ARROW, 'up');\n      }\n    }\n  }\n  KeyboardSupportService.ɵfac = function KeyboardSupportService_Factory(t) {\n    return new (t || KeyboardSupportService)();\n  };\n  KeyboardSupportService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: KeyboardSupportService,\n    factory: KeyboardSupportService.ɵfac,\n    providedIn: 'root'\n  });\n  return KeyboardSupportService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass MockStorage {\n  // eslint-disable-next-line\n  key(index) {}\n  clear() {}\n  // eslint-disable-next-line\n  getItem(key) {}\n  // eslint-disable-next-line\n  removeItem(key) {}\n  // eslint-disable-next-line\n  setItem(key, value) {}\n}\nlet LocalStorageService = /*#__PURE__*/(() => {\n  class LocalStorageService {\n    /** @hidden */\n    constructor() {\n      typeof localStorage !== 'undefined' ? this._storage = localStorage : this._storage = new MockStorage();\n    }\n    /** Get item from local storage. */\n    get(key) {\n      const value = this._storage.getItem(key);\n      if (value) {\n        return JSON.parse(value);\n      }\n      return null;\n    }\n    /** Set item in local storage. */\n    set(key, value) {\n      this._storage.setItem(key, JSON.stringify(value));\n    }\n  }\n  LocalStorageService.ɵfac = function LocalStorageService_Factory(t) {\n    return new (t || LocalStorageService)();\n  };\n  LocalStorageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: LocalStorageService,\n    factory: LocalStorageService.ɵfac,\n    providedIn: 'root'\n  });\n  return LocalStorageService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ResizeObserverFactory = /*#__PURE__*/(() => {\n  class ResizeObserverFactory {\n    /** Factory to create ResizeObserver if it's present in browser.  */\n    create(callback) {\n      return typeof ResizeObserver === 'undefined' ? null : new ResizeObserver(callback);\n    }\n  }\n  ResizeObserverFactory.ɵfac = function ResizeObserverFactory_Factory(t) {\n    return new (t || ResizeObserverFactory)();\n  };\n  ResizeObserverFactory.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResizeObserverFactory,\n    factory: ResizeObserverFactory.ɵfac,\n    providedIn: 'root'\n  });\n  return ResizeObserverFactory;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ResizeObserverService = /*#__PURE__*/(() => {\n  class ResizeObserverService {\n    /** @hidden */\n    constructor(_resizeObserverFactory) {\n      this._resizeObserverFactory = _resizeObserverFactory;\n      /** @hidden */\n      this._observedElements = new Map();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n    }\n    /** Observe the given element and emit whenever its size changes. */\n    observe(elementOrRef) {\n      const element = coerceElement(elementOrRef);\n      return new Observable(observer => {\n        const stream = this._observeElement(element);\n        const subscription = stream?.subscribe(observer);\n        return () => {\n          subscription?.unsubscribe();\n          this._unobserveElement(element);\n        };\n      });\n    }\n    /**\n     * Observes the given element by using the existing MutationObserver if available, or creating a\n     * new one if not.\n     */\n    _observeElement(element) {\n      let observedElement = this._observedElements.get(element);\n      if (!observedElement) {\n        const stream = new Subject();\n        const observer = this._resizeObserverFactory.create(mutations => stream.next(mutations));\n        if (observer) {\n          observer.observe(element);\n        }\n        observedElement = {\n          observer,\n          stream,\n          count: 0\n        };\n        this._observedElements.set(element, observedElement);\n      }\n      observedElement.count++;\n      return observedElement?.stream;\n    }\n    /**\n     * Un-observes the given element and cleans up the underlying MutationObserver if nobody else is\n     * observing this element.\n     */\n    _unobserveElement(element) {\n      const observedElement = this._observedElements.get(element);\n      if (!observedElement) {\n        return;\n      }\n      if (--observedElement.count) {\n        return;\n      }\n      this._cleanupObserver(element);\n    }\n    /** Clean up the underlying MutationObserver for the specified element. */\n    _cleanupObserver(element) {\n      const observedElement = this._observedElements.get(element);\n      if (!observedElement) {\n        return;\n      }\n      const {\n        observer,\n        stream\n      } = observedElement;\n      if (observer) {\n        observer.disconnect();\n      }\n      stream.complete();\n      this._observedElements.delete(element);\n    }\n  }\n  ResizeObserverService.ɵfac = function ResizeObserverService_Factory(t) {\n    return new (t || ResizeObserverService)(i0.ɵɵinject(ResizeObserverFactory));\n  };\n  ResizeObserverService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ResizeObserverService,\n    factory: ResizeObserverService.ɵfac,\n    providedIn: 'root'\n  });\n  return ResizeObserverService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Retrieves native element from ElementRef.\n */\nfunction getNativeElement(element) {\n  let coercible = element;\n  if (isHasElementRef(element)) {\n    coercible = element.elementRef();\n  }\n  return coerceElement(coercible);\n}\n/**\n * Checks whether object has element reference in it.\n */\nfunction isHasElementRef(something) {\n  return something && typeof something['elementRef'] === 'function';\n}\n\n/* eslint-disable @typescript-eslint/no-non-null-assertion */\nlet AttributeObserver = /*#__PURE__*/(() => {\n  class AttributeObserver {\n    /** @hidden */\n    constructor(_mutationObserverFactory) {\n      this._mutationObserverFactory = _mutationObserverFactory;\n      /** @Hidden */\n      this._observedElements = new Map();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._observedElements.forEach((_, element) => this._cleanupObserver(element));\n    }\n    /** @Hidden */\n    observe(elementOrRef) {\n      const element = getNativeElement(elementOrRef);\n      return new Observable(observer => {\n        const stream = this._observeElement(element);\n        const subscription = stream.subscribe(observer);\n        return () => {\n          subscription.unsubscribe();\n          this._unobserveElement(element);\n        };\n      });\n    }\n    /** @Hidden */\n    unobserve(element) {\n      this._unobserveElement(getNativeElement(element));\n    }\n    /** @hidden */\n    _observeElement(element) {\n      if (!this._observedElements.has(element)) {\n        const stream = new Subject();\n        const observer = this._mutationObserverFactory.create(mutations => stream.next(mutations));\n        if (observer) {\n          observer.observe(element, {\n            attributes: true\n          });\n        }\n        this._observedElements.set(element, {\n          observer,\n          stream,\n          count: 1\n        });\n      } else {\n        this._observedElements.get(element).count++;\n      }\n      return this._observedElements.get(element).stream;\n    }\n    /** @Hidden */\n    _unobserveElement(element) {\n      if (this._observedElements.has(element)) {\n        this._observedElements.get(element).count--;\n        if (!this._observedElements.get(element).count) {\n          this._cleanupObserver(element);\n        }\n      }\n    }\n    /** @hidden */\n    _cleanupObserver(element) {\n      if (this._observedElements.has(element)) {\n        const {\n          observer,\n          stream\n        } = this._observedElements.get(element);\n        if (observer) {\n          observer.disconnect();\n        }\n        stream.complete();\n        this._observedElements.delete(element);\n      }\n    }\n  }\n  AttributeObserver.ɵfac = function AttributeObserver_Factory(t) {\n    return new (t || AttributeObserver)(i0.ɵɵinject(i1$3.MutationObserverFactory));\n  };\n  AttributeObserver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AttributeObserver,\n    factory: AttributeObserver.ɵfac,\n    providedIn: 'root'\n  });\n  return AttributeObserver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst focusableTagnamesByDefault = new Set(['select', 'textarea', 'input', 'button', 'audio', 'video']);\nconst focusableTagOptions = [{\n  tag: 'div',\n  attributes: [{\n    name: 'contenteditable',\n    valueMatcher: value => coerceBooleanProperty(value)\n  }]\n}];\n/** @hidden */\nfunction isElementFocusableByDefault(el) {\n  const element = getNativeElement(el);\n  const tagName = element.tagName.toLowerCase();\n  if (focusableTagnamesByDefault.has(tagName)) {\n    return true;\n  }\n  return focusableTagOptions.some(tagOptions => {\n    if (tagOptions.tag === tagName) {\n      return tagOptions.attributes.some(attribute => {\n        const attrVal = element.getAttribute(attribute.name);\n        return attrVal && attribute.valueMatcher(attrVal);\n      });\n    }\n    return false;\n  });\n}\nlet DisabledObserver = /*#__PURE__*/(() => {\n  class DisabledObserver {\n    /** @hidden */\n    constructor(_attributeObserver) {\n      this._attributeObserver = _attributeObserver;\n    }\n    /** @hidden */\n    static isDisabled(el) {\n      return el.hasAttribute('disabled') || el.getAttribute('aria-disabled') === 'true' || el.classList.contains('is-disabled');\n    }\n    /** @hidden */\n    observe(element) {\n      return this._attributeObserver.observe(element).pipe(map(() => DisabledObserver.isDisabled(getNativeElement(element))), distinctUntilChanged());\n    }\n    /** @hidden */\n    unobserve(element) {\n      this._attributeObserver.unobserve(element);\n    }\n  }\n  DisabledObserver.ɵfac = function DisabledObserver_Factory(t) {\n    return new (t || DisabledObserver)(i0.ɵɵinject(AttributeObserver));\n  };\n  DisabledObserver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DisabledObserver,\n    factory: DisabledObserver.ɵfac,\n    providedIn: 'root'\n  });\n  return DisabledObserver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusableObserver = /*#__PURE__*/(() => {\n  class FocusableObserver {\n    /** @hidden */\n    constructor(_attributeObserver) {\n      this._attributeObserver = _attributeObserver;\n    }\n    /** @Hidden */\n    static isFocusable(element, respectTabIndex) {\n      if (DisabledObserver.isDisabled(element)) {\n        return false;\n      }\n      if (!respectTabIndex) {\n        return true;\n      }\n      const tabIndex = parseInt(element.getAttribute('tabindex') + '', 10);\n      if (isNaN(tabIndex)) {\n        return isElementFocusableByDefault(element);\n      }\n      return tabIndex > -1;\n    }\n    /** @hidden */\n    observe(element, respectTabIndex = true) {\n      const nativeElement = getNativeElement(element);\n      return this._attributeObserver.observe(nativeElement).pipe(map(() => FocusableObserver.isFocusable(nativeElement, respectTabIndex)), distinctUntilChanged());\n    }\n    /** @hidden */\n    unobserve(element) {\n      this._attributeObserver.unobserve(element);\n    }\n  }\n  FocusableObserver.ɵfac = function FocusableObserver_Factory(t) {\n    return new (t || FocusableObserver)(i0.ɵɵinject(AttributeObserver));\n  };\n  FocusableObserver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FocusableObserver,\n    factory: FocusableObserver.ɵfac,\n    providedIn: 'root'\n  });\n  return FocusableObserver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedFocusableItemDirective = /*#__PURE__*/(() => {\n  class DeprecatedFocusableItemDirective extends DeprecatedSelector {}\n  DeprecatedFocusableItemDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedFocusableItemDirective_BaseFactory;\n    return function DeprecatedFocusableItemDirective_Factory(t) {\n      return (ɵDeprecatedFocusableItemDirective_BaseFactory || (ɵDeprecatedFocusableItemDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedFocusableItemDirective)))(t || DeprecatedFocusableItemDirective);\n    };\n  }();\n  DeprecatedFocusableItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedFocusableItemDirective,\n    selectors: [[\"\", \"fnFocusableItem\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkFocusableItem]', '[fnFocusableItem]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedFocusableItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusableItemDirective = /*#__PURE__*/(() => {\n  class FocusableItemDirective {\n    /** Whether the item is focusable. Default is true. */\n    set fdkFocusableItem(val) {\n      this._focusable = coerceBooleanProperty(val);\n      this.setTabbable(this._focusable);\n    }\n    get fdkFocusableItem() {\n      return this._focusable;\n    }\n    /** @hidden */\n    get _tabindex() {\n      return this._tabbable ? 0 : -1;\n    }\n    /** @hidden */\n    constructor(_elementRef, _focusableObserver, _destroy$, _tabbableElementService, _liveAnnouncer) {\n      this._elementRef = _elementRef;\n      this._focusableObserver = _focusableObserver;\n      this._destroy$ = _destroy$;\n      this._tabbableElementService = _tabbableElementService;\n      this._liveAnnouncer = _liveAnnouncer;\n      /** Function, which returns a string to be announced by screen-reader whenever an item which is in grid receives focus. */\n      this.cellFocusedEventAnnouncer = this._defaultItemFocusedEventAnnouncer;\n      /** Event emitted when the cell receives focus, not being emitted when focus moves between item's children. */\n      this.cellFocused = new EventEmitter();\n      /** @hidden */\n      this._keydown$ = new Subject();\n      /** @hidden */\n      this._focusable = true;\n      /** @hidden */\n      this._tabbableElements = new Map();\n      /** @hidden */\n      this._tabbable = true;\n      this._focusableObserver.observe(this._elementRef, false).pipe(takeUntil$1(this._destroy$)).subscribe(isFocusable => {\n        if (!isFocusable && isFocusable !== this.fdkFocusableItem) {\n          this.fdkFocusableItem = isFocusable;\n        }\n      });\n    }\n    /** Element reference. */\n    elementRef() {\n      return this._elementRef;\n    }\n    /** Set tabbable state */\n    setTabbable(state) {\n      this._tabbable = state;\n      if (state) {\n        this._enableTabbableElements();\n      } else {\n        this._disableTabbableElements();\n      }\n    }\n    /** @hidden */\n    _onFocusin() {\n      var _this = this;\n      return _asyncToGenerator(function* () {\n        if (!_this.fdkFocusableItem) {\n          return;\n        }\n        if (_this._timerId != null) {\n          clearTimeout(_this._timerId);\n          _this._timerId = null;\n          return;\n        }\n        if (_this._position) {\n          _this.cellFocused.next(_this._position);\n          if (_this.cellFocusedEventAnnouncer) {\n            _this._liveAnnouncer.clear();\n            yield _this._liveAnnouncer.announce(_this.cellFocusedEventAnnouncer(_this._position));\n          }\n        }\n      })();\n    }\n    /** @hidden */\n    _onFocusout() {\n      if (!this.fdkFocusableItem) {\n        return;\n      }\n      // Timeout is needed to prevent focusout event from being emitted when focus moves between item's children.\n      this._timerId = setTimeout(() => this._timerId = null);\n    }\n    /** @hidden */\n    _onKeydown(event) {\n      if (!this.fdkFocusableItem) {\n        return;\n      }\n      const isFocused = document.activeElement === this._elementRef.nativeElement;\n      const shouldFocusChild = KeyUtil.isKeyCode(event, [ENTER, MAC_ENTER, F2]) && !event.shiftKey && isFocused;\n      const shouldFocusCell = (KeyUtil.isKeyCode(event, F2) && event.shiftKey || KeyUtil.isKeyCode(event, ESCAPE)) && !isFocused;\n      if (shouldFocusChild) {\n        event.stopPropagation();\n        const tabbableElement = this._tabbableElementService.getTabbableElement(this.elementRef().nativeElement, false, true);\n        tabbableElement?.focus();\n        return;\n      } else if (shouldFocusCell) {\n        event.stopPropagation();\n        this._elementRef.nativeElement.focus();\n        return;\n      }\n      if (isFocused) {\n        this._keydown$.next(event);\n      }\n    }\n    /** @hidden */\n    _enableTabbableElements() {\n      if (this._tabbableElements.size === 0) {\n        return;\n      }\n      this._tabbableElements.forEach((tabIndex, element) => element.tabIndex = tabIndex);\n      this._tabbable = false;\n    }\n    /** @hidden */\n    _disableTabbableElements() {\n      // Since we cannot select by tabindex attribute (links, inputs, buttons might not have one but still can be focusable),\n      // Select all elements from the cell and filter by tabIndex property.\n      Array.from(this._elementRef.nativeElement.querySelectorAll('*')).filter(elm => elm.tabIndex >= 0).forEach(elm => {\n        this._tabbableElements.set(elm, elm.tabIndex);\n        elm.tabIndex = -1;\n      });\n    }\n    /** @hidden */\n    _defaultItemFocusedEventAnnouncer(position) {\n      return `Column ${position.colIndex + 1} of ${position.totalCols}, row: ${position.rowIndex + 1} of ${position.totalRows}`;\n    }\n  }\n  FocusableItemDirective.ɵfac = function FocusableItemDirective_Factory(t) {\n    return new (t || FocusableItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(FocusableObserver), i0.ɵɵdirectiveInject(DestroyedService), i0.ɵɵdirectiveInject(TabbableElementService), i0.ɵɵdirectiveInject(i1$1.LiveAnnouncer));\n  };\n  FocusableItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusableItemDirective,\n    selectors: [[\"\", \"fdkFocusableItem\", \"\"]],\n    hostVars: 1,\n    hostBindings: function FocusableItemDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focusin\", function FocusableItemDirective_focusin_HostBindingHandler() {\n          return ctx._onFocusin();\n        })(\"focusout\", function FocusableItemDirective_focusout_HostBindingHandler() {\n          return ctx._onFocusout();\n        })(\"keydown\", function FocusableItemDirective_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx._tabindex);\n      }\n    },\n    inputs: {\n      fdkFocusableItem: \"fdkFocusableItem\",\n      cellFocusedEventAnnouncer: \"cellFocusedEventAnnouncer\"\n    },\n    outputs: {\n      cellFocused: \"cellFocused\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FDK_FOCUSABLE_ITEM_DIRECTIVE,\n      useExisting: FocusableItemDirective\n    }, DestroyedService])]\n  });\n  return FocusableItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusableItemModule = /*#__PURE__*/(() => {\n  class FocusableItemModule {}\n  FocusableItemModule.ɵfac = function FocusableItemModule_Factory(t) {\n    return new (t || FocusableItemModule)();\n  };\n  FocusableItemModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FocusableItemModule\n  });\n  FocusableItemModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return FocusableItemModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FDK_FOCUSABLE_LIST_DIRECTIVE = new InjectionToken('Focusable list token');\n\n/**\n * Helper function check whether passed data is a JS object (including function).\n */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isJsObject(obj) {\n  return obj !== null && (typeof obj === 'function' || typeof obj === 'object');\n}\n/**\n * Helper function checks whether passed value is not empty.\n */\nfunction isPresent(obj) {\n  return obj !== undefined && obj !== null;\n}\n/**\n * Helper function check whether passed value is empty.\n */\nfunction isBlank(obj) {\n  return obj === undefined || obj === null;\n}\n/**\n * Helper function checks whether passed value is a boolean.\n */\nfunction isBoolean(obj) {\n  return typeof obj === 'boolean';\n}\n/**\n * Helper function checks whether passed value is a valid number.\n */\nfunction isNumber(obj) {\n  return typeof obj === 'number';\n}\n/**\n * Helper function checks whether passed value is a string.\n */\nfunction isString(obj) {\n  return typeof obj === 'string';\n}\n/**\n * Helper function checks whether passed value is a function\n */\nfunction isFunction(obj) {\n  return typeof obj === 'function';\n}\n/** @hidden */\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isType(obj) {\n  return isFunction(obj);\n}\n/**\n * Helper function checks whether passed value is a record of `T` values.\n */\nfunction isStringMap(obj) {\n  return typeof obj === 'object' && obj !== null;\n}\n/**\n * Helper function checks whether passed value is an `object`.\n */\nfunction isObject(item) {\n  return typeof item === 'object' && !Array.isArray(item) && item !== null;\n}\n/**\n * Helper function checks whether passed value is a promise.\n */\nfunction isPromise(obj) {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && isFunction(obj.then);\n}\n/**\n * Helper function checks whether passed value is an Observable/Subscribable.\n */\nfunction isSubscribable(obj) {\n  return !!obj && isFunction(obj.subscribe);\n}\n\n/**\n * Utility type, that allows to track and select ranges of elements while using multi-selection.\n *\n * @usage\n * Imagine we have a simple list of checkboxes:\n * ```html\n * <input\n *  #checkboxInput\n *  *ngFor=\"let o of options; let idx = index\"\n *  type=\"checkbox\"\n *  [checked]=\"selectionModel.checked(o)\"\n *  (click)=\"toggle(idx, $event)\"\n *  >\n * ```\n * With the given layout the logic should be as follows:\n * ```typescript\n * export class YourComponent {\n *  options = ['a', 'b', 'c'];\n *  readonly selectionModel = new SelectionModel(true);\n *\n *  private readonly _rangeSelector = new RangeSelector();\n *\n *\n *  toggle(idx: number, event: PointerEvent): void {\n *      // getting the toggled value of the checkbox\n *      const toggledSelection = event.target.value;\n *\n *      // registering the selection of current checkbox\n *      this._rangeSelector.onRangeElementToggled(idx, event);\n *\n *      // Apply value to each element in range.\n *      // If checkbox was toggled without shift pressed or without previously selected one,\n *      // this method will select only it.\n *      this._rangeSelector.applyValueToEachInRange(idx => {\n *          if (toggledSelection) {\n *              this.selectionModel.select(options[idx]);\n *          } else {\n *              this.selectionModel.deselect(options[idx]);\n *          }\n *      });\n *  }\n * }\n * ```\n */\nclass RangeSelector {\n  constructor() {\n    /** @hidden */\n    this._previousSelectedIndex = null;\n  }\n  /**\n   * Last registered selection state (either multiple or single).\n   * Is updated on each `onRangeElementClicked` invokation. Will be `null` initially or once `reset()` is called.\n   */\n  get lastRangeSelectionState() {\n    return this._state ? {\n      ...this._state\n    } : null;\n  }\n  /**\n   * The method that should be used to register each checkbox toggle.\n   * Accepts two arguments: `index` and `event`. If none provided, will reset existing state.\n   * Otherwise will register current index as last checked.\n   *\n   * If toggling was done with \"shift\" pressed and there's a previously registered index, will register a range selection.\n   * At the same time if checkbox was toggled without shift pressed or without previously selected one, this method will select only it.\n   *\n   * After calling this method it's recommended to use `applyValueToEachInRange` to actually toggle each checkbox in range.\n   *\n   * See usage example on this class itself.\n   */\n  onRangeElementToggled(index, event) {\n    if (this._isNonNegativeInteger(this._previousSelectedIndex) && this._isNonNegativeInteger(index) && event?.shiftKey) {\n      this._state = {\n        isRangeSelection: true,\n        from: Math.min(this._previousSelectedIndex, index),\n        to: Math.max(this._previousSelectedIndex, index)\n      };\n      this._previousSelectedIndex = index;\n    } else if (this._isNonNegativeInteger(index)) {\n      this._state = {\n        isRangeSelection: false,\n        from: index,\n        to: index\n      };\n      this._previousSelectedIndex = index;\n    } else {\n      this.reset();\n    }\n    return this.lastRangeSelectionState;\n  }\n  /**\n   * Allows to apply selection to each item in selection range.\n   * Accepts a function to apply selection to each item by registered index.\n   *\n   * See usage example on this class itself.\n   */\n  applyValueToEachInRange(selectionMethod) {\n    const state = this.lastRangeSelectionState;\n    if (!state) {\n      return;\n    }\n    if (this._isNonNegativeInteger(state?.from) && this._isNonNegativeInteger(state?.to)) {\n      for (let index = state.from; index <= state.to; index++) {\n        selectionMethod(index);\n      }\n    }\n  }\n  /** Resets selection state. Useful when the list of selectable items is changed (e.g. by filtering, sorting, page change) */\n  reset() {\n    this._state = null;\n    this._previousSelectedIndex = null;\n  }\n  /** @hidden */\n  _isNonNegativeInteger(num) {\n    return isNumber(num) && num >= 0;\n  }\n}\n\n/** Helper function to scroll to focusable list or its item relatively to the container. */\nfunction scrollIntoView(element, position) {\n  if (!position || !element) {\n    return;\n  }\n  const scrollableParent = getScrollParent(element);\n  if (scrollableParent) {\n    const itemOffsetTop = element.offsetTop - scrollableParent.offsetTop;\n    switch (position) {\n      case 'top':\n        scrollableParent.scrollTop = itemOffsetTop;\n        break;\n      case 'bottom':\n        scrollableParent.scrollTop = itemOffsetTop - (scrollableParent.offsetHeight - element.offsetHeight);\n        break;\n    }\n  }\n}\nfunction getScrollParent(node) {\n  if (node == null) {\n    return null;\n  }\n  if (node.scrollHeight > node.clientHeight && ['auto', 'scroll'].includes(getComputedStyle(node).overflowY)) {\n    return node;\n  } else {\n    return getScrollParent(node.parentNode);\n  }\n}\nlet DeprecatedFocusableListDirective = /*#__PURE__*/(() => {\n  class DeprecatedFocusableListDirective extends DeprecatedSelector {}\n  DeprecatedFocusableListDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedFocusableListDirective_BaseFactory;\n    return function DeprecatedFocusableListDirective_Factory(t) {\n      return (ɵDeprecatedFocusableListDirective_BaseFactory || (ɵDeprecatedFocusableListDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedFocusableListDirective)))(t || DeprecatedFocusableListDirective);\n    };\n  }();\n  DeprecatedFocusableListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedFocusableListDirective,\n    selectors: [[\"\", \"fnFocusableList\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkFocusableList]', '[fnFocusableList]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedFocusableListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusableListDirective = /*#__PURE__*/(() => {\n  class FocusableListDirective {\n    /** Whether the whole list should be focusable, handy in grids. */\n    set focusable(value) {\n      this._focusable = coerceBooleanProperty(value);\n      this.setTabbable(this._focusable);\n    }\n    get focusable() {\n      return this._focusable;\n    }\n    /** @hidden */\n    get _tabindex() {\n      return this._tabbable ? 0 : -1;\n    }\n    /** @hidden */\n    constructor(_renderer, _destroy$, _elementRef, _liveAnnouncer, _focusableObserver) {\n      this._renderer = _renderer;\n      this._destroy$ = _destroy$;\n      this._elementRef = _elementRef;\n      this._liveAnnouncer = _liveAnnouncer;\n      this._focusableObserver = _focusableObserver;\n      /** @hidden */\n      this._focusable = false;\n      /** Direction of navigation. Should be set to 'grid' when list is a part of grid. */\n      this.navigationDirection = 'vertical';\n      /** Direction of the content. */\n      this.contentDirection = 'ltr';\n      /**\n       * Configures wrapping mode which determines whether the active item will wrap to the other end of list when there are no more items in the given direction.\n       */\n      this.wrap = false;\n      /** Function, which returns a string to be announced by screen-reader whenever an row which is in grid receives focus. */\n      this.listFocusedEventAnnouncer = this._defaultListFocusedEventAnnouncer;\n      /** Event emitted when list's item focused, contains item's position info. */\n      this.itemFocused = new EventEmitter();\n      /** @hidden */\n      this._gridItemFocused$ = new Subject();\n      /** @hidden */\n      this._gridListFocused$ = new Subject();\n      /** @hidden */\n      this._keydown$ = new Subject();\n      /** @hidden */\n      this._tabbable = false;\n      /** @hidden */\n      this._refreshItems$ = new Subject();\n      /** @hidden */\n      this._isVisible = false;\n      intersectionObservable(this._elementRef.nativeElement, {\n        threshold: 0.25\n      }).pipe(takeUntil(this._destroy$)).subscribe(isVisible => this._isVisible = isVisible[0]?.isIntersecting);\n      this._focusableObserver.observe(this._elementRef, false).pipe(takeUntil(this._destroy$)).subscribe(isFocusable => {\n        if (!isFocusable && isFocusable !== this.focusable) {\n          this.focusable = isFocusable;\n        }\n      });\n    }\n    /** @hidden */\n    ngOnChanges(changes) {\n      if (!this._keyManager) {\n        return;\n      }\n      if (changes['wrap']) {\n        this._keyManager = this._keyManager.withWrap(changes['wrap'].currentValue);\n      }\n      if (changes['navigationDirection']) {\n        this._updateNavigationDirection();\n      }\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._focusableItems.changes.pipe(startWith(this._focusableItems), map(queryList => queryList.toArray()), tap(items => {\n        const focusableItems = items.map((item, index) => ({\n          index,\n          focusable: () => item.fdkFocusableItem,\n          elementRef: () => item.elementRef(),\n          focus: () => item.elementRef().nativeElement.focus(),\n          keydown: item._keydown$\n        }));\n        const direction = this.navigationDirection === 'grid' ? 'horizontal' : this.navigationDirection;\n        this._initializeFocusManager(focusableItems, this, {\n          direction,\n          contentDirection: this.contentDirection,\n          wrap: this.wrap\n        });\n      }), takeUntil(this._destroy$)).subscribe();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._keyManager?.destroy();\n    }\n    /** @hidden */\n    _onKeydown(event) {\n      // Already handled\n      if (event.defaultPrevented) {\n        return;\n      }\n      const isFocused = document.activeElement === this._elementRef.nativeElement;\n      const shouldFocusChild = KeyUtil.isKeyCode(event, [ENTER, MAC_ENTER, F2]) && !event.shiftKey && isFocused;\n      const shouldFocusList = (KeyUtil.isKeyCode(event, F2) && event.shiftKey || KeyUtil.isKeyCode(event, ESCAPE)) && !isFocused;\n      if (shouldFocusChild) {\n        event.stopPropagation();\n        this.setActiveItem(0);\n        return;\n      } else if (shouldFocusList) {\n        event.stopPropagation();\n        this.focus();\n        return;\n      }\n      this._keydown$.next({\n        list: this,\n        event,\n        activeItemIndex: this._keyManager?.activeItemIndex ?? null\n      });\n    }\n    /** Set active item in list */\n    setActiveItem(index, scrollPosition) {\n      let availableIndex;\n      this._focusableItems.find((item, itemIndex) => {\n        if (itemIndex >= index && item.fdkFocusableItem) {\n          availableIndex = itemIndex;\n          return true;\n        }\n        return false;\n      });\n      if (availableIndex != null) {\n        scrollIntoView(this._focusableItems.get(availableIndex)?.elementRef().nativeElement, scrollPosition);\n        this._keyManager?.setActiveItem(availableIndex);\n      }\n    }\n    /** Focus whole list */\n    focus(scrollPosition) {\n      if (this.focusable) {\n        scrollIntoView(this._elementRef.nativeElement, scrollPosition);\n        this._elementRef.nativeElement.focus();\n      }\n    }\n    /** Set tabbable state */\n    setTabbable(state) {\n      this._tabbable = state;\n    }\n    /** @hidden */\n    _onFocus() {\n      var _this2 = this;\n      return _asyncToGenerator(function* () {\n        if (_this2._gridPosition) {\n          _this2._gridListFocused$.next(_this2._gridPosition);\n          _this2._liveAnnouncer.clear();\n          yield _this2._liveAnnouncer.announce(_this2.listFocusedEventAnnouncer(_this2._gridPosition));\n          _this2.setTabbable(true);\n        }\n      })();\n    }\n    /** @hidden */\n    _updateNavigationDirection() {\n      if (!this._keyManager) {\n        return;\n      }\n      if (this.navigationDirection === 'vertical') {\n        this._keyManager = this._keyManager.withVerticalOrientation(true);\n        this._keyManager = this._keyManager.withHorizontalOrientation(null);\n      } else {\n        this._keyManager = this._keyManager.withVerticalOrientation(false);\n        this._keyManager = this._keyManager.withHorizontalOrientation(this.contentDirection || 'ltr');\n      }\n    }\n    /** @hidden */\n    _setItemsTabbable(state) {\n      this._focusableItems.forEach(item => item.setTabbable(state));\n    }\n    /** @hidden */\n    _setGridPosition(position) {\n      this._gridPosition = position;\n      this._focusableItems.changes.pipe(startWith(this._focusableItems), takeUntil(this._destroy$)).subscribe(items => items.forEach((item, index) => item._position = {\n        ...this._gridPosition,\n        colIndex: index,\n        totalCols: this._focusableItems.length\n      }));\n    }\n    /** @hidden */\n    _initializeFocusManager(items, list, config = {}) {\n      this._refreshItems$.next();\n      let keyManager = new FocusKeyManager(items).withHomeAndEnd();\n      if (config.wrap !== false) {\n        keyManager = keyManager.withWrap();\n      }\n      if (config.direction === 'horizontal') {\n        keyManager = keyManager.withHorizontalOrientation(config.contentDirection || 'ltr'); // should be replaced\n        // Vertical is enabled by default, so let's disable it here in consistency purposes\n        keyManager = keyManager.withVerticalOrientation(false);\n      }\n      keyManager.skipPredicate(item => !(typeof item.focusable === 'boolean' ? item.focusable : item.focusable()));\n      this._keyManager = keyManager;\n      const focusListenerDestroyers = items.map((item, index) => this._renderer.listen(getNativeElement(item), 'focus', () => {\n        const directiveItem = this._focusableItems.get(index);\n        if (!directiveItem) {\n          return;\n        }\n        if (this._gridPosition) {\n          this._gridItemFocused$.next(directiveItem._position);\n        }\n        this.itemFocused.next({\n          index: item.index,\n          total: items.length\n        });\n        this._focusableItems.forEach(i => i.setTabbable(i === directiveItem));\n        this._keyManager?.setActiveItem(item.index);\n      }));\n      merge(...items.map(item => item.keydown)).pipe(tap(event => {\n        // Already handled\n        if (event.defaultPrevented) {\n          return;\n        }\n        this._keyManager?.onKeydown(event);\n      }), takeUntil(merge(this._refreshItems$, this._destroy$)), finalize(() => focusListenerDestroyers.forEach(d => d()))).subscribe();\n    }\n    /** @hidden */\n    _defaultListFocusedEventAnnouncer(position) {\n      return `Row: ${position.rowIndex + 1} of ${position.totalRows}, use F2 button to dive in and focus list's item`;\n    }\n  }\n  FocusableListDirective.ɵfac = function FocusableListDirective_Factory(t) {\n    return new (t || FocusableListDirective)(i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(DestroyedService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$1.LiveAnnouncer), i0.ɵɵdirectiveInject(FocusableObserver));\n  };\n  FocusableListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusableListDirective,\n    selectors: [[\"\", \"fdkFocusableList\", \"\"]],\n    contentQueries: function FocusableListDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FDK_FOCUSABLE_ITEM_DIRECTIVE, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._focusableItems = _t);\n      }\n    },\n    hostVars: 1,\n    hostBindings: function FocusableListDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function FocusableListDirective_keydown_HostBindingHandler($event) {\n          return ctx._onKeydown($event);\n        })(\"focus\", function FocusableListDirective_focus_HostBindingHandler() {\n          return ctx._onFocus();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"tabindex\", ctx._tabindex);\n      }\n    },\n    inputs: {\n      focusable: \"focusable\",\n      navigationDirection: \"navigationDirection\",\n      contentDirection: \"contentDirection\",\n      wrap: \"wrap\",\n      listFocusedEventAnnouncer: \"listFocusedEventAnnouncer\"\n    },\n    outputs: {\n      itemFocused: \"itemFocused\"\n    },\n    exportAs: [\"fdkFocusableList\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FDK_FOCUSABLE_LIST_DIRECTIVE,\n      useExisting: FocusableListDirective\n    }, DestroyedService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return FocusableListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusableListModule = /*#__PURE__*/(() => {\n  class FocusableListModule {}\n  FocusableListModule.ɵfac = function FocusableListModule_Factory(t) {\n    return new (t || FocusableListModule)();\n  };\n  FocusableListModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FocusableListModule\n  });\n  FocusableListModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [FocusableItemModule, FocusableItemModule]\n  });\n  return FocusableListModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FDK_FOCUSABLE_GRID_DIRECTIVE = new InjectionToken('Focusable grid directive token');\nlet FocusableGridDirective = /*#__PURE__*/(() => {\n  class FocusableGridDirective {\n    /** Whether the item in the previous/next row should be selected when going out of the first/last cell in the row. Default is false. */\n    set wrapHorizontally(value) {\n      this._wrapHorizontally = coerceBooleanProperty(value);\n    }\n    get wrapHorizontally() {\n      return this._wrapHorizontally;\n    }\n    /** @hidden */\n    constructor(_destroy$) {\n      this._destroy$ = _destroy$;\n      /** Direction of the content. */\n      this.contentDirection = 'ltr';\n      /** Specify which item to select in prev/next row if its length smaller than current index. Nullish value means do not select. Default is null. */\n      this.shortRowFocus = null;\n      /** Event emitted when item focused, contains item's position info. */\n      this.itemFocused = new EventEmitter();\n      /** Event emitted when whole row focused, contains row's position info. */\n      this.rowFocused = new EventEmitter();\n      /** @hidden */\n      this._wrapHorizontally = false;\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._focusableLists.changes.pipe(startWith$1(this._focusableLists), takeUntil$1(this._destroy$)).subscribe(lists => lists.forEach((list, index) => list._setGridPosition({\n        rowIndex: index,\n        totalRows: this._focusableLists.length\n      })));\n      this._focusableLists.changes.pipe(startWith$1(this._focusableLists), switchMap(queryList => merge(...queryList.toArray().map(list => list._gridListFocused$))), takeUntil$1(this._destroy$)).subscribe(focusedEvent => {\n        this.rowFocused.emit(focusedEvent);\n        this._focusableLists.forEach(list => list.setTabbable(false));\n        this._focusableLists.forEach(list => list._setItemsTabbable(false));\n      });\n      this._focusableLists.changes.pipe(startWith$1(this._focusableLists), switchMap(queryList => merge(...queryList.toArray().map(list => list._gridItemFocused$))), takeUntil$1(this._destroy$)).subscribe(focusedEvent => {\n        this.itemFocused.emit(focusedEvent);\n        this._focusableLists.forEach(list => list.setTabbable(false));\n        this._focusableLists.forEach(list => list._setItemsTabbable(false));\n      });\n      this._focusableLists.changes.pipe(startWith$1(this._focusableLists), switchMap(queryList => merge(...queryList.toArray().map(list => list._keydown$))), takeUntil$1(this._destroy$)).subscribe(({\n        event,\n        list,\n        activeItemIndex\n      }) => this._onKeydown(event, list, activeItemIndex));\n    }\n    /**\n     * Focus cell by position.\n     * @param position position of the cell\n     */\n    focusCell(position) {\n      const list = this._focusableLists.get(position.rowIndex);\n      if (list) {\n        list.setActiveItem(position.colIndex);\n      }\n    }\n    /** @hidden */\n    _onKeydown(event, list, activeItemIndex) {\n      if (!KeyUtil.isKeyCode(event, [UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW, PAGE_DOWN, PAGE_UP])) {\n        return;\n      }\n      const lists = this._focusableLists.toArray();\n      const currentRowIndex = lists.findIndex(item => item === list);\n      let nextRowIndex;\n      let nextRowItemIndex = activeItemIndex ?? 0;\n      let scrollIntoView;\n      const isFirstItemLtr = activeItemIndex === 0 && this.contentDirection !== 'rtl';\n      const isLastItemRtl = activeItemIndex === list._focusableItems.length - 1 && this.contentDirection === 'rtl';\n      const isFirstItemRtl = activeItemIndex === 0 && this.contentDirection === 'rtl';\n      const isLastItemLtr = activeItemIndex === list._focusableItems.length - 1 && this.contentDirection !== 'rtl';\n      switch (event.keyCode) {\n        case UP_ARROW:\n          event.preventDefault();\n          nextRowIndex = currentRowIndex - 1;\n          break;\n        case DOWN_ARROW:\n          event.preventDefault();\n          nextRowIndex = currentRowIndex + 1;\n          break;\n        case LEFT_ARROW:\n          if (this.wrapHorizontally && (isFirstItemLtr || isLastItemRtl)) {\n            event.preventDefault();\n            nextRowIndex = currentRowIndex - 1;\n            nextRowItemIndex = lists[nextRowIndex]?._focusableItems.length - 1;\n          }\n          break;\n        case RIGHT_ARROW:\n          if (this.wrapHorizontally && (isFirstItemRtl || isLastItemLtr)) {\n            event.preventDefault();\n            nextRowIndex = currentRowIndex + 1;\n            nextRowItemIndex = 0;\n          }\n          break;\n        case PAGE_DOWN:\n          event.preventDefault();\n          nextRowIndex = findLastIndex(lists, item => item._isVisible);\n          scrollIntoView = 'top';\n          break;\n        case PAGE_UP:\n          event.preventDefault();\n          nextRowIndex = lists.findIndex(item => item._isVisible);\n          scrollIntoView = 'bottom';\n          break;\n      }\n      const nextRow = lists[nextRowIndex ?? -1];\n      if (nextRow) {\n        if (nextRow.focusable) {\n          nextRow.focus(scrollIntoView);\n          return;\n        }\n        const itemIndex = this._getItemIndex(nextRow, nextRowItemIndex);\n        if (itemIndex != null) {\n          nextRow.setActiveItem(itemIndex, scrollIntoView);\n        }\n      }\n    }\n    /** @hidden */\n    _getItemIndex(list, activeIndex) {\n      if (activeIndex >= 0 && activeIndex < list._focusableItems.length) {\n        return activeIndex;\n      }\n      if (this.shortRowFocus == null) {\n        return null;\n      }\n      return this.shortRowFocus === 'first' ? 0 : list._focusableItems.length - 1;\n    }\n  }\n  FocusableGridDirective.ɵfac = function FocusableGridDirective_Factory(t) {\n    return new (t || FocusableGridDirective)(i0.ɵɵdirectiveInject(DestroyedService));\n  };\n  FocusableGridDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: FocusableGridDirective,\n    selectors: [[\"\", \"fdkFocusableGrid\", \"\"]],\n    contentQueries: function FocusableGridDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FDK_FOCUSABLE_LIST_DIRECTIVE, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._focusableLists = _t);\n      }\n    },\n    inputs: {\n      contentDirection: \"contentDirection\",\n      wrapHorizontally: \"wrapHorizontally\",\n      shortRowFocus: \"shortRowFocus\"\n    },\n    outputs: {\n      itemFocused: \"itemFocused\",\n      rowFocused: \"rowFocused\"\n    },\n    exportAs: [\"fdkFocusableGrid\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FDK_FOCUSABLE_GRID_DIRECTIVE,\n      useExisting: FocusableGridDirective\n    }, DestroyedService])]\n  });\n  return FocusableGridDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FocusableGridModule = /*#__PURE__*/(() => {\n  class FocusableGridModule {}\n  FocusableGridModule.ɵfac = function FocusableGridModule_Factory(t) {\n    return new (t || FocusableGridModule)();\n  };\n  FocusableGridModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FocusableGridModule\n  });\n  FocusableGridModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [FocusableListModule, FocusableListModule]\n  });\n  return FocusableGridModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FDK_READONLY_DIRECTIVE = new InjectionToken('Readonly directive token');\n\n/** @Hidden */\nfunction setReadonlyState(element, isReadonly) {\n  const htmlElement = getNativeElement(element);\n  if (isReadonly) {\n    htmlElement.classList.add('is-readonly');\n    htmlElement.setAttribute('readonly', '');\n  } else {\n    htmlElement.classList.remove('is-readonly');\n    htmlElement.removeAttribute('readonly');\n  }\n}\nlet DeprecatedReadonlyBehaviorDirective = /*#__PURE__*/(() => {\n  class DeprecatedReadonlyBehaviorDirective extends DeprecatedSelector {}\n  DeprecatedReadonlyBehaviorDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedReadonlyBehaviorDirective_BaseFactory;\n    return function DeprecatedReadonlyBehaviorDirective_Factory(t) {\n      return (ɵDeprecatedReadonlyBehaviorDirective_BaseFactory || (ɵDeprecatedReadonlyBehaviorDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedReadonlyBehaviorDirective)))(t || DeprecatedReadonlyBehaviorDirective);\n    };\n  }();\n  DeprecatedReadonlyBehaviorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedReadonlyBehaviorDirective,\n    selectors: [[\"\", \"fnReadonly\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkReadonly]', '[fnReadonly]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedReadonlyBehaviorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ReadonlyBehaviorDirective = /*#__PURE__*/(() => {\n  class ReadonlyBehaviorDirective extends ReplaySubject {\n    /** @Hidden */\n    set fdkReadonly(value) {\n      this._readonlyInput$.next(coerceBooleanProperty(value));\n    }\n    get fdkReadonly() {\n      return this._readonly;\n    }\n    /** @hidden */\n    constructor(_elementRef, _destroy$) {\n      super(1);\n      this._elementRef = _elementRef;\n      this._destroy$ = _destroy$;\n      /** @Hidden */\n      this._readonly = false;\n      /** @hidden */\n      this._readonlyInput$ = new BehaviorSubject(false);\n      /** @Hidden */\n      this.setReadonlyState = isReadonly => {\n        setReadonlyState(this._elementRef, isReadonly);\n      };\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._readonlyInput$.pipe(tap(isReadonly => {\n        if (isReadonly !== this._readonly) {\n          this.setReadonlyState(isReadonly);\n          this._readonly = isReadonly;\n          this.next(isReadonly);\n        }\n      }), takeUntil(this._destroy$)).subscribe();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.complete();\n    }\n  }\n  ReadonlyBehaviorDirective.ɵfac = function ReadonlyBehaviorDirective_Factory(t) {\n    return new (t || ReadonlyBehaviorDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DestroyedService));\n  };\n  ReadonlyBehaviorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ReadonlyBehaviorDirective,\n    selectors: [[\"\", \"fdkReadonly\", \"\"], [\"\", \"fnReadonly\", \"\"]],\n    inputs: {\n      fdkReadonly: \"fdkReadonly\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FDK_READONLY_DIRECTIVE,\n      useExisting: ReadonlyBehaviorDirective\n    }, DestroyedService]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return ReadonlyBehaviorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ReadonlyBehaviorModule = /*#__PURE__*/(() => {\n  class ReadonlyBehaviorModule {}\n  ReadonlyBehaviorModule.ɵfac = function ReadonlyBehaviorModule_Factory(t) {\n    return new (t || ReadonlyBehaviorModule)();\n  };\n  ReadonlyBehaviorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ReadonlyBehaviorModule\n  });\n  ReadonlyBehaviorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ReadonlyBehaviorModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ReadonlyObserver = /*#__PURE__*/(() => {\n  class ReadonlyObserver {\n    /** @Hidden */\n    constructor(_attributeObserver) {\n      this._attributeObserver = _attributeObserver;\n    }\n    /** @Hidden */\n    static isReadonly(element) {\n      return element.classList.contains('is-readonly') || element.hasAttribute('readonly');\n    }\n    /** @hidden */\n    observe(element) {\n      return this._attributeObserver.observe(element).pipe(map(() => ReadonlyObserver.isReadonly(getNativeElement(element))), distinctUntilChanged());\n    }\n    /** @Hidden */\n    unobserve(element) {\n      this._attributeObserver.unobserve(element);\n    }\n  }\n  ReadonlyObserver.ɵfac = function ReadonlyObserver_Factory(t) {\n    return new (t || ReadonlyObserver)(i0.ɵɵinject(AttributeObserver));\n  };\n  ReadonlyObserver.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ReadonlyObserver,\n    factory: ReadonlyObserver.ɵfac,\n    providedIn: 'root'\n  });\n  return ReadonlyObserver;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass DefaultReadonlyViewModifier {\n  /** @hidden */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    /** @hidden */\n    this.setReadonlyState = isDisabled => {\n      setReadonlyState(this.elementRef, isDisabled);\n    };\n  }\n}\nlet FdkReadonlyProvider = /*#__PURE__*/(() => {\n  class FdkReadonlyProvider extends ReplaySubject {\n    /** @hidden */\n    constructor(ngZone, elementRef, readonlyObserver, selfReadonly$, parentReadonly$) {\n      super(1);\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      this.readonlyObserver = readonlyObserver;\n      this.selfReadonly$ = selfReadonly$;\n      this.parentReadonly$ = parentReadonly$;\n      /** @Hidden */\n      this.fdkReadonly = false;\n      /** @hidden */\n      this._viewModifiers$ = new BehaviorSubject(this._getInitialViewModifiers());\n      /** @hidden */\n      this._readonlyChange$ = this._getReadonlyChange$();\n      /** @hidden */\n      this._destroy$ = new Subject();\n      combineLatest([this._readonlyChange$, this._viewModifiers$]).pipe(tap(([isReadonly]) => this.setReadonlyState(isReadonly)), takeUntil(this._destroy$)).subscribe();\n      this._readonlyChange$.pipe(tap(isDisabled => this.fdkReadonly = isDisabled), tap(isDisabled => this.next(isDisabled)), takeUntil(this._destroy$)).subscribe();\n    }\n    /** @hidden */\n    addViewModifier(modifier) {\n      const viewModifiers = [...new Set([...this._viewModifiers$.value, modifier]).values()];\n      this._viewModifiers$.next(viewModifiers);\n    }\n    /** @hidden */\n    setReadonlyState(isReadonly) {\n      firstValueFrom(this.ngZone.onStable).then(() => {\n        this._viewModifiers$.value.forEach(viewModifier => viewModifier.setReadonlyState(isReadonly));\n      });\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.complete();\n      this._destroy$.next();\n      this._destroy$.complete();\n      this.readonlyObserver.unobserve(this.elementRef);\n    }\n    /** @hidden */\n    _getReadonlyChange$() {\n      let selfReadonly = false;\n      let parentReadonly = false;\n      if (this.parentReadonly$) {\n        this.parentReadonly$.pipe(startWith(this.parentReadonly$.fdkReadonly), tap(d => parentReadonly = d), distinctUntilChanged(), tap(() => {\n          if (parentReadonly) {\n            this.setReadonlyState(true);\n          }\n          if (!selfReadonly && !parentReadonly) {\n            this.setReadonlyState(false);\n          }\n        }), takeUntil(this._destroy$)).subscribe();\n      }\n      if (this.selfReadonly$) {\n        this.selfReadonly$.pipe(startWith(this.selfReadonly$.fdkReadonly), tap(d => selfReadonly = d), distinctUntilChanged(), tap(isReadonly => {\n          if (!parentReadonly) {\n            this.setReadonlyState(isReadonly);\n          }\n        }), takeUntil(this._destroy$)).subscribe();\n      }\n      return this.readonlyObserver.observe(this.elementRef).pipe(distinctUntilChanged());\n    }\n    /** @hidden */\n    _getInitialViewModifiers() {\n      return !this.selfReadonly$ ? [new DefaultReadonlyViewModifier(this.elementRef)] : [this.selfReadonly$];\n    }\n  }\n  FdkReadonlyProvider.ɵfac = function FdkReadonlyProvider_Factory(t) {\n    return new (t || FdkReadonlyProvider)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.ElementRef), i0.ɵɵinject(ReadonlyObserver), i0.ɵɵinject(FDK_READONLY_DIRECTIVE, 10), i0.ɵɵinject(FDK_READONLY_DIRECTIVE, 12));\n  };\n  FdkReadonlyProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FdkReadonlyProvider,\n    factory: FdkReadonlyProvider.ɵfac\n  });\n  return FdkReadonlyProvider;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** @hidden */\nfunction setDisabledState(element, isDisabled, disabledClass, addDisabledClass) {\n  const htmlElement = getNativeElement(element);\n  if (isDisabled) {\n    if (addDisabledClass) {\n      htmlElement.classList.add(disabledClass);\n    }\n    htmlElement.setAttribute('disabled', '');\n    htmlElement.setAttribute('aria-disabled', 'true');\n  } else {\n    htmlElement.classList.remove(disabledClass);\n    htmlElement.removeAttribute('disabled');\n    htmlElement.removeAttribute('aria-disabled');\n  }\n}\nconst FDK_DISABLED_DIRECTIVE = new InjectionToken('Disabled directive token');\nlet DeprecatedClickedDirective = /*#__PURE__*/(() => {\n  class DeprecatedClickedDirective extends DeprecatedSelector {}\n  DeprecatedClickedDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedClickedDirective_BaseFactory;\n    return function DeprecatedClickedDirective_Factory(t) {\n      return (ɵDeprecatedClickedDirective_BaseFactory || (ɵDeprecatedClickedDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedClickedDirective)))(t || DeprecatedClickedDirective);\n    };\n  }();\n  DeprecatedClickedDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedClickedDirective,\n    selectors: [[\"\", \"fnClicked\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkClicked]', '[fnClicked]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedClickedDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClickedDirective = /*#__PURE__*/(() => {\n  class ClickedDirective {\n    constructor() {\n      /**\n       * FdkClicked output. Sole purpose of existence of this directive is to just silence Angular Language Service.\n       * This is only viable solution, since NO_ERRORS_SCHEMA silences everything and valuable exception might slip\n       * through your eyes.\n       */\n      this.fdkClicked = new EventEmitter();\n    }\n  }\n  /**\n   * Event name.\n   */\n  ClickedDirective.eventName = 'fdkClicked';\n  ClickedDirective.ɵfac = function ClickedDirective_Factory(t) {\n    return new (t || ClickedDirective)();\n  };\n  ClickedDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: ClickedDirective,\n    selectors: [[\"\", \"fdkClicked\", \"\"]],\n    outputs: {\n      fdkClicked: \"fdkClicked\"\n    }\n  });\n  return ClickedDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ClickedEventPlugin = /*#__PURE__*/(() => {\n  class ClickedEventPlugin {\n    /** @hidden */\n    constructor(document, platformId) {\n      this.document = document;\n      this.platformId = platformId;\n    }\n    /** @hidden */\n    addEventListener(element, eventName, handler) {\n      return this._setupEventBinding(element, handler);\n    }\n    /** @hidden */\n    addGlobalEventListener(higherOrderElement, eventName, handler) {\n      const target = this._parseHigherOrderElement(higherOrderElement);\n      return this._setupEventBinding(target, handler);\n    }\n    /** @hidden */\n    supports(eventName) {\n      return eventName === ClickedDirective.eventName;\n    }\n    /** @hidden */\n    _parseHigherOrderElement(selector) {\n      if (this.platformId !== 'browser') {\n        return this.document;\n      }\n      switch (selector) {\n        case 'window':\n          return window;\n        case 'document':\n          return document;\n        case 'body':\n          return document.body;\n        default:\n          throw new Error(`Element selector [${selector}] not supported.`);\n      }\n    }\n    /** @hidden */\n    _setupEventBinding(target, handler) {\n      const addProxyFunction = () => {\n        target.addEventListener('click', proxyFunction, false);\n        target.addEventListener('keydown', proxyFunction, false);\n      };\n      const removeProxyFunction = () => {\n        target.removeEventListener('click', proxyFunction, false);\n        target.removeEventListener('keydown', proxyFunction, false);\n      };\n      const proxyFunction = event => {\n        if (event instanceof KeyboardEvent) {\n          if (event.keyCode !== ENTER && event.keyCode !== SPACE) {\n            return;\n          }\n        }\n        handler(event);\n      };\n      addProxyFunction();\n      return removeProxyFunction;\n    }\n  }\n  ClickedEventPlugin.ɵfac = function ClickedEventPlugin_Factory(t) {\n    return new (t || ClickedEventPlugin)(i0.ɵɵinject(DOCUMENT), i0.ɵɵinject(PLATFORM_ID));\n  };\n  ClickedEventPlugin.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: ClickedEventPlugin,\n    factory: ClickedEventPlugin.ɵfac\n  });\n  return ClickedEventPlugin;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst ClickedBehaviorModuleForRootLoadedOnce = new InjectionToken('Checking Module providers had been loaded', {\n  factory: () => false\n});\nlet ClickedBehaviorModule = /*#__PURE__*/(() => {\n  class ClickedBehaviorModule {\n    /** @hidden */\n    constructor(clickedBehaviorModuleForRootLoadedOnce) {\n      if (!clickedBehaviorModuleForRootLoadedOnce && isDevMode()) {\n        console.warn('ClickedBehaviorModule.forRoot() was not called from RootModule, you will not be able to use (fdkClicked) events');\n      }\n    }\n    /** @hidden */\n    static forRoot() {\n      return {\n        ngModule: ClickedBehaviorModule,\n        providers: [{\n          provide: EVENT_MANAGER_PLUGINS,\n          useClass: ClickedEventPlugin,\n          multi: true\n        }, {\n          provide: ClickedBehaviorModuleForRootLoadedOnce,\n          useValue: true\n        }]\n      };\n    }\n  }\n  ClickedBehaviorModule.ɵfac = function ClickedBehaviorModule_Factory(t) {\n    return new (t || ClickedBehaviorModule)(i0.ɵɵinject(ClickedBehaviorModuleForRootLoadedOnce));\n  };\n  ClickedBehaviorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: ClickedBehaviorModule\n  });\n  ClickedBehaviorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return ClickedBehaviorModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FdkClickedProvider = /*#__PURE__*/(() => {\n  class FdkClickedProvider extends Subject {\n    /** @hidden */\n    constructor(_elementRef, _renderer, eventManagerPlugins) {\n      super();\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this.eventManagerPlugins = eventManagerPlugins;\n      /** @hidden */\n      this._preventDefault = true;\n      this._fdkClickedEventManagerPluginLoaded = eventManagerPlugins.some(em => em instanceof ClickedEventPlugin);\n      this._initialize();\n    }\n    /** @hidden */\n    setPreventDefault(val) {\n      this._preventDefault = val;\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._listeners.forEach(d => d());\n      this.complete();\n    }\n    /** @hidden */\n    _initialize() {\n      const eventsList = this._fdkClickedEventManagerPluginLoaded ? [ClickedDirective.eventName] : ['click', 'keydown.enter', 'keydown.space'];\n      this._listeners = eventsList.map(eventName => this._renderer.listen(this._elementRef.nativeElement, eventName, event => {\n        if (this._preventDefault) {\n          event.preventDefault();\n        }\n        this.next(event);\n      }));\n    }\n  }\n  FdkClickedProvider.ɵfac = function FdkClickedProvider_Factory(t) {\n    return new (t || FdkClickedProvider)(i0.ɵɵinject(i0.ElementRef), i0.ɵɵinject(i0.Renderer2), i0.ɵɵinject(EVENT_MANAGER_PLUGINS));\n  };\n  FdkClickedProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FdkClickedProvider,\n    factory: FdkClickedProvider.ɵfac\n  });\n  return FdkClickedProvider;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedDisabledBehaviorDirective = /*#__PURE__*/(() => {\n  class DeprecatedDisabledBehaviorDirective extends DeprecatedSelector {}\n  DeprecatedDisabledBehaviorDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵDeprecatedDisabledBehaviorDirective_BaseFactory;\n    return function DeprecatedDisabledBehaviorDirective_Factory(t) {\n      return (ɵDeprecatedDisabledBehaviorDirective_BaseFactory || (ɵDeprecatedDisabledBehaviorDirective_BaseFactory = i0.ɵɵgetInheritedFactory(DeprecatedDisabledBehaviorDirective)))(t || DeprecatedDisabledBehaviorDirective);\n    };\n  }();\n  DeprecatedDisabledBehaviorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedDisabledBehaviorDirective,\n    selectors: [[\"\", \"fnDisabled\", \"\"]],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FD_DEPRECATED_DIRECTIVE_SELECTOR,\n      useValue: getDeprecatedModel('[fdkDisabled]', '[fnDisabled]')\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedDisabledBehaviorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DisabledBehaviorDirective = /*#__PURE__*/(() => {\n  class DisabledBehaviorDirective extends ReplaySubject {\n    /** @hidden */\n    set fdkDisabled(value) {\n      const val = coerceBooleanProperty(value);\n      this._clicked.setPreventDefault(val);\n      this._fdkDisableInput$.next(val);\n    }\n    get fdkDisabled() {\n      return this._disabled;\n    }\n    /** @hidden */\n    constructor(_elementRef, _destroy$, _clicked) {\n      super(1);\n      this._elementRef = _elementRef;\n      this._destroy$ = _destroy$;\n      this._clicked = _clicked;\n      /**\n       * Whether to add `disabledClass` class to the element.\n       */\n      this.addDisabledClass = true;\n      /**\n       * Disabled css class to apply to the element.\n       */\n      this.disabledClass = 'is-disabled';\n      /** @hidden */\n      this._disabled = false;\n      /** @hidden */\n      this._fdkDisableInput$ = new BehaviorSubject(false);\n      /** @hidden */\n      this.setDisabledState = isDisabled => {\n        setDisabledState(this._elementRef, isDisabled, this.disabledClass, this.addDisabledClass);\n      };\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._fdkDisableInput$.pipe(filter$1(isDisabled => isDisabled !== this._disabled), tap(isDisabled => {\n        this.setDisabledState(isDisabled);\n        this._disabled = isDisabled;\n        this.next(isDisabled);\n      }), takeUntil(this._destroy$)).subscribe();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.complete();\n    }\n  }\n  DisabledBehaviorDirective.ɵfac = function DisabledBehaviorDirective_Factory(t) {\n    return new (t || DisabledBehaviorDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DestroyedService), i0.ɵɵdirectiveInject(FdkClickedProvider));\n  };\n  DisabledBehaviorDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DisabledBehaviorDirective,\n    selectors: [[\"\", \"fdkDisabled\", \"\"]],\n    inputs: {\n      fdkDisabled: \"fdkDisabled\",\n      addDisabledClass: \"addDisabledClass\",\n      disabledClass: \"disabledClass\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: FDK_DISABLED_DIRECTIVE,\n      useExisting: DisabledBehaviorDirective\n    }, DestroyedService, FdkClickedProvider]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DisabledBehaviorDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DisabledBehaviorModule = /*#__PURE__*/(() => {\n  class DisabledBehaviorModule {}\n  DisabledBehaviorModule.ɵfac = function DisabledBehaviorModule_Factory(t) {\n    return new (t || DisabledBehaviorModule)();\n  };\n  DisabledBehaviorModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DisabledBehaviorModule\n  });\n  DisabledBehaviorModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return DisabledBehaviorModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass DefaultDisabledViewModifier {\n  /** @hidden */\n  constructor(elementRef) {\n    this.elementRef = elementRef;\n    /** @hidden */\n    this.setDisabledState = isDisabled => {\n      setDisabledState(this.elementRef, isDisabled, 'is-disabled', true);\n    };\n  }\n}\nlet FdkDisabledProvider = /*#__PURE__*/(() => {\n  class FdkDisabledProvider extends ReplaySubject {\n    /** @hidden */\n    constructor(ngZone, elementRef, disabledObserver, selfDisabled$, parentDisabled$) {\n      super(1);\n      this.ngZone = ngZone;\n      this.elementRef = elementRef;\n      this.disabledObserver = disabledObserver;\n      this.selfDisabled$ = selfDisabled$;\n      this.parentDisabled$ = parentDisabled$;\n      /** @Hidden */\n      this.fdkDisabled = false;\n      /** @Hidden */\n      this._destroy$ = new Subject();\n      /** @hidden */\n      this._viewModifiers$ = new BehaviorSubject(this._getInitialViewModifiers());\n      /** @hidden */\n      this._disabledChange$ = this._getDisabledChange$();\n      combineLatest([this._disabledChange$, this._viewModifiers$]).pipe(tap(([isDisabled]) => this.setDisabledState(isDisabled)), takeUntil(this._destroy$)).subscribe();\n      this._disabledChange$.pipe(tap(isDisabled => this.fdkDisabled = isDisabled), tap(isDisabled => this.next(isDisabled)), takeUntil(this._destroy$)).subscribe();\n    }\n    /** @hidden */\n    addViewModifier(modifier) {\n      const viewModifiers = [...new Set([...this._viewModifiers$.value, modifier]).values()];\n      this._viewModifiers$.next(viewModifiers);\n    }\n    /** @hidden */\n    setDisabledState(isDisabled) {\n      firstValueFrom(this.ngZone.onStable).then(() => {\n        this._viewModifiers$.value.forEach(viewModifier => viewModifier.setDisabledState(isDisabled));\n      });\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.complete();\n      this._destroy$.next();\n      this.disabledObserver.unobserve(this.elementRef);\n    }\n    /** @hidden */\n    _getDisabledChange$() {\n      let selfDisabled = false;\n      let parentDisabled = false;\n      if (this.parentDisabled$) {\n        this.parentDisabled$.pipe(startWith(this.parentDisabled$.fdkDisabled), tap(d => parentDisabled = d), distinctUntilChanged(), tap(() => {\n          if (parentDisabled) {\n            this.setDisabledState(true);\n          }\n          if (!selfDisabled && !parentDisabled) {\n            this.setDisabledState(false);\n          }\n        }), takeUntil(this._destroy$)).subscribe();\n      }\n      if (this.selfDisabled$) {\n        this.selfDisabled$.pipe(startWith(this.selfDisabled$.fdkDisabled), tap(d => selfDisabled = d), distinctUntilChanged(), tap(isDisabled => {\n          if (!parentDisabled) {\n            this.setDisabledState(isDisabled);\n          }\n        }), takeUntil(this._destroy$)).subscribe();\n      }\n      return this.disabledObserver.observe(this.elementRef).pipe(distinctUntilChanged());\n    }\n    /** @hidden */\n    _getInitialViewModifiers() {\n      return !this.selfDisabled$ ? [new DefaultDisabledViewModifier(this.elementRef)] : [this.selfDisabled$];\n    }\n  }\n  FdkDisabledProvider.ɵfac = function FdkDisabledProvider_Factory(t) {\n    return new (t || FdkDisabledProvider)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.ElementRef), i0.ɵɵinject(DisabledObserver), i0.ɵɵinject(FDK_DISABLED_DIRECTIVE, 10), i0.ɵɵinject(FDK_DISABLED_DIRECTIVE, 12));\n  };\n  FdkDisabledProvider.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FdkDisabledProvider,\n    factory: FdkDisabledProvider.ɵfac\n  });\n  return FdkDisabledProvider;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SelectionService = /*#__PURE__*/(() => {\n  class SelectionService {\n    /** @hidden */\n    constructor(_cd) {\n      this._cd = _cd;\n      /** @hidden */\n      this._value$ = new ReplaySubject(1);\n      /** @hidden */\n      this._destroy$ = new Subject();\n      /** @hidden */\n      this._clear$ = new Subject();\n      /** @hidden */\n      this._value = [];\n      this._normalizedValue$ = this._value$.pipe(distinctUntilChanged(equal), map(v => coerceArray(v)), map(value => this._isMultipleMode ? value : [value[0]]), map(coerced => coerced.filter(Boolean)));\n      this._normalizedValue$.pipe(takeUntil(this._destroy$)).subscribe(val => this._value = val);\n      this.value$ = this._normalizedValue$.pipe(map(v => this._getProperValues(v)), shareReplay(1));\n    }\n    /**\n     * Register main select component, which holds config\n     * */\n    registerRootComponent(rootComponent) {\n      this._rootComponent = rootComponent;\n    }\n    /**\n     * Clear listeners\n     */\n    clear() {\n      this._clear$.next();\n    }\n    /**\n     * Initialize watcher for selection changes and user interactions\n     * */\n    initialize(queryList) {\n      this._items$ = queryList.changes.pipe(startWith(queryList), map(items => items.toArray()), shareReplay(1));\n      this.listenToItemInteractions();\n    }\n    /**\n     * Sets Value, on which service looks at and updates UI accordingly\n     * */\n    setValue(v) {\n      this._value$.next(v);\n    }\n    /** @hidden */\n    getValue() {\n      return this._getProperValues(this._value);\n    }\n    /**\n     * Start listening for item interactions. Will destroy() first.\n     * Will silently continue if service was not initialized first.\n     * */\n    listenToItemInteractions() {\n      this.clear();\n      const unsubscribe$ = merge(this._destroy$, this._clear$);\n      if (this._items$) {\n        this._items$.pipe(map(items => items.filter(itm => itm.fdkSelectableItem !== false)), switchMap(items => {\n          const clickedEvents$ = items.map(item => item.clicked.pipe(map(() => item)));\n          return merge(...clickedEvents$);\n        }), tap(clickedItem => this._itemClicked(clickedItem)), takeUntil(unsubscribe$)).subscribe();\n        combineLatest([this._normalizedValue$, this._items$]).pipe(tap(([value, items]) => {\n          if (value.length === 0 && items.some(itm => itm.getSelected()) && !this._rootComponent.toggle) {\n            const selectedValues = this._getSelectedValues(items);\n            this._rootComponent.onChange(selectedValues);\n            return this._value$.next(selectedValues);\n          }\n          items.forEach(item => {\n            item.setSelected(value.includes(item.value));\n          });\n          this._cd.detectChanges();\n        }), takeUntil(unsubscribe$)).subscribe();\n      }\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._destroy$.next();\n    }\n    /** @hidden */\n    selectItem(item) {\n      if (item.fdkSelectableItem !== false) {\n        const val = [item.value, ...this._value];\n        const properValues = this._getProperValues(val);\n        this._value$.next(properValues);\n        this._rootComponent.onChange(properValues);\n      }\n    }\n    /** @hidden */\n    deselectItem(item) {\n      const canBeDeselected = this._rootComponent.toggle || this._isMultipleMode && this._value.length > 1;\n      if (canBeDeselected) {\n        const val = this._value.filter(v => v !== item.value);\n        const properValues = this._getProperValues(val);\n        this._value$.next(properValues);\n        this._rootComponent.onChange(properValues);\n      }\n    }\n    /** @hidden */\n    get _isMultipleMode() {\n      return this._rootComponent.multiple === true;\n    }\n    /** @hidden */\n    _itemClicked(item) {\n      const wasSelected = this._value.includes(item.value);\n      if (wasSelected) {\n        this.deselectItem(item);\n      } else {\n        this.selectItem(item);\n      }\n    }\n    /** @hidden */\n    _getSelectedValues(items) {\n      const selectedValues = items.filter(itm => itm.getSelected()).map(itm => itm.value);\n      return this._getProperValues(selectedValues);\n    }\n    /** @hidden */\n    _getProperValues(values) {\n      return this._isMultipleMode ? values : values[0];\n    }\n  }\n  SelectionService.ɵfac = function SelectionService_Factory(t) {\n    return new (t || SelectionService)(i0.ɵɵinject(i0.ChangeDetectorRef));\n  };\n  SelectionService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SelectionService,\n    factory: SelectionService.ɵfac\n  });\n  return SelectionService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nclass SelectComponentRootToken {}\nclass SelectableItemToken {}\n\n/**\n * Function, which generates decorator. Passed mutator will be called during value set\n */\nfunction alternateSetter(mutator) {\n  return function (targetObj, propertyKey) {\n    const _key = Symbol();\n    targetObj[_key] = targetObj[propertyKey];\n    Object.defineProperty(targetObj, propertyKey, {\n      get() {\n        return this[_key];\n      },\n      set(v) {\n        this[_key] = mutator.call(this, v, this);\n      }\n    });\n  };\n}\n\n/**\n * Decorator for coercing passed value to boolean, using @angular/cdk coerceBooleanProperty\n */\nconst coerceBoolean = alternateSetter(coerceBooleanProperty);\nlet SelectableListDirective = /*#__PURE__*/(() => {\n  class SelectableListDirective {\n    /** @hidden */\n    set selected(value) {\n      this._selectionService.setValue(value);\n    }\n    /** @hidden */\n    constructor(_selectionService) {\n      this._selectionService = _selectionService;\n      /** @hidden */\n      this.selectedChange = new EventEmitter();\n      /** @hidden */\n      this.toggle = false;\n      /** @hidden */\n      this.multiple = false;\n      this._selectionService.registerRootComponent(this);\n    }\n    /** @hidden */\n    select(item) {\n      this._selectionService.selectItem(item);\n    }\n    /** @hidden */\n    deselect(item) {\n      this._selectionService.deselectItem(item);\n    }\n    /** @hidden */\n    toggleSelect(item) {\n      if (item.getSelected()) {\n        this.deselect(item);\n      } else {\n        this.select(item);\n      }\n    }\n    /** @hidden */\n    onChange(value) {\n      this.selectedChange.emit(value);\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._selectionService.initialize(this.selectableItems);\n    }\n  }\n  SelectableListDirective.ɵfac = function SelectableListDirective_Factory(t) {\n    return new (t || SelectableListDirective)(i0.ɵɵdirectiveInject(SelectionService));\n  };\n  SelectableListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectableListDirective,\n    selectors: [[\"\", \"fdkSelectableList\", \"\"]],\n    contentQueries: function SelectableListDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, SelectableItemToken, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.selectableItems = _t);\n      }\n    },\n    inputs: {\n      toggle: \"toggle\",\n      multiple: \"multiple\",\n      selected: \"selected\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\"\n    },\n    exportAs: [\"fdkSelectableList\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SelectComponentRootToken,\n      useExisting: SelectableListDirective\n    }, SelectionService])]\n  });\n  __decorate([coerceBoolean, __metadata(\"design:type\", Object)], SelectableListDirective.prototype, \"toggle\", void 0);\n  __decorate([coerceBoolean, __metadata(\"design:type\", Object)], SelectableListDirective.prototype, \"multiple\", void 0);\n  return SelectableListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst FDK_SELECTABLE_ITEM_PROVIDER = new InjectionToken('Token for providing custom behaviors to the SelectableListItem');\nlet SelectableItemDirective = /*#__PURE__*/(() => {\n  class SelectableItemDirective {\n    /** @hidden */\n    set value(val) {\n      this._value = val;\n    }\n    get value() {\n      if (this.provider && this.provider.value) {\n        return this.provider.value;\n      }\n      return this._value;\n    }\n    /** @hidden */\n    set fdkSelectableItem(value) {\n      const isSelectable = coerceBooleanProperty(value);\n      if (isSelectable !== this._selectable) {\n        this._selectable = isSelectable;\n      }\n    }\n    get fdkSelectableItem() {\n      let selectable = this._selectable;\n      if (typeof this.provider?.fdkSelectableItem !== 'undefined') {\n        selectable = this.provider.fdkSelectableItem;\n      }\n      return selectable && (!this.disabled$ || !this.disabled$?.fdkDisabled) && (!this.readonly$ || !this.readonly$?.fdkReadonly);\n    }\n    /** @hidden */\n    constructor(provider, disabled$, readonly$, selectionService, _elementRef, _cd, _clicked) {\n      this.provider = provider;\n      this.disabled$ = disabled$;\n      this.readonly$ = readonly$;\n      this.selectionService = selectionService;\n      this._elementRef = _elementRef;\n      this._cd = _cd;\n      /** @hidden */\n      this._selected = false;\n      /** @hidden */\n      this._selectable = true;\n      this.clicked = this.provider?.clicked || _clicked.asObservable();\n      this._listenToDisablingEvents();\n    }\n    /** @hidden */\n    getSelected() {\n      if (this.provider?.getSelected) {\n        return this.provider.getSelected();\n      }\n      return this._selected;\n    }\n    /** @hidden */\n    setSelected(isSelected) {\n      if (this.provider?.setSelected) {\n        this.provider.setSelected(isSelected);\n      } else {\n        this._selected = isSelected;\n        const htmlElement = this._elementRef.nativeElement;\n        const {\n          classList\n        } = htmlElement;\n        if (isSelected) {\n          classList.add('is-selected');\n        } else {\n          classList.remove('is-selected');\n        }\n        htmlElement.setAttribute('aria-selected', `${isSelected}`);\n      }\n    }\n    /** @hidden */\n    elementRef() {\n      return this._elementRef;\n    }\n    /** @hidden */\n    _listenToDisablingEvents() {\n      const disablingEvents$ = [];\n      if (this.disabled$) {\n        disablingEvents$.push(this.disabled$);\n      }\n      if (this.readonly$) {\n        disablingEvents$.push(this.readonly$);\n      }\n      merge(...disablingEvents$).subscribe(() => this._updateSelectionAndSelectableWatcher());\n    }\n    /** @hidden */\n    _updateSelectionAndSelectableWatcher() {\n      if (this.disabled$?.fdkDisabled) {\n        this.selectionService.deselectItem(this);\n      }\n      this._updateSelectableWatcher();\n    }\n    /** @hidden */\n    _updateSelectableWatcher() {\n      this.selectionService.listenToItemInteractions();\n    }\n  }\n  SelectableItemDirective.ɵfac = function SelectableItemDirective_Factory(t) {\n    return new (t || SelectableItemDirective)(i0.ɵɵdirectiveInject(FDK_SELECTABLE_ITEM_PROVIDER, 8), i0.ɵɵdirectiveInject(FdkDisabledProvider), i0.ɵɵdirectiveInject(FdkReadonlyProvider), i0.ɵɵdirectiveInject(SelectionService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(FdkClickedProvider));\n  };\n  SelectableItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: SelectableItemDirective,\n    selectors: [[\"\", \"fdkSelectableItem\", \"\"]],\n    inputs: {\n      value: \"value\",\n      fdkSelectableItem: \"fdkSelectableItem\"\n    },\n    outputs: {\n      clicked: \"clicked\"\n    },\n    exportAs: [\"fdkSelectableItem\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: SelectableItemToken,\n      useExisting: SelectableItemDirective\n    }, FdkReadonlyProvider, FdkDisabledProvider, FdkClickedProvider])]\n  });\n  return SelectableItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SelectableListModule = /*#__PURE__*/(() => {\n  class SelectableListModule {}\n  SelectableListModule.ɵfac = function SelectableListModule_Factory(t) {\n    return new (t || SelectableListModule)();\n  };\n  SelectableListModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SelectableListModule\n  });\n  SelectableListModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return SelectableListModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Injection token for the viewport size observable.\n * Emits the viewport size in pixels, which are outputted by the ViewportRuler\n * from @angular/cdk/overlay.\n */\nconst ViewportSizeObservable = new InjectionToken('ViewportSizeObservable', {\n  providedIn: 'root',\n  factory: () => {\n    const viewportRuler = inject(ViewportRuler);\n    return viewportRuler.change(50).pipe(map$1(e => e.target.innerWidth)).pipe(startWith(window.innerWidth));\n  }\n});\nconst ResponsiveBreakpoints = {\n  S: 600,\n  M: 1024,\n  L: 1440\n};\n/** @hidden */\nfunction getBreakpointName(width) {\n  if (width < ResponsiveBreakpoints.S) {\n    return 'S';\n  }\n  if (width < ResponsiveBreakpoints.M) {\n    return 'M';\n  }\n  if (width < ResponsiveBreakpoints.L) {\n    return 'L';\n  }\n  return 'XL';\n}\n\n/* eslint-disable @angular-eslint/no-input-rename */\n/**\n * Directive to show/hide element on specific breakpoint or range of window width.\n * Uses native ngIf directive to show/hide element.\n */\nlet BreakpointDirective = /*#__PURE__*/(() => {\n  class BreakpointDirective {\n    /**\n     * Provide list of the breakpoints to show element on.\n     * */\n    set fdkBreakpoint(value) {\n      const providedValues = value.map(v => v.toLowerCase());\n      this.showOnS = providedValues.includes('s');\n      this.showOnM = providedValues.includes('m');\n      this.showOnL = providedValues.includes('l');\n      this.showOnXL = providedValues.includes('xl');\n    }\n    /**\n     * Show element on S breakpoint.\n     * S - 0 - 599px\n     * */\n    set showOnS(value) {\n      this._showOnS = coerceBooleanProperty(value);\n    }\n    /**\n     * Show element on M breakpoint.\n     * M - 0 - 1023px\n     * */\n    set showOnM(value) {\n      this._showOnM = coerceBooleanProperty(value);\n    }\n    /**\n     * Show element on L breakpoint.\n     * L - 0 - 1439px\n     * */\n    set showOnL(value) {\n      this._showOnL = coerceBooleanProperty(value);\n    }\n    /**\n     * Show element on XL breakpoint.\n     *  */\n    set showOnXL(value) {\n      this._showOnXL = coerceBooleanProperty(value);\n    }\n    /**\n     * Observe element width changes.\n     */\n    set observationSource(value) {\n      const element = coerceElement(value);\n      this._sizeObservable$.next(this._resizeObserverService.observe(value).pipe(map(() => element.offsetWidth), startWith(element.offsetWidth)));\n    }\n    /** @hidden */\n    constructor(templateRef, viewContainer) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n      /** @hidden */\n      this._showOnS = false;\n      /** @hidden */\n      this._showOnM = false;\n      /** @hidden */\n      this._showOnL = false;\n      /** @hidden */\n      this._showOnXL = false;\n      /** @hidden */\n      this.viewportSize$ = inject(ViewportSizeObservable);\n      /** @hidden */\n      this._destroyed$ = inject(DestroyedService);\n      /** @hidden */\n      this._resizeObserverService = inject(ResizeObserverService);\n      /** @hidden */\n      this.onChanges$ = new Subject();\n      /** @hidden */\n      this._sizeObservable$ = new BehaviorSubject(this.viewportSize$);\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      combineLatest([this._sizeObservable$.pipe(switchMap$1(obs$ => obs$)), this.onChanges$.pipe(startWith(void 0))]).pipe(map(([w]) => [w, getBreakpointName(w)]), map(([width, breakpointName]) => this._shouldShow(width, breakpointName)), tap(shouldShow => {\n        if (shouldShow) {\n          if (!this.templateViewRef) {\n            this.viewContainer.clear();\n            this.templateViewRef = this.viewContainer.createEmbeddedView(this.templateRef);\n            this.templateViewRef.detectChanges();\n          }\n        } else {\n          this.viewContainer.clear();\n          this.templateViewRef = undefined;\n        }\n      }), takeUntil(this._destroyed$), finalize(() => {\n        this.viewContainer.clear();\n        this.templateViewRef = undefined;\n      })).subscribe();\n    }\n    /** @hidden */\n    ngOnChanges() {\n      this.onChanges$.next();\n    }\n    /** @hidden */\n    _shouldShow(width, currentBreakpoint) {\n      const shouldShowOnBreakpoints = [this._showOnS && 'S', this._showOnM && 'M', this._showOnL && 'L', this._showOnXL && 'XL'].filter(Boolean);\n      const shouldShow = shouldShowOnBreakpoints.includes(currentBreakpoint);\n      if (this.fdkBreakpointLt) {\n        return width < this.fdkBreakpointLt;\n      }\n      if (this.fdkBreakpointGt) {\n        return width > this.fdkBreakpointGt;\n      }\n      return shouldShow;\n    }\n  }\n  BreakpointDirective.ɵfac = function BreakpointDirective_Factory(t) {\n    return new (t || BreakpointDirective)(i0.ɵɵdirectiveInject(i0.TemplateRef), i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n  BreakpointDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BreakpointDirective,\n    selectors: [[\"\", \"fdkBreakpoint\", \"\"], [\"\", \"fdkBreakpointS\", \"\"], [\"\", \"fdkBreakpointM\", \"\"], [\"\", \"fdkBreakpointL\", \"\"], [\"\", \"fdkBreakpointXL\", \"\"], [\"\", \"fdkBreakpointLt\", \"\"], [\"\", \"fdkBreakpointGt\", \"\"]],\n    inputs: {\n      fdkBreakpoint: \"fdkBreakpoint\",\n      showOnS: [\"fdkBreakpointS\", \"showOnS\"],\n      showOnM: [\"fdkBreakpointM\", \"showOnM\"],\n      showOnL: [\"fdkBreakpointL\", \"showOnL\"],\n      showOnXL: [\"fdkBreakpointXL\", \"showOnXL\"],\n      fdkBreakpointLt: \"fdkBreakpointLt\",\n      fdkBreakpointGt: \"fdkBreakpointGt\",\n      observationSource: [\"fdkBreakpointObserve\", \"observationSource\"]\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([DestroyedService]), i0.ɵɵNgOnChangesFeature]\n  });\n  return BreakpointDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet BreakpointModule = /*#__PURE__*/(() => {\n  class BreakpointModule {}\n  BreakpointModule.ɵfac = function BreakpointModule_Factory(t) {\n    return new (t || BreakpointModule)();\n  };\n  BreakpointModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BreakpointModule\n  });\n  BreakpointModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return BreakpointModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DND_ITEM = new InjectionToken('Drag and drop Item');\nconst DND_LIST = new InjectionToken('Drag and drop List');\nlet DndListDirective = /*#__PURE__*/(() => {\n  class DndListDirective {\n    constructor() {\n      /**\n       * Defines if the element is allowed to be dragged in 2 dimensions,\n       * When true - replace indicator will be displayed vertically\n       */\n      this.gridMode = false;\n      /**\n       * Defines drop strategy:\n       * * `shift` mode will create line after closest drop element.\n       * * `group` mode will create replace indicator on whole closest drop element.\n       * * `auto` mode will create line after closest drop element,\n       * if dragged element coordinates are shifted for 30% from center of the closest drop element.\n       * Otherwise, it will create replace indicator on whole closest drop element.\n       *\n       * `shift` mode is the default.\n       */\n      this.dropMode = 'shift';\n      /**\n       * Threshold of dragged item over another item to define which type of `dropMode` should be used.\n       */\n      this.threshold = 0.3;\n      /** @hidden */\n      this._replaceMode = false;\n      /** Event that is thrown, when items are reordered */\n      this.itemsChange = new EventEmitter();\n      /** Event that is thrown, when the item is dropped */\n      this.itemDropped = new EventEmitter();\n      /** @hidden */\n      this._closestItemIndex = null;\n      /** @hidden */\n      this._closestItemPosition = null;\n      /** An RxJS Subject that will kill the current data stream (for unsubscribing)  */\n      this._refresh$ = new Subject();\n      /** @hidden */\n      this._onDestroy$ = new Subject();\n      /** @hidden */\n      this._draggable = true;\n      /** @hidden */\n      this._initialClass = 'fd-dnd-list';\n      /** @hidden */\n      this._linesRemoved = true;\n      /** @hidden */\n      this._indicatorsRemoved = true;\n    }\n    /**\n     * @deprecated\n     * Use `dropMode` property for better configuration.\n     *\n     * @description\n     * When enabled, replace indicator will appear on whole element, instead of horizontal/vertical line before/after element.\n     */\n    set replaceMode(value) {\n      this._replaceMode = value;\n      this.dropMode = value ? 'group' : 'shift';\n      this._detectedDropMode = this.dropMode;\n    }\n    get replaceMode() {\n      return this._replaceMode;\n    }\n    /** Defines if drag and drop feature should be enabled for list items */\n    set draggable(draggable) {\n      this._draggable = draggable;\n      this._changeDraggableState(draggable);\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      this._changeDraggableState(this._draggable);\n      this.dndItems.changes.pipe(takeUntil(this._onDestroy$), startWith(0)).subscribe(() => this._refreshQueryList());\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n    }\n    /** Method called, when the item is being moved by 1 px */\n    onMove(mousePosition, draggedItemIndex) {\n      /** Temporary object, to store lowest distance values */\n      let closestItemIndex = null;\n      const closestItem = this._elementsCoordinates.find((element, index) => {\n        /** Check if element can be replaced */\n        if (!element.stickToPosition && closestItemIndex !== index) {\n          const isMouseOnElement = _isMouseOnElement(element, mousePosition);\n          if (isMouseOnElement) {\n            closestItemIndex = index;\n            return true;\n          }\n        }\n        return false;\n      });\n      if (!closestItem) {\n        closestItemIndex = null;\n      }\n      /** If the closest element is different from the old one, new one is picked. It prevents from performance issues */\n      if ((closestItemIndex || closestItemIndex === 0) && (closestItemIndex !== this._closestItemIndex || this.dropMode === 'auto')) {\n        this._removeAllLines();\n        this._removeAllReplaceIndicators();\n        this._closestItemIndex = closestItemIndex;\n        this._closestItemPosition = this._elementsCoordinates[closestItemIndex].position;\n        // If closest item index is same as dragged item, just remove indicators\n        if (closestItemIndex === draggedItemIndex) {\n          this._removeAllLines();\n          this._removeAllReplaceIndicators();\n          return;\n        }\n        /** Generating line, that shows where the element will be placed, on drop */\n        if (this.dropMode === 'group') {\n          this._createReplaceIndicator(this._closestItemIndex);\n        } else if (this.dropMode === 'shift') {\n          this._createLine(this._closestItemIndex, this._closestItemPosition);\n        } else {\n          this._selectDropModeIndicator(draggedItemIndex, closestItem, closestItemIndex);\n        }\n      }\n    }\n    /** Method called, when element is started to be dragged */\n    dragStart(index) {\n      const draggedItemElement = this._dndItemReference[index].elementRef;\n      /** Counting all the element's chords */\n      this._elementsCoordinates = this._dndItemReference.map(item => item.getElementCoordinates(this._isBefore(draggedItemElement, item.elementRef), this.gridMode));\n    }\n    /** Method called, when element is released */\n    dragEnd(draggedItemIndex) {\n      const items = this.items.slice();\n      const replacedItemIndex = this._closestItemIndex;\n      const draggedItem = items[draggedItemIndex];\n      if (replacedItemIndex || replacedItemIndex === 0) {\n        if (draggedItemIndex !== replacedItemIndex) {\n          if (draggedItemIndex < replacedItemIndex) {\n            for (let i = draggedItemIndex; i < replacedItemIndex; i++) {\n              items[i] = items[i + 1];\n            }\n          } else {\n            for (let i = draggedItemIndex; i > replacedItemIndex; i--) {\n              items[i] = items[i - 1];\n            }\n          }\n          /** Replacing items */\n          items[replacedItemIndex] = draggedItem;\n          this.itemsChange.emit(items);\n        }\n        this.itemDropped.emit({\n          replacedItemIndex,\n          draggedItemIndex,\n          items,\n          insertAt: this._closestItemPosition,\n          mode: this.dropMode !== 'auto' ? this.dropMode : this._detectedDropMode\n        });\n        this._removeAllLines();\n        this._removeAllReplaceIndicators();\n        /** Reset */\n        this._elementsCoordinates = [];\n        this._closestItemIndex = null;\n        this._closestItemPosition = null;\n      }\n    }\n    /** @hidden */\n    _selectDropModeIndicator(draggedItemIndex, closestItem, closestItemIndex) {\n      if (!closestItem || !this._dndItemReference[draggedItemIndex]) {\n        return;\n      }\n      let newDetectedDropMode;\n      const draggedElmCoords = this._dndItemReference[draggedItemIndex].elementRef.nativeElement.getBoundingClientRect();\n      const closestItemBoundaries = getElementBoundaries(closestItem, this.threshold);\n      const draggedItemStartCoords = getElementStartCoords(draggedElmCoords, closestItem.position);\n      if (_between(draggedItemStartCoords.x, closestItemBoundaries.x.start, closestItemBoundaries.x.end) && _between(draggedItemStartCoords.y, closestItemBoundaries.y.start, closestItemBoundaries.y.end)) {\n        newDetectedDropMode = 'group';\n      } else {\n        newDetectedDropMode = 'shift';\n      }\n      if (newDetectedDropMode === this._detectedDropMode && (!this._linesRemoved || !this._indicatorsRemoved)) {\n        return;\n      }\n      this._detectedDropMode = newDetectedDropMode;\n      if (this._detectedDropMode === 'shift') {\n        this._createLine(closestItemIndex, this._elementsCoordinates[closestItemIndex].position);\n      } else {\n        this._createReplaceIndicator(closestItemIndex);\n      }\n    }\n    /** @hidden */\n    _removeAllLines() {\n      this._linesRemoved = true;\n      this.dndItems.forEach(item => item.removeLine());\n    }\n    /** @hidden */\n    _removeAllReplaceIndicators() {\n      this._indicatorsRemoved = true;\n      this.dndItems.forEach(item => item.removeReplaceIndicator());\n    }\n    /** @hidden */\n    _createLine(closestItemIndex, linkPosition) {\n      this._removeAllLines();\n      this._removeAllReplaceIndicators();\n      this._linesRemoved = false;\n      this._dndItemReference[closestItemIndex].createLine(linkPosition, this.gridMode);\n    }\n    /** @hidden */\n    _createReplaceIndicator(closestItemIndex) {\n      this._removeAllLines();\n      this._removeAllReplaceIndicators();\n      this._indicatorsRemoved = false;\n      this._dndItemReference[closestItemIndex].createReplaceIndicator();\n    }\n    /** @hidden */\n    _refreshQueryList() {\n      const refresh$ = merge(this._refresh$, this._onDestroy$);\n      this._refresh$.next();\n      this._dndItemReference = this.dndItems.toArray();\n      this._changeDraggableState(this._draggable);\n      this.dndItems.forEach((item, index) => {\n        item.moved.pipe(takeUntil(refresh$)).subscribe(position => this.onMove(position, index));\n        item.started.pipe(takeUntil(refresh$)).subscribe(() => this.dragStart(index));\n        item.released.pipe(takeUntil(refresh$)).subscribe(() => this.dragEnd(index));\n      });\n    }\n    /**\n     *  @hidden\n     * Return information if element is placed before the dragged element\n     */\n    _isBefore(draggedElement, targetElement) {\n      /** Sometimes the element are not straight in one column, that's why offset is needed */\n      const VERTICAL_OFFSET = 20;\n      /** Distances from the top of screen */\n      const draggedElementBound = draggedElement.nativeElement.getBoundingClientRect();\n      const targetElementBound = targetElement.nativeElement.getBoundingClientRect();\n      if (draggedElementBound.top - targetElementBound.top > VERTICAL_OFFSET) {\n        /** If element is higher than the dragged element, it's for sure before */\n        return true;\n      } else if (targetElementBound.top - draggedElementBound.top > VERTICAL_OFFSET) {\n        /** If element is lower than the dragged element, it's for sure after */\n        return false;\n      } else {\n        /** If elements are in same level, the horizontal position decides if it's before/after */\n        return draggedElementBound.left - targetElementBound.left > 0;\n      }\n    }\n    /** @hidden */\n    _changeDraggableState(draggable) {\n      if (this.dndItems) {\n        this.dndItems.forEach(item => {\n          item.listDraggable = draggable;\n          item.changeCDKDragState();\n        });\n      }\n    }\n  }\n  DndListDirective.ɵfac = function DndListDirective_Factory(t) {\n    return new (t || DndListDirective)();\n  };\n  DndListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndListDirective,\n    selectors: [[\"\", \"fdkDndList\", \"\"], [\"\", \"fd-dnd-list\", \"\"]],\n    contentQueries: function DndListDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, DND_ITEM, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.dndItems = _t);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function DndListDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassMap(ctx._initialClass);\n      }\n    },\n    inputs: {\n      gridMode: \"gridMode\",\n      dropMode: \"dropMode\",\n      threshold: \"threshold\",\n      replaceMode: \"replaceMode\",\n      items: \"items\",\n      draggable: \"draggable\"\n    },\n    outputs: {\n      itemsChange: \"itemsChange\",\n      itemDropped: \"itemDropped\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: DND_LIST,\n      useExisting: forwardRef(() => DndListDirective)\n    }])]\n  });\n  return DndListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nfunction _isMouseOnElement(element, mousePosition) {\n  const startX = element.x;\n  const endX = element.x + element.width;\n  const startY = element.y;\n  const endY = element.y + element.height;\n  return _between(mousePosition.x, startX, endX) && _between(mousePosition.y, startY, endY);\n}\nfunction _between(x, min, max) {\n  return x >= min && x <= max;\n}\nfunction getElementStartCoords(rect, position) {\n  return {\n    x: position === 'after' ? rect.x + rect.width : rect.x,\n    y: position === 'after' ? rect.y + rect.height : rect.y\n  };\n}\nfunction getElementBoundaries(coordinates, threshold) {\n  const widthOffset = coordinates.width * (coordinates.position === 'after' ? 1 : -1);\n  const heightOffset = coordinates.height * (coordinates.position === 'after' ? 1 : -1);\n  const xStart = coordinates.position === 'after' ? coordinates.x : coordinates.x + coordinates.width;\n  const xEnd = xStart + widthOffset + widthOffset / 2 * threshold;\n  const yStart = coordinates.position === 'after' ? coordinates.y : coordinates.y + coordinates.height;\n  const yEnd = yStart + heightOffset + heightOffset / 2 * threshold;\n  return {\n    x: {\n      start: xStart > xEnd ? xEnd : xStart,\n      end: xStart > xEnd ? xStart : xEnd\n    },\n    y: {\n      start: yStart > yEnd ? yEnd : yStart,\n      end: yStart > yEnd ? yStart : yEnd\n    }\n  };\n}\nlet DndItemDirective = /*#__PURE__*/(() => {\n  class DndItemDirective {\n    /** Defines if element is draggable */\n    set draggable(draggable) {\n      this._draggable = draggable;\n      this.changeCDKDragState();\n    }\n    /** @hidden */\n    constructor(elementRef, _dragDrop) {\n      this.elementRef = elementRef;\n      this._dragDrop = _dragDrop;\n      /**\n       * Whether to apply \"fd-dnd-item\" class.\n       * @default true\n       */\n      this.applyDragItemClass = true;\n      /** Event thrown when the element is moved by 1px */\n      this.moved = new EventEmitter();\n      /** Event thrown when the element is released */\n      this.released = new EventEmitter();\n      /** Event thrown when the element is started to be dragged */\n      this.started = new EventEmitter();\n      /**\n       *  Defines if the item is prevented from being moved by other elements.\n       * So nothing can be placed just before and just after it\n       */\n      this.stickInPlace = false;\n      /** Class added to element, when it's dragged. */\n      this.classWhenElementDragged = 'fd-dnd-on-drag';\n      /** Defines if every element in list is draggable */\n      this.listDraggable = true;\n      /** @hidden */\n      this._draggable = true;\n      /** @hidden */\n      this._subscriptions = new Subscription();\n    }\n    /** @hidden */\n    getElementCoordinates(isBefore) {\n      /** Takes distance from the beginning of window page */\n      const rect = this.elementRef.nativeElement.getBoundingClientRect();\n      const position = isBefore ? 'before' : 'after';\n      /** Vertically distance is counted by distance from top of the side + half of the element height */\n      return {\n        x: rect.left,\n        position,\n        y: rect.top,\n        stickToPosition: this.stickInPlace,\n        width: rect.width,\n        height: rect.height\n      };\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      this._setCDKDrag();\n      this._listenElementEvents();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscriptions.unsubscribe();\n      this._dragRef.dispose();\n    }\n    /** @hidden */\n    onCdkMove(position) {\n      this.moved.emit(position);\n    }\n    /** @hidden */\n    onCdkDragReleased() {\n      /** Remove class which is added, when element is dragged */\n      this.elementRef.nativeElement.classList.remove(this.classWhenElementDragged);\n      this.released.emit();\n      /** Resets the position of element. */\n      this._dragRef.reset();\n      /** Removes placeholder element */\n      this.removePlaceholder();\n    }\n    /** @hidden */\n    onCdkDragStart() {\n      /** Adds class */\n      this.elementRef.nativeElement.classList.add(this.classWhenElementDragged);\n      if (!this._placeholderElement) {\n        this.createPlaceholder();\n      }\n      this.started.emit();\n    }\n    /** @hidden */\n    removePlaceholder() {\n      if (this._placeholderElement && this._placeholderElement.parentNode) {\n        // IE11 workaround\n        this._placeholderElement.parentNode.removeChild(this._placeholderElement);\n        this._placeholderElement = null;\n      }\n    }\n    /** @hidden */\n    removeLine() {\n      if (this._lineElement && this._lineElement.parentNode) {\n        // IE11 workaround\n        this._lineElement.parentNode.removeChild(this._lineElement);\n        this._lineElement = null;\n      }\n    }\n    /** @hidden */\n    removeReplaceIndicator() {\n      if (this._replaceIndicator && this._replaceIndicator.parentNode) {\n        // IE11 workaround\n        this._replaceIndicator.parentNode.removeChild(this._replaceIndicator);\n        this._replaceIndicator = null;\n      }\n    }\n    /** @hidden */\n    createReplaceIndicator() {\n      this._replaceIndicator = document.createElement('DIV');\n      this._replaceIndicator.classList.add('fd-replace-indicator');\n      let container = this.elementRef.nativeElement;\n      if (this.containerSelector) {\n        const newContainer = this.elementRef.nativeElement.querySelector(this.containerSelector);\n        if (newContainer) {\n          container = newContainer;\n        }\n      }\n      container.appendChild(this._replaceIndicator);\n    }\n    /** @hidden */\n    createLine(position, gridMode) {\n      /** Creating of line element */\n      this._lineElement = document.createElement('div');\n      this._lineElement.classList.add('drop-area__line');\n      if (gridMode) {\n        this._lineElement.classList.add('drop-area__line--vertical');\n      } else {\n        this._lineElement.classList.add('drop-area__line--horizontal');\n      }\n      if (position === 'after') {\n        this._lineElement.classList.add('after');\n      }\n      if (position === 'before') {\n        this._lineElement.classList.add('before');\n      }\n      /** Putting element to the container */\n      let container = this.elementRef.nativeElement;\n      if (this.containerSelector) {\n        const newContainer = this.elementRef.nativeElement.querySelector(this.containerSelector);\n        if (newContainer) {\n          container = newContainer;\n        }\n      }\n      container.appendChild(this._lineElement);\n    }\n    /** @hidden */\n    changeCDKDragState() {\n      if (this._dragRef) {\n        this._dragRef.disabled = !(this._draggable && this.listDraggable);\n      }\n    }\n    /** @hidden */\n    createPlaceholder() {\n      const placeholder = this.elementRef.nativeElement.cloneNode(true);\n      /** Cloning container element */\n      this._placeholderElement = placeholder;\n      placeholder.classList.add('fd-dnd-placeholder');\n      this._setPlaceholderStyles();\n      /** Including element to the container\n       *  IE11 equivalent to `this.element.nativeElement.after(clone);`\n       */\n      this._placeAfter(this.elementRef.nativeElement, placeholder);\n    }\n    /** @hidden */\n    _setPlaceholderStyles() {\n      const offset = this._getOffsetToParent(this.elementRef.nativeElement);\n      if (!offset || !this._placeholderElement) {\n        return;\n      }\n      this._placeholderElement.style.top = offset.y + 'px';\n      this._placeholderElement.style.left = offset.x + 'px';\n      this._placeholderElement.style.position = 'absolute';\n      this._placeholderElement.style.zIndex = '0';\n      this._placeholderElement.style.opacity = '0.3';\n      this._placeholderElement.style.width = this.elementRef.nativeElement.offsetWidth + 'px';\n      this._placeholderElement.style.height = this.elementRef.nativeElement.offsetHeight + 'px';\n    }\n    /** @hidden */\n    _getOffsetToParent(element) {\n      const parentElement = element.parentElement;\n      if (!parentElement) {\n        return;\n      }\n      const parentTop = parentElement.getBoundingClientRect().top;\n      const parentLeft = parentElement.getBoundingClientRect().left;\n      return {\n        x: Math.abs(element.getBoundingClientRect().left - parentLeft),\n        y: Math.abs(element.getBoundingClientRect().top - parentTop)\n      };\n    }\n    /** @hidden */\n    _setCDKDrag() {\n      this._dragRef = this._dragDrop.createDrag(this.elementRef);\n      this._dragRef.disabled = !this._draggable;\n      this._subscriptions.add(this._dragRef.moved.subscribe(event => this.onCdkMove(event.pointerPosition)));\n      this._subscriptions.add(this._dragRef.released.subscribe(() => this.onCdkDragReleased()));\n      this._subscriptions.add(this._dragRef.started.subscribe(() => this.onCdkDragStart()));\n    }\n    /** IE11 equivalent of Node.after() Method */\n    _placeAfter(element, cloneNode) {\n      const docFrag = document.createDocumentFragment();\n      docFrag.appendChild(cloneNode);\n      element.parentNode?.insertBefore(docFrag, element.nextSibling);\n    }\n    /** @hidden */\n    _listenElementEvents() {\n      this._subscriptions.add(this.released.pipe(\n      // postpone blur\n      delay(0)).subscribe(() => {\n        if (this.containerSelector) {\n          this.elementRef.nativeElement.children[0].blur();\n        }\n        this.elementRef.nativeElement.blur();\n      }));\n    }\n  }\n  DndItemDirective.ɵfac = function DndItemDirective_Factory(t) {\n    return new (t || DndItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$4.DragDrop));\n  };\n  DndItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndItemDirective,\n    selectors: [[\"\", \"fdkDndItem\", \"\"], [\"\", \"fd-dnd-item\", \"\"]],\n    hostVars: 2,\n    hostBindings: function DndItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"fd-dnd-item\", ctx.applyDragItemClass);\n      }\n    },\n    inputs: {\n      applyDragItemClass: \"applyDragItemClass\",\n      containerSelector: \"containerSelector\",\n      stickInPlace: \"stickInPlace\",\n      draggable: \"draggable\",\n      classWhenElementDragged: \"classWhenElementDragged\"\n    },\n    outputs: {\n      moved: \"moved\",\n      released: \"released\",\n      started: \"started\"\n    },\n    features: [i0.ɵɵProvidersFeature([DragDrop, {\n      provide: DND_ITEM,\n      useExisting: forwardRef(() => DndItemDirective)\n    }])]\n  });\n  return DndItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * This directive is used to provide drag & drop with keyboard support.\n * It should be used together with directive fdDndKeyboardItem.\n */\nlet DndKeyboardGroupDirective = /*#__PURE__*/(() => {\n  class DndKeyboardGroupDirective {\n    /** @hidden */\n    constructor(_cdr, _rtlService) {\n      this._cdr = _cdr;\n      this._rtlService = _rtlService;\n      /** Whether to disable drag & drop */\n      this.disableKeyboardDragDrop = false;\n      /** Used to apply indexes when moving between groups */\n      this.orientation = 'vertical';\n      /** @hidden */\n      this._onDndItemFocus$ = new Subject();\n      /** Custom function to call when moving item inside the group */\n      this.customMoveFn = (group, fromIndex, toIndex) => moveItemInArray(group, fromIndex, toIndex);\n      /** Custom function to call when moving item between groups */\n      this.customTransferFn = (group, nextGroup, fromIndex, toIndex) => transferArrayItem(group, nextGroup, fromIndex, toIndex);\n    }\n    /** Process drag & drop */\n    processDragDrop(event, itemIndex, groupIndex) {\n      if (this.disableKeyboardDragDrop || !event.altKey) {\n        return;\n      }\n      const isRtl = this._rtlService.rtl.value;\n      const group = this.groups[groupIndex];\n      const indexInNextGroup = this.orientation === 'vertical' ? 0 : itemIndex;\n      const nextGroupExists = this.groups.length > groupIndex + 1;\n      const prevGroupExists = !!groupIndex;\n      if (KeyUtil.isKeyCode(event, RIGHT_ARROW) && (isRtl ? prevGroupExists : nextGroupExists)) {\n        event.preventDefault();\n        const nextGroupIndex = groupIndex + (isRtl ? -1 : 1);\n        const nextGroup = this.groups[nextGroupIndex];\n        this.customTransferFn(group, nextGroup, itemIndex, indexInNextGroup);\n        this._focusDndItem(nextGroupIndex, indexInNextGroup);\n      } else if (KeyUtil.isKeyCode(event, LEFT_ARROW) && (isRtl ? nextGroupExists : prevGroupExists)) {\n        event.preventDefault();\n        const nextGroupIndex = groupIndex + (isRtl ? 1 : -1);\n        const nextGroup = this.groups[nextGroupIndex];\n        this.customTransferFn(group, nextGroup, itemIndex, indexInNextGroup);\n        this._focusDndItem(nextGroupIndex, indexInNextGroup);\n      } else if (KeyUtil.isKeyCode(event, DOWN_ARROW)) {\n        event.preventDefault();\n        this.customMoveFn(group, itemIndex, itemIndex + 1);\n        this._focusDndItem(groupIndex, itemIndex + 1);\n      } else if (KeyUtil.isKeyCode(event, UP_ARROW)) {\n        event.preventDefault();\n        this.customMoveFn(group, itemIndex, itemIndex - 1);\n        this._focusDndItem(groupIndex, itemIndex - 1);\n      }\n    }\n    /** @hidden Focus after moving elements with keyboard */\n    _focusDndItem(groupIndex, itemIndex) {\n      this._cdr.detectChanges();\n      this._onDndItemFocus$.next([groupIndex, itemIndex]);\n    }\n  }\n  DndKeyboardGroupDirective.ɵfac = function DndKeyboardGroupDirective_Factory(t) {\n    return new (t || DndKeyboardGroupDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(RtlService, 8));\n  };\n  DndKeyboardGroupDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndKeyboardGroupDirective,\n    selectors: [[\"\", \"fdkDndKeyboardGroup\", \"\"], [\"\", \"fdDndKeyboardGroup\", \"\"]],\n    inputs: {\n      groups: \"groups\",\n      disableKeyboardDragDrop: \"disableKeyboardDragDrop\",\n      orientation: \"orientation\",\n      customMoveFn: \"customMoveFn\",\n      customTransferFn: \"customTransferFn\"\n    }\n  });\n  return DndKeyboardGroupDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * This directive is used to provide drag & drop with keyboard support.\n * It should be used together with directive fdDndKeyboardGroup.\n * We are using _groups from fdDndKeyboardGroup and adding a possibility to move cards.\n * Please see example below:\n * @Component({\n * selector: 'cdk-drag-drop-example',\n * template: `<div\n *               cdkDragListGroup\n *               fdDndKeyboardGroup\n *               [groups]=\"groups\"\n *           >\n *               <div\n *                   *ngFor=\"let group of groups; let groupIndex = index\"\n *                   cdkDragList\n *               >\n *                   Group #{{ groupIndex }}\n *                   <div\n *                       *ngFor=\"let item of group; let index = index\"\n *                       cdkDrag\n *                       fdDndKeyboardItem\n *                       [itemIndex]=\"index\"\n *                       [groupIndex]=\"groupIndex\"\n *                       [dndKeyboardDisabled]=\"flag for disable/enable keyboard navigation if needed\"\n *                       tabindex=\"0\"\n *                   >\n *                       Item #{{ item }}\n *                   </div>\n *               </div>\n *           </div>`,\n * })\n * export class CdkDragDropExample {\n *   groups = [\n *        [1, 2, 3],\n *        [4, 5, 6],\n *      ];\n *   }\n */\nlet DndKeyboardItemDirective = /*#__PURE__*/(() => {\n  class DndKeyboardItemDirective {\n    /** @hidden */\n    constructor(_dndGroup, _elementRef) {\n      this._dndGroup = _dndGroup;\n      this._elementRef = _elementRef;\n      /** @hidden */\n      this._onDestroy$ = new Subject();\n    }\n    /** @hidden */\n    ngOnInit() {\n      this._dndGroup._onDndItemFocus$.subscribe(([groupIndex, itemIndex]) => {\n        if (this.groupIndex === groupIndex && this.itemIndex === itemIndex) {\n          this._elementRef.nativeElement.focus();\n        }\n      });\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n    }\n    /** @hidden */\n    _onKeyDown(event) {\n      this._dndGroup.processDragDrop(event, this.itemIndex, this.groupIndex);\n    }\n  }\n  DndKeyboardItemDirective.ɵfac = function DndKeyboardItemDirective_Factory(t) {\n    return new (t || DndKeyboardItemDirective)(i0.ɵɵdirectiveInject(DndKeyboardGroupDirective), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  DndKeyboardItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DndKeyboardItemDirective,\n    selectors: [[\"\", \"fdkDndKeyboardItem\", \"\"], [\"\", \"fdDndKeyboardItem\", \"\"]],\n    hostBindings: function DndKeyboardItemDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function DndKeyboardItemDirective_keydown_HostBindingHandler($event) {\n          return ctx._onKeyDown($event);\n        });\n      }\n    },\n    inputs: {\n      itemIndex: \"itemIndex\",\n      groupIndex: \"groupIndex\"\n    }\n  });\n  return DndKeyboardItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DragAndDropModule = /*#__PURE__*/(() => {\n  class DragAndDropModule {}\n  DragAndDropModule.ɵfac = function DragAndDropModule_Factory(t) {\n    return new (t || DragAndDropModule)();\n  };\n  DragAndDropModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: DragAndDropModule\n  });\n  DragAndDropModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule, DragDropModule]\n  });\n  return DragAndDropModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet UtilsModule = /*#__PURE__*/(() => {\n  class UtilsModule {}\n  UtilsModule.ɵfac = function UtilsModule_Factory(t) {\n    return new (t || UtilsModule)();\n  };\n  UtilsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: UtilsModule\n  });\n  UtilsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [RtlService, ThemesService],\n    imports: [CommonModule, FocusableItemModule, FocusableListModule, FocusableGridModule, DragAndDropModule, OnlyDigitsModule, TruncateModule, LineClampModule, OverflowListModule, RepeatModule, ResizeModule, TemplateModule, AutoCompleteModule, DisabledBehaviorModule, SelectableListModule, ReadonlyBehaviorModule, ClickedBehaviorModule, InitialFocusModule, BreakpointModule, FocusableItemModule, FocusableListModule, FocusableGridModule, DragAndDropModule, OnlyDigitsModule, TruncateModule, LineClampModule, OverflowListModule, RepeatModule, ResizeModule, TemplateModule, AutoCompleteModule, DisabledBehaviorModule, SelectableListModule, ReadonlyBehaviorModule, ClickedBehaviorModule, InitialFocusModule, BreakpointModule]\n  });\n  return UtilsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** @hidden */\nfunction coerceArraySafe(value) {\n  return isBlank(value) ? [] : coerceArray(value);\n}\nconst ELEMENT_REF_EXCEPTION = 'HasElementRef interface has to be implemented';\n\n/**\n * Method decorator to apply css class to a component through native element\n * decorator will store original method in variable and wrap it with custom one\n * component has to implement CssClassBuilder interface\n * more info abour method decorator: https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators\n * @param target a component\n * @param propertyKey name of the method\n * @param descriptor method\n */\nfunction applyCssClass(target, propertyKey, descriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function () {\n    const self = this;\n    if (!self.elementRef) {\n      throw ELEMENT_REF_EXCEPTION;\n    }\n    const classListToApply = sanitize(originalMethod.apply(this));\n    const elementRef = self.elementRef.apply(this);\n    const nativeElement = elementRef?.nativeElement;\n    if (nativeElement) {\n      if (!nativeElement._classMap) {\n        nativeElement._classMap = {};\n      }\n      if (!self._uuidv4) {\n        self._uuidv4 = uuidv4();\n      }\n      const currentClassList = Array.from(nativeElement.classList);\n      const previousClassListToApply = nativeElement._classMap[self._uuidv4] || [];\n      const newClassList = createComponentClassList(currentClassList, previousClassListToApply, classListToApply);\n      nativeElement.className = newClassList.join(' ');\n      nativeElement._classMap[self._uuidv4] = classListToApply;\n    }\n    return classListToApply;\n  };\n}\n/** Filter list to unique items */\nfunction unique(value, index, list) {\n  return list.indexOf(value) === index;\n}\n/** Splits merged classes, removes falsy elements and leaves only unique items */\nfunction sanitize(array) {\n  return array.filter(Boolean).reduce((classList, cssClass) => [...classList, ...cssClass.split(/\\s+/)], []).filter(unique);\n}\nfunction firstCommonElementIndex(array1, array2) {\n  return array1.findIndex(element => array2.indexOf(element) !== -1);\n}\n/** Create set of component classes based on previous set and new set */\nfunction createComponentClassList(allClasses, previousComponentClassList, newComponentClassList) {\n  allClasses = allClasses.slice();\n  let index = firstCommonElementIndex(allClasses, previousComponentClassList);\n  index = index === -1 ? 0 : index;\n  allClasses.splice(index, previousComponentClassList.length, ...newComponentClassList);\n  return allClasses;\n}\n\n/**\n * Method decorator to apply css styles to a component through native element\n * decorator will store original method in variable and wrap it with custom one\n * component has to implement HasElementRef or CssStyleBuilder interface\n * more info abour method decorator: https://www.typescriptlang.org/docs/handbook/decorators.html#method-decorators\n * @param target a component\n * @param propertyKey name of the method\n * @param descriptor method\n */\nfunction applyCssStyle(target, propertyKey, descriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function () {\n    const self = this;\n    if (!self.elementRef) {\n      throw ELEMENT_REF_EXCEPTION;\n    }\n    const _styles = originalMethod.apply(this);\n    if (self.elementRef()) {\n      const htmlElement = self.elementRef().nativeElement;\n      Object.keys(_styles).forEach(key => {\n        htmlElement.style[key] = _styles[key];\n      });\n    }\n    return _styles;\n  };\n}\nconst coerceCssPixel = alternateSetter(coerceCssPixelValue);\nclass DynamicComponentContainer {\n  /** @hidden */\n  constructor(_elementRef, _injector, _cdr) {\n    this._elementRef = _elementRef;\n    this._injector = _injector;\n    this._cdr = _cdr;\n    /** @hidden */\n    this.childContent = undefined;\n    /** @hidden */\n    this._contentLoaded$ = new BehaviorSubject(false);\n  }\n  /** @hidden Load received content as component */\n  _createFromComponent(content) {\n    this.portalOutlet?.attachedRef?.destroy();\n    const injector = Injector.create({\n      parent: this._injector,\n      providers: []\n    });\n    this._componentRef = this.portalOutlet.attach(new ComponentPortal(content, null, injector));\n    this._cdr.markForCheck();\n  }\n  /** @hidden Load received content as embedded view */\n  _createFromTemplate(content, context) {\n    this.portalOutlet?.attachedRef?.destroy();\n    this._componentRef = this.portalOutlet.attach(new TemplatePortal(content, null, context));\n    this._cdr.markForCheck();\n  }\n}\nclass DynamicComponentInjector {\n  /** @hidden */\n  constructor(_parentInjector, _additionalTokens) {\n    this._parentInjector = _parentInjector;\n    this._additionalTokens = _additionalTokens;\n  }\n  /**\n   *\n   * @param token\n   * @param notFoundValue\n   */\n  get(token, notFoundValue) {\n    const value = this._additionalTokens.get(token);\n    if (value) {\n      return value;\n    }\n    return this._parentInjector.get(token, notFoundValue);\n  }\n}\n\n/**\n * Service used to dynamically generate components like dialogs/alerts/notifications\n */\nlet DynamicComponentService = /*#__PURE__*/(() => {\n  class DynamicComponentService {\n    /** @hidden */\n    constructor(_componentFactoryResolver, _applicationRef, _injector, _compiler) {\n      this._componentFactoryResolver = _componentFactoryResolver;\n      this._applicationRef = _applicationRef;\n      this._injector = _injector;\n      this._compiler = _compiler;\n    }\n    /**\n     * Function that creates dynamic component and injects services to allow communication between component and outside\n     * @param content Type of the component content\n     * @param componentType Type of component that should be rendered.\n     * @param config Configuration that will be passed to the component.\n     * @param inject  enables to provide preconfigured component injector and dependencies\n     */\n    createDynamicComponent(content, componentType, config, inject = {}) {\n      const {\n        injector,\n        services\n      } = inject;\n      const dependenciesMap = this._createDependencyMap(services);\n      const componentRef = this._createComponent(componentType, dependenciesMap, injector);\n      this._passExternalContent(componentRef, content);\n      this._attachToContainer(componentRef, config);\n      return componentRef;\n    }\n    /**\n     * Function that creates dynamic component and injects services to allow communication between component and outside\n     * @param content Type of the component content\n     * @param moduleType Type of module that should be compiled.\n     * @param componentType Type of component that should be rendered.\n     * @param containerRef The container that the dynamic component is appended to.\n     * @param injector enables to provide preconfigured component injector\n     */\n    createDynamicModule(content, moduleType, componentType, containerRef, injector) {\n      var _this3 = this;\n      return _asyncToGenerator(function* () {\n        const moduleFactory = moduleType instanceof NgModuleFactory ? moduleType : yield _this3._compiler.compileModuleAsync(moduleType);\n        const moduleRef = moduleFactory.create(injector || _this3._injector);\n        const componentFactory = moduleRef.componentFactoryResolver.resolveComponentFactory(componentType);\n        containerRef.clear();\n        const componentRef = containerRef.createComponent(componentFactory);\n        _this3._passExternalContent(componentRef, content);\n        return componentRef;\n      })();\n    }\n    /** Function that destroys dynamic component */\n    destroyComponent(componentRef) {\n      this._applicationRef.detachView(componentRef.hostView);\n      componentRef.destroy();\n    }\n    /** @hidden */\n    _createDependencyMap(services = []) {\n      const dependencyMap = new WeakMap();\n      services.filter(service => !!service).forEach(service => dependencyMap.set(service.constructor, service));\n      return dependencyMap;\n    }\n    /** @hidden */\n    _attachToContainer(componentRef, config) {\n      const configObj = Object.assign({}, config);\n      const componentEl = componentRef.hostView.rootNodes[0];\n      if (configObj.container !== 'body') {\n        configObj.container?.appendChild(componentEl);\n      } else {\n        document.body.appendChild(componentEl);\n      }\n    }\n    /** @hidden */\n    _createComponent(componentType, dependenciesMap, injector) {\n      const dynamicComponentInjector = new DynamicComponentInjector(injector || this._injector, dependenciesMap);\n      const componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentType);\n      const componentRef = componentFactory.create(dynamicComponentInjector);\n      this._applicationRef.attachView(componentRef.hostView);\n      return componentRef;\n    }\n    /** @hidden */\n    _passExternalContent(componentRef, content) {\n      // TODO: this approach should be revisited, it can cause issues, that is really hard to debug\n      if (Object.prototype.hasOwnProperty.call(componentRef.instance, 'childContent')) {\n        componentRef.instance.childContent = content;\n      }\n    }\n  }\n  DynamicComponentService.ɵfac = function DynamicComponentService_Factory(t) {\n    return new (t || DynamicComponentService)(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i0.Compiler));\n  };\n  DynamicComponentService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: DynamicComponentService,\n    factory: DynamicComponentService.ɵfac\n  });\n  return DynamicComponentService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst LIST_ITEM_COMPONENT = new InjectionToken('ListItemComponent');\n\n/*\n This abstract class allows the user to set their own custom styles on a Fundamental Library for Angular directive, in addition to the\n styles the library needs to add itself.\n When library styles were added through the directive's host: {'[class]'} property, any styles the user added would be\n overwritten.  By extending this class, we instead add library styles to the user's classList rather than replace them.\n */\n/** @hidden */\nlet AbstractFdNgxClass = /*#__PURE__*/(() => {\n  class AbstractFdNgxClass {\n    /** @hidden */\n    _setClassToElement(className) {\n      this._elementRef.nativeElement.classList.value = `${className} ${this.class}`;\n    }\n    /** @hidden */\n    _clearElementClass() {\n      this._elementRef.nativeElement.classList.value = '';\n    }\n    /** @hidden */\n    _addClassToElement(className) {\n      this._elementRef.nativeElement.classList.add(...className.split(' '));\n    }\n    /** @hidden */\n    _addStyleToElement(attribute, value) {\n      this._elementRef.nativeElement.style[attribute] = value;\n    }\n    /** @hidden */\n    constructor(elementRef) {\n      this._elementRef = elementRef;\n      this._setProperties();\n    }\n    /** @hidden */\n    ngOnChanges() {\n      const classList = this._elementRef.nativeElement.classList;\n      while (classList.length > 0) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        classList.remove(classList.item(0));\n      }\n      if (this.class) {\n        this._addClassToElement(this.class);\n      }\n      this._setProperties();\n    }\n    /** @hidden */\n    ngOnInit() {\n      this._setProperties();\n    }\n  }\n  AbstractFdNgxClass.ɵfac = function AbstractFdNgxClass_Factory(t) {\n    return new (t || AbstractFdNgxClass)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  AbstractFdNgxClass.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: AbstractFdNgxClass,\n    inputs: {\n      class: \"class\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return AbstractFdNgxClass;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DisplayFnPipe = /*#__PURE__*/(() => {\n  class DisplayFnPipe {\n    /** Transform value with display function. */\n    transform(value, displayFn, ...args) {\n      return displayFn(value, ...args);\n    }\n  }\n  DisplayFnPipe.ɵfac = function DisplayFnPipe_Factory(t) {\n    return new (t || DisplayFnPipe)();\n  };\n  DisplayFnPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"displayFnPipe\",\n    type: DisplayFnPipe,\n    pure: true,\n    standalone: true\n  });\n  return DisplayFnPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FilterStringsPipe = /*#__PURE__*/(() => {\n  class FilterStringsPipe {\n    /**\n     * Performs filtering.\n     * @param values Array of items.\n     * @param params Search parameters.\n     */\n    transform(values = [], params) {\n      if (!params.searchTerm) {\n        return values;\n      }\n      if (params.key) {\n        values = values.filter(item => item[params.key].toLocaleLowerCase().includes(params.searchTerm?.toLocaleLowerCase()));\n      } else {\n        values = values.filter(item => item.toLocaleLowerCase().includes(params.searchTerm?.toLocaleLowerCase()));\n      }\n      return values;\n    }\n  }\n  FilterStringsPipe.ɵfac = function FilterStringsPipe_Factory(t) {\n    return new (t || FilterStringsPipe)();\n  };\n  FilterStringsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"fdFilterStrings\",\n    type: FilterStringsPipe,\n    pure: true,\n    standalone: true\n  });\n  return FilterStringsPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet IsCompactDensityPipe = /*#__PURE__*/(() => {\n  class IsCompactDensityPipe {\n    /** Check if the content density is compact. */\n    transform(size) {\n      return isCompactDensity(size);\n    }\n  }\n  IsCompactDensityPipe.ɵfac = function IsCompactDensityPipe_Factory(t) {\n    return new (t || IsCompactDensityPipe)();\n  };\n  IsCompactDensityPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"isCompactDensity\",\n    type: IsCompactDensityPipe,\n    pure: true,\n    standalone: true\n  });\n  return IsCompactDensityPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet AsyncOrSyncPipe = /*#__PURE__*/(() => {\n  class AsyncOrSyncPipe {\n    /** @hidden */\n    constructor(ref) {\n      this._cdr = ref;\n      this._asyncPipe = new AsyncPipe(this._cdr);\n    }\n    /**\n     * Transforms raw async-like value into static one.\n     * @param value raw value. Can be either a static value, or Promise-like, or Observable-like.\n     */\n    transform(value) {\n      return !isPromise(value) && !isSubscribable(value) ? value : this._asyncPipe?.transform(value) ?? null;\n    }\n    /** @Hidden */\n    ngOnDestroy() {\n      this._asyncPipe?.ngOnDestroy();\n      this._asyncPipe = null;\n      this._cdr = null;\n    }\n  }\n  AsyncOrSyncPipe.ɵfac = function AsyncOrSyncPipe_Factory(t) {\n    return new (t || AsyncOrSyncPipe)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n  };\n  AsyncOrSyncPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"fdkAsyncOrSync\",\n    type: AsyncOrSyncPipe,\n    pure: false,\n    standalone: true\n  });\n  return AsyncOrSyncPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SearchHighlightPipe = /*#__PURE__*/(() => {\n  class SearchHighlightPipe {\n    /** Highlight search term in string. */\n    transform(value, args, active = true, includeSpans = false) {\n      value = escape(value);\n      let result = value;\n      if (args && value && active) {\n        const testStr = escape(args.trim().toLowerCase());\n        const startIndex = value.toLowerCase().indexOf(testStr);\n        if (startIndex !== -1) {\n          const matchingString = value.substr(startIndex, testStr.length);\n          result = value.replace(matchingString, '<strong>' + matchingString + '</strong>');\n        }\n      }\n      if (includeSpans) {\n        result = '<span>' + result + '</span>';\n      }\n      return result;\n    }\n  }\n  SearchHighlightPipe.ɵfac = function SearchHighlightPipe_Factory(t) {\n    return new (t || SearchHighlightPipe)();\n  };\n  SearchHighlightPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"highlight\",\n    type: SearchHighlightPipe,\n    pure: true,\n    standalone: true\n  });\n  return SearchHighlightPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TwoDigitsPipe = /*#__PURE__*/(() => {\n  class TwoDigitsPipe {\n    /** Transform number to two digits. */\n    transform(value, enable = true) {\n      if ((value || value === 0) && enable) {\n        return value < 10 ? '0' + value : value.toString();\n      } else {\n        return String(value);\n      }\n    }\n  }\n  TwoDigitsPipe.ɵfac = function TwoDigitsPipe_Factory(t) {\n    return new (t || TwoDigitsPipe)();\n  };\n  TwoDigitsPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"twoDigits\",\n    type: TwoDigitsPipe,\n    pure: true,\n    standalone: true\n  });\n  return TwoDigitsPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SafePipe = /*#__PURE__*/(() => {\n  class SafePipe {\n    /** @hidden */\n    constructor(sanitizer) {\n      this.sanitizer = sanitizer;\n    }\n    /** Sanitize HTML string. */\n    transform(value, type) {\n      switch (type) {\n        case 'html':\n          return this.sanitizer.bypassSecurityTrustHtml(value);\n        case 'style':\n          return this.sanitizer.bypassSecurityTrustStyle(value);\n        case 'script':\n          return this.sanitizer.bypassSecurityTrustScript(value);\n        case 'url':\n          return this.sanitizer.bypassSecurityTrustUrl(value);\n        case 'resourceUrl':\n          return this.sanitizer.bypassSecurityTrustResourceUrl(value);\n        default:\n          throw new Error(`Invalid safe type specified: ${type}`);\n      }\n    }\n  }\n  SafePipe.ɵfac = function SafePipe_Factory(t) {\n    return new (t || SafePipe)(i0.ɵɵdirectiveInject(i2.DomSanitizer, 16));\n  };\n  SafePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"safe\",\n    type: SafePipe,\n    pure: true,\n    standalone: true\n  });\n  return SafePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet ValueByPathPipe = /*#__PURE__*/(() => {\n  class ValueByPathPipe {\n    /** Get value by path. */\n    transform(value, key) {\n      return get(value, key);\n    }\n  }\n  ValueByPathPipe.ɵfac = function ValueByPathPipe_Factory(t) {\n    return new (t || ValueByPathPipe)();\n  };\n  ValueByPathPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"valueByPath\",\n    type: ValueByPathPipe,\n    pure: true,\n    standalone: true\n  });\n  return ValueByPathPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet TruncatePipe = /*#__PURE__*/(() => {\n  class TruncatePipe {\n    /** Truncate string to given length. */\n    transform(value, limit = 500) {\n      return value && value.length > limit ? value.substring(0, limit) + '...' : value;\n    }\n  }\n  TruncatePipe.ɵfac = function TruncatePipe_Factory(t) {\n    return new (t || TruncatePipe)();\n  };\n  TruncatePipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"truncate\",\n    type: TruncatePipe,\n    pure: true,\n    standalone: true\n  });\n  return TruncatePipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet MakeAsyncPipe = /*#__PURE__*/(() => {\n  class MakeAsyncPipe {\n    /**\n     * Transforms raw value into observable.\n     * @param value raw value. Can be either a static value, or Promise-like, or Observable-like.\n     */\n    transform(value) {\n      return isPromise(value) || isSubscribable(value) ? value : of(value);\n    }\n  }\n  MakeAsyncPipe.ɵfac = function MakeAsyncPipe_Factory(t) {\n    return new (t || MakeAsyncPipe)();\n  };\n  MakeAsyncPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"fdkMakeAsync\",\n    type: MakeAsyncPipe,\n    pure: true,\n    standalone: true\n  });\n  return MakeAsyncPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet PipeModule = /*#__PURE__*/(() => {\n  class PipeModule {}\n  PipeModule.ɵfac = function PipeModule_Factory(t) {\n    return new (t || PipeModule)();\n  };\n  PipeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: PipeModule\n  });\n  PipeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return PipeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ANY_LANGUAGE_LETTERS_GROUP_REGEX, ANY_LANGUAGE_LETTERS_REGEX, AbstractFdNgxClass, AsyncOrSyncPipe, AttributeObserver, AutoCompleteDirective, AutoCompleteModule, BreakpointDirective, BreakpointModule, ClickedBehaviorModule, ClickedDirective, ContentDensityService, DECIMAL_NUMBER_UNICODE_GROUP_REGEX, DECIMAL_NUMBER_UNICODE_RANGE, DECIMAL_NUMBER_UNICODE_REGEX, DEFAULT_CONTENT_DENSITY, DND_ITEM, DND_LIST, DefaultReadonlyViewModifier, DeprecatedAutoCompleteDirective, DeprecatedClickedDirective, DeprecatedDisabledBehaviorDirective, DeprecatedFocusKeyManagerItemDirective, DeprecatedFocusKeyManagerListDirective, DeprecatedFocusableItemDirective, DeprecatedFocusableListDirective, DeprecatedIgnoreClickOnSelectionDirective, DeprecatedInitialFocusDirective, DeprecatedLineClampDirective, DeprecatedLineClampTargetDirective, DeprecatedOnlyDigitsDirective, DeprecatedOverflowListDirective, DeprecatedOverflowListItemDirective, DeprecatedReadonlyBehaviorDirective, DeprecatedRepeatDirective, DeprecatedResizeDirective, DeprecatedResizeHandleDirective, DeprecatedTemplateSelectorDirective, DeprecatedTruncateSelectorDirective, DestroyedService, DisabledBehaviorDirective, DisabledBehaviorModule, DisabledObserver, DisplayFnPipe, DndItemDirective, DndKeyboardGroupDirective, DndKeyboardItemDirective, DndListDirective, DragAndDropModule, DynamicComponentContainer, DynamicComponentInjector, DynamicComponentService, ELEMENT_REF_EXCEPTION, FDK_DISABLED_DIRECTIVE, FDK_FOCUSABLE_GRID_DIRECTIVE, FDK_FOCUSABLE_ITEM_DIRECTIVE, FDK_FOCUSABLE_LIST_DIRECTIVE, FDK_READONLY_DIRECTIVE, FDK_SELECTABLE_ITEM_PROVIDER, FOCUSABLE_ITEM, FdkClickedProvider, FdkDisabledProvider, FdkReadonlyProvider, FilterStringsPipe, FocusKeyManagerHelpersModule, FocusKeyManagerItemDirective, FocusKeyManagerListDirective, FocusTrapService, FocusableGridDirective, FocusableGridModule, FocusableItemDirective, FocusableItemModule, FocusableListDirective, FocusableListModule, FocusableObserver, INVALID_DATE_ERROR, IgnoreClickOnSelectionDirective, IgnoreClickOnSelectionDirectiveToken, IgnoreClickOnSelectionModule, InitialFocusDirective, InitialFocusModule, IsCompactDensityPipe, KeyUtil, KeyboardSupportService, LETTERS_UNICODE_RANGE, LIST_ITEM_COMPONENT, LineClampDirective, LineClampModule, LineClampTargetDirective, LocalStorageService, MOBILE_CONFIG_ERROR, MakeAsyncPipe, ModuleDeprecations, OVERFLOW_PRIORITY_SCORE, OnlyDigitsDirective, OnlyDigitsModule, OverflowListDirective, OverflowListItemDirective, OverflowListModule, PipeModule, RTL_LANGUAGE, RangeSelector, ReadonlyBehaviorDirective, ReadonlyBehaviorModule, ReadonlyObserver, RepeatDirective, RepeatModule, ResizeDirective, ResizeHandleDirective, ResizeModule, ResizeObserverFactory, ResizeObserverService, RtlService, SafePipe, SearchHighlightPipe, SelectComponentRootToken, SelectableItemDirective, SelectableItemToken, SelectableListDirective, SelectableListModule, SelectionService, THEME_SWITCHER_ROUTER_MISSING_ERROR, TabbableElementService, TemplateDirective, TemplateModule, ThemesService, TruncateDirective, TruncateModule, TruncatePipe, TwoDigitsPipe, UtilsModule, ValueByPathPipe, ViewportSizeObservable, alternateSetter, applyCssClass, applyCssStyle, coerceArraySafe, coerceBoolean, coerceCssPixel, consumerProviderFactory, getDocumentFontSize, getElementCapacity, getElementWidth, getNativeElement, getRandomColorAccent, intersectionObservable, isBlank, isBoolean, isCompactDensity, isFunction, isHasElementRef, isJsObject, isNumber, isObject, isOdd, isPresent, isPromise, isString, isStringMap, isSubscribable, isType, isValidContentDensity, moduleDeprecationsFactory, moduleDeprecationsProvider, parserFileSize, pxToNum, resizeObservable, scrollIntoView, scrollTop, setDisabledState, setReadonlyState, toNativeElement, uuidv4 };\n//# sourceMappingURL=fundamental-ngx-cdk-utils.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}