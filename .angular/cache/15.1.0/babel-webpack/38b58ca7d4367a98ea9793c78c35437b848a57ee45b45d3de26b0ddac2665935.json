{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { forwardRef, Component, ViewEncapsulation, ChangeDetectionStrategy, Input, HostBinding, ContentChildren, HostListener, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FD_BUTTON_COMPONENT } from '@fundamental-ngx/core/button';\nimport { startWith, observeOn, takeUntil, filter, tap } from 'rxjs/operators';\nimport { Subject, asyncScheduler, merge, fromEvent } from 'rxjs';\nimport * as i1 from '@fundamental-ngx/cdk/utils';\nimport { KeyUtil, DestroyedService } from '@fundamental-ngx/cdk/utils';\nimport { ENTER, SPACE } from '@angular/cdk/keycodes';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nconst _c0 = [\"*\"];\nconst isDisabledClass = 'is-disabled';\n/**\n * Container for grouped buttons.\n *\n * ```html\n * <fd-segmented-button [(ngModel)]=\"value\">\n *     <button fd-button value=\"first\">Button</button>\n *     <button fd-button value=\"second\">Button</button>\n *     <button fd-button value=\"third\">Button</button>\n * </fd-segmented-button>\n * ```\n */\nlet SegmentedButtonComponent = /*#__PURE__*/(() => {\n  class SegmentedButtonComponent {\n    /** @hidden */\n    constructor(_changeDetRef, _elementRef, _onDestroy$) {\n      this._changeDetRef = _changeDetRef;\n      this._elementRef = _elementRef;\n      this._onDestroy$ = _onDestroy$;\n      /** Whether segmented button is on toggle mode, which allows to toggle more than 1 button */\n      this.toggle = false;\n      /** @hidden */\n      this._fdSegmentedButtonClass = true;\n      /** @hidden */\n      this._isDisabled = false;\n      /** An RxJS Subject that will kill the data stream upon queryList changes (for unsubscribing)  */\n      this._onRefresh$ = new Subject();\n      /** @hidden */\n      this.onChange = () => {};\n      /** @hidden */\n      this.onTouched = () => {};\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._listenToButtonChanges();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onRefresh$.complete();\n    }\n    /** @hidden */\n    writeValue(values) {\n      this._currentValue = values;\n      this._pickButtonsByValues(values);\n    }\n    /**\n     * @hidden\n     * @param fn User defined function that handles the *onChange* event of the SegmentedButtons.\n     */\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /**\n     * @hidden\n     * @param fn User defined function that handles the *onTouch* event of the SegmentedButtons.\n     */\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /**\n     * @hidden\n     * @param isDisabled Sets the value of the *disabled* property of the SegmentedButtons.\n     */\n    setDisabledState(isDisabled) {\n      this._isDisabled = isDisabled;\n      this._toggleDisableButtons(isDisabled);\n      this._changeDetRef.detectChanges();\n    }\n    /** @hidden */\n    _click(event) {\n      if (!this._elementRef.nativeElement.contains(event.relatedTarget)) {\n        this.onTouched();\n      }\n    }\n    /** @hidden */\n    _listenToButtonChanges() {\n      this._buttons.changes.pipe(startWith(1), observeOn(asyncScheduler), takeUntil(this._onDestroy$)).subscribe(() => {\n        this._onRefresh$.next();\n        this._toggleDisableButtons(this._isDisabled);\n        this._pickButtonsByValues(this._currentValue);\n        this._buttons.forEach(button => this._listenToTriggerEvents(button));\n      });\n    }\n    /** @hidden */\n    _listenToTriggerEvents(buttonComponent) {\n      const htmlElement = buttonComponent.elementRef().nativeElement;\n      const refresh$ = merge(this._onDestroy$, this._onRefresh$);\n      const triggerEvents$ = merge(fromEvent(htmlElement, 'click'), fromEvent(htmlElement, 'keydown').pipe(filter(event => KeyUtil.isKeyCode(event, [ENTER, SPACE])), tap(event => {\n        event.preventDefault();\n        this.onTouched();\n      })));\n      triggerEvents$.pipe(takeUntil(refresh$)).subscribe(() => this._handleTriggerOnButton(buttonComponent));\n    }\n    /** @hidden */\n    _handleTriggerOnButton(buttonComponent) {\n      if (!this._isButtonDisabled(buttonComponent)) {\n        if (!this._isButtonSelected(buttonComponent) && !this.toggle) {\n          this._buttons.forEach(button => this._deselectButton(button));\n          this._selectButton(buttonComponent);\n          this._propagateChange();\n          this._changeDetRef.markForCheck();\n        }\n        if (this.toggle) {\n          this._toggleButton(buttonComponent);\n          this._propagateChange();\n          this._changeDetRef.markForCheck();\n        }\n      }\n    }\n    /** @hidden */\n    _propagateChange() {\n      this.onChange(this._getValuesBySelected());\n      this._currentValue = this._getValuesBySelected();\n    }\n    /** @hidden */\n    _toggleButton(buttonComponent) {\n      if (this._isButtonSelected(buttonComponent)) {\n        this._deselectButton(buttonComponent);\n      } else {\n        this._selectButton(buttonComponent);\n      }\n    }\n    /** @hidden */\n    _pickButtonsByValues(values) {\n      if (!this._buttons) {\n        return;\n      }\n      this._buttons.forEach(button => this._deselectButton(button));\n      this._getButtonsByValues(values).forEach(button => this._selectButton(button));\n      this._changeDetRef.detectChanges();\n    }\n    /** @hidden */\n    _getButtonsByValues(values) {\n      if (!values) {\n        return [];\n      }\n      if (Array.isArray(values)) {\n        return this._buttons.filter(button => !!values.find(value => this._getButtonValue(button) === value));\n      } else {\n        return this._buttons.filter(button => this._getButtonValue(button) === values);\n      }\n    }\n    /** @hidden */\n    _selectButton(buttonComponent) {\n      buttonComponent.toggled = true;\n    }\n    /** @hidden */\n    _deselectButton(buttonComponent) {\n      buttonComponent.toggled = false;\n    }\n    /** @hidden */\n    _isButtonSelected(buttonComponent) {\n      return buttonComponent.toggled;\n    }\n    /** @hidden */\n    _isButtonDisabled(buttonComponent) {\n      return buttonComponent._disabled || buttonComponent.ariaDisabled;\n    }\n    /** @hidden */\n    _toggleDisableButtons(disable) {\n      if (!this._buttons) {\n        return;\n      }\n      this._buttons.forEach(button => button.disabled = disable);\n      if (disable) {\n        this._buttons.forEach(button => button.elementRef().nativeElement.setAttribute('disabled', 'true'));\n      }\n      this._changeDetRef.markForCheck();\n    }\n    /** @hidden */\n    _getButtonValue(buttonComponent) {\n      const element = buttonComponent.elementRef().nativeElement;\n      if (element instanceof HTMLButtonElement) {\n        return element.value;\n      }\n      return element.getAttribute('value');\n    }\n    /** @hidden\n     * Returns values depending on selected state of buttons\n     */\n    _getValuesBySelected() {\n      if (!this._buttons) {\n        return [];\n      }\n      const resButtons = this._buttons.filter(button => this._isButtonSelected(button)).map(button => this._getButtonValue(button));\n      if (!this.toggle) {\n        return resButtons.length === 1 ? resButtons[0] : null;\n      } else {\n        return resButtons;\n      }\n    }\n  }\n  SegmentedButtonComponent.ɵfac = function SegmentedButtonComponent_Factory(t) {\n    return new (t || SegmentedButtonComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1.DestroyedService));\n  };\n  SegmentedButtonComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: SegmentedButtonComponent,\n    selectors: [[\"fd-segmented-button\"]],\n    contentQueries: function SegmentedButtonComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, FD_BUTTON_COMPONENT, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._buttons = _t);\n      }\n    },\n    hostAttrs: [\"role\", \"group\"],\n    hostVars: 2,\n    hostBindings: function SegmentedButtonComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function SegmentedButtonComponent_click_HostBindingHandler($event) {\n          return ctx._click($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"fd-segmented-button\", ctx._fdSegmentedButtonClass);\n      }\n    },\n    inputs: {\n      toggle: \"toggle\"\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => SegmentedButtonComponent),\n      multi: true\n    }, DestroyedService])],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function SegmentedButtonComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    styles: [\"/*!\\n * Fundamental Library Styles v0.28.3\\n * Copyright (c) 2023 SAP SE or an SAP affiliate company.\\n * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/main/LICENSE)\\n *//*!\\n.fd-segmented-button\\n    button\\n*/.fd-segmented-button{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);display:inline-flex;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;padding:0;position:relative;vertical-align:middle}.fd-segmented-button:after,.fd-segmented-button:before{box-sizing:inherit;font-size:inherit}.fd-segmented-button:before{background:var(--sapButton_Background);border-radius:var(--sapButton_BorderCornerRadius);content:\\\"\\\";display:var(--fdButton_Segmented_Pad_Display);height:100%;left:0;position:absolute;top:0;width:100%}.fd-segmented-button button{margin:0}.fd-segmented-button button.is-hover,.fd-segmented-button button:hover{z-index:1}.fd-segmented-button button:first-child{border-radius:var(--fdButton_Border_Radius_Left)}.fd-segmented-button button:not(:first-child):not(:last-child){border-radius:var(--fdButton_Segmented_Middle_Border_Radius)}.fd-segmented-button button:last-child{border-radius:var(--fdButton_Border_Radius_Right)}.fd-segmented-button button:not(:last-child){margin-right:var(--fdButton_Segmented_Border_Offset)}.fd-segmented-button button:not(:last-child)[dir=rtl],[dir=rtl] .fd-segmented-button button:not(:last-child){margin-left:var(--fdButton_Segmented_Border_Offset);margin-right:0}.fd-segmented-button button[dir=rtl]:first-child,[dir=rtl] .fd-segmented-button button:first-child{border-radius:var(--fdButton_Border_Radius_Left_RTL)}.fd-segmented-button button[dir=rtl]:last-child,[dir=rtl] .fd-segmented-button button:last-child{border-radius:var(--fdButton_Border_Radius_Right_RTL)}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return SegmentedButtonComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet SegmentedButtonModule = /*#__PURE__*/(() => {\n  class SegmentedButtonModule {}\n  SegmentedButtonModule.ɵfac = function SegmentedButtonModule_Factory(t) {\n    return new (t || SegmentedButtonModule)();\n  };\n  SegmentedButtonModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: SegmentedButtonModule\n  });\n  SegmentedButtonModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return SegmentedButtonModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { SegmentedButtonComponent, SegmentedButtonModule, isDisabledClass };\n//# sourceMappingURL=fundamental-ngx-core-segmented-button.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}