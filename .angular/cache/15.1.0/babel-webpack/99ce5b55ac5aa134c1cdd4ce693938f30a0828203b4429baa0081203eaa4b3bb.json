{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, LOCALE_ID, Injectable, Optional, Inject, Pipe, NgModule } from '@angular/core';\nimport { Subject } from 'rxjs';\nimport { INVALID_DATE_ERROR, LETTERS_UNICODE_RANGE } from '@fundamental-ngx/cdk/utils';\nimport * as i1 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport { CommonModule } from '@angular/common';\n\n/**\n * DateTimeFormats injection token\n */\nconst DATE_TIME_FORMATS = new InjectionToken('date-formats');\n\n/**\n * Datetime Adapter is an abstract class that must be implemented by each adapter.\n * It's used to encapsulate a date/time manipulations as result\n * others places that uses it remain date type agnostic.\n *\n */\nclass DatetimeAdapter {\n  constructor() {\n    /** @hidden */\n    this._localeChanges = new Subject();\n    /** locale changes stream */\n    this.localeChanges = this._localeChanges.asObservable();\n  }\n  /**\n   * Sets the locale used for all dates.\n   * @param locale The new locale.\n   */\n  setLocale(locale) {\n    this.locale = locale;\n    this._localeChanges.next();\n  }\n  /**\n   * Set hours, minutes and seconds at once.\n   * @param date The date to set time to.\n   * @returns The new date instance.\n   */\n  setTime(date, hours, minutes, seconds) {\n    date = this.setHours(date, hours);\n    date = this.setMinutes(date, minutes);\n    date = this.setSeconds(date, seconds);\n    return date;\n  }\n  /**\n   * Get Amount of weeks in given month/year\n   * @param year The year of the date\n   * @param month The month of the date\n   * @param firstDayOfWeek The first day of week. 1 - Sunday, 2 - Monday...\n   * @returns Number of weeks in the given month\n   */\n  getAmountOfWeeks(year, month, firstDayOfWeek) {\n    const firstOfMonth = new Date(year, month - 1, 1);\n    const lastOfMonth = new Date(year, month, 0);\n    const dayOffset = (firstOfMonth.getDay() - firstDayOfWeek + 8) % 7;\n    const used = dayOffset + lastOfMonth.getDate();\n    return Math.ceil(used / 7);\n  }\n  /**\n   * Compares two dates.\n   * @param first The first date to compare.\n   * @param second The second date to compare.\n   * @returns 0 if the dates are equal, a number less than 0 if the first date is earlier,\n   *     a number greater than 0 if the first date is later.\n   */\n  compareDate(first, second) {\n    return this.getYear(first) - this.getYear(second) || this.getMonth(first) - this.getMonth(second) || this.getDate(first) - this.getDate(second) || this.getHours(first) - this.getHours(second) || this.getMinutes(first) - this.getMinutes(second) || this.getSeconds(first) - this.getSeconds(second);\n  }\n}\n\n/** Generate range of given lengths using given function. */\nfunction range(length, mapFn) {\n  return Array.from(new Array(length)).map((_, index) => mapFn(index));\n}\n/** Adds 0 if number is less then 10 */\nfunction _leftPad(n) {\n  return n === n % 10 ? `0${n}` : `${n}`;\n}\n/** Converts date to ISO8601 */\nfunction toIso8601(fdDate) {\n  return [[fdDate.year, _leftPad(fdDate.month), _leftPad(fdDate.day)].join('-'), 'T', [_leftPad(fdDate.hour), _leftPad(fdDate.minute), _leftPad(fdDate.second)].join(':')].join('');\n}\n/**\n * @param year e.g. 2020\n * @param month 1 = January, 12 = December\n * @param day 1 - 31\n * @param hour 0 - 23\n * @param minute 0 - 59\n * @param second 0 - 59\n */\nfunction isValidByParams(params) {\n  const {\n    year,\n    month,\n    day,\n    hour,\n    minute,\n    second\n  } = params;\n  if (!undefinedOrInRange(month, 1, 12) || !undefinedOrInRange(day, 1, 31) || !undefinedOrInRange(hour, 0, 23) || !undefinedOrInRange(minute, 0, 59) || !undefinedOrInRange(second, 0, 59)) {\n    return false;\n  }\n  if (!isNaN(year) && !isNaN(month) && day != null && !isNaN(day)) {\n    const tempDate = new Date(year, month - 1, day);\n    if (tempDate.getMonth() + 1 !== month) {\n      return false;\n    }\n  }\n  const date = new Date(year, month - 1, day, hour, minute, second);\n  return !Number.isNaN(date.getTime());\n}\nfunction undefinedOrInRange(value, from, to) {\n  return value == null || value >= from && value <= to;\n}\n\n/**\n * FdDate class is used to represent date and time.\n *\n * It's a simplified analog of native Date instance.\n * It gives some convenience methods to work with date or time data.\n *\n */\nclass FdDate {\n  /**\n   * Create FdDate instance of the current moment\n   */\n  static getNow() {\n    return FdDate.getFdDateByDate(new Date());\n  }\n  /**\n   * Gets today's FdDate where hour, minute and second is set to 0\n   */\n  static getToday() {\n    return FdDate.getNow().setTime(0, 0, 0);\n  }\n  /**\n   *  Convert js date object to FdDate model\n   */\n  static getFdDateByDate(date) {\n    return new FdDate(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());\n  }\n  /** Create a date object */\n  constructor(...args) {\n    if (args.length === 0) {\n      return FdDate.getNow();\n    }\n    let [year, month = 1, day = 1, hour = 0, minute = 0, second = 0] = args;\n    year = Number.parseInt(year, 10);\n    month = Number.parseInt(month, 10);\n    day = Number.parseInt(day, 10);\n    hour = Number.parseInt(hour, 10);\n    minute = Number.parseInt(minute, 10);\n    second = Number.parseInt(second, 10);\n    this._isValid = isValidByParams({\n      year,\n      month,\n      day,\n      hour,\n      minute,\n      second\n    });\n    this.year = this._isValid ? year : NaN;\n    this.month = this._isValid ? month : NaN;\n    this.day = this._isValid ? day : NaN;\n    this.hour = this._isValid ? hour : NaN;\n    this.minute = this._isValid ? minute : NaN;\n    this.second = this._isValid ? second : NaN;\n    return this;\n  }\n  /**\n   * Set hour, minute and second data\n   * @param hour\n   * @param minute\n   * @param second\n   */\n  setTime(hour, minute, second) {\n    this._isValid = isValidByParams({\n      year: this.year,\n      month: this.month,\n      day: this.day,\n      hour,\n      minute,\n      second\n    });\n    if (!this._isValid) {\n      this.hour = NaN;\n      this.minute = NaN;\n      this.second = NaN;\n    } else {\n      this.hour = hour || hour === 0 ? hour : this.hour;\n      this.minute = minute || minute === 0 ? minute : this.minute;\n      this.second = second || second === 0 ? second : this.second;\n    }\n    return this;\n  }\n  /**\n   * Get amount of milliseconds from 01.01.1970\n   */\n  getTimeStamp() {\n    return this.toDate().getTime();\n  }\n  /**\n   * Get number of weekday ex. Sunday = 1, Monday = 2, Tuesday = 3 etc.\n   */\n  getDayOfWeek() {\n    return this.toDate().getDay() + 1;\n  }\n  /**\n   * Get native date object from FdDate.\n   */\n  toDate() {\n    // We have stricter validation rules than Date object.\n    // For example, Date allows values for month=100 or for day=100.\n    // Therefore, we need to do this trick for the consistency of the validation status\n    if (!this.isDateValid()) {\n      return new Date(NaN);\n    }\n    return new Date(this.year, this.month - 1, this.day, this.hour, this.minute, this.second);\n  }\n  /**\n   * Method that checks validity of current FdDate instance.\n   */\n  isDateValid() {\n    return this instanceof FdDate && this._isValid;\n  }\n  /**\n   * Get string representation in yyyy-mm-ddThh:mm:ss format\n   */\n  toString() {\n    if (!this.isDateValid()) {\n      return INVALID_DATE_ERROR;\n    }\n    if (!this.year || !this.month || !this.day) {\n      return '';\n    }\n    return toIso8601(this);\n  }\n  /**\n   * The valueOf() method returns the primitive value of a FdDate.\n   * Returns: The number of milliseconds between 1 January 1970 00:00:00 UTC and the given date.\n   */\n  valueOf() {\n    return this.getTimeStamp();\n  }\n  /**\n   * Get date string in yyyy-mm-dd format\n   */\n  toDateString() {\n    if (!this.isDateValid()) {\n      return INVALID_DATE_ERROR;\n    }\n    if (!this.year || !this.month || !this.day) {\n      return '';\n    }\n    return toIso8601(this).split('T')[0];\n  }\n  /**\n   * Get time string in hh:mm:ss format\n   */\n  toTimeString() {\n    if (!this.isDateValid()) {\n      return INVALID_DATE_ERROR;\n    }\n    if (!this.year || !this.month || !this.day) {\n      return '';\n    }\n    return toIso8601(this).split('T')[1];\n  }\n}\nconst dateInput = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric'\n};\nconst timeInput = {\n  hour: 'numeric',\n  minute: '2-digit'\n};\nconst dateTimeInput = {\n  year: 'numeric',\n  month: 'numeric',\n  day: 'numeric',\n  hour: 'numeric',\n  minute: '2-digit'\n};\nconst FD_DATETIME_FORMATS = {\n  parse: {\n    dateInput,\n    timeInput,\n    dateTimeInput\n  },\n  display: {\n    dateInput,\n    timeInput,\n    dateTimeInput,\n    dateA11yLabel: {\n      year: 'numeric',\n      month: 'long',\n      day: 'numeric'\n    },\n    monthA11yLabel: {\n      month: 'long',\n      year: 'numeric'\n    },\n    yearA11yLabel: {\n      year: 'numeric'\n    }\n  },\n  rangeDelimiter: ' - '\n};\nconst AM_DAY_PERIOD_DEFAULT = 'AM';\nconst PM_DAY_PERIOD_DEFAULT = 'PM';\n/**\n * DatetimeAdapter implementation based on FdDate.\n *\n * This uses FdDate as a date model and relies on Intl.DateTimeFormat\n * for formatting and translation purposes.\n *\n */\nlet FdDatetimeAdapter = /*#__PURE__*/(() => {\n  class FdDatetimeAdapter extends DatetimeAdapter {\n    /** @hidden */\n    constructor(localeId, platform) {\n      super();\n      super.setLocale(localeId);\n      this._fixYearsRangeIssue = platform.TRIDENT || platform.EDGE;\n    }\n    /** Get year */\n    getYear(date) {\n      return date.year;\n    }\n    /** Get month */\n    getMonth(date) {\n      return date.month;\n    }\n    /** Get date */\n    getDate(date) {\n      return date.day;\n    }\n    /** Get day of week */\n    getDayOfWeek(date) {\n      return this._createDateInstanceByFdDate(date).getDay() + 1;\n    }\n    /** Get hours */\n    getHours(date) {\n      return date.hour;\n    }\n    /** Get minutes */\n    getMinutes(date) {\n      return date.minute;\n    }\n    /** Get seconds */\n    getSeconds(date) {\n      return date.second;\n    }\n    /** Get week number */\n    getWeekNumber(fdDate) {\n      const date = this._createDateInstanceByFdDate(fdDate);\n      date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);\n      // January 4 is always in week 1.\n      const firstWeek = new Date(date.getFullYear(), 0, 4);\n      // Adjust to Thursday in week 1 and count number of weeks from date to week1.\n      return 1 + Math.round(((date.getTime() - firstWeek.getTime()) / 86400000 - 3 + (firstWeek.getDay() + 6) % 7) / 7);\n    }\n    /** Get month names */\n    getMonthNames(style) {\n      const dateTimeFormat = new Intl.DateTimeFormat(this.locale, {\n        month: style,\n        timeZone: 'utc'\n      });\n      return range(12, i => this._stripDirectionalityCharacters(this._format(dateTimeFormat, new Date(2017, i, 1))));\n    }\n    /** Get date names */\n    getDateNames() {\n      const dateTimeFormat = new Intl.DateTimeFormat(this.locale, {\n        day: 'numeric',\n        timeZone: 'utc'\n      });\n      return range(31, i => this._stripDirectionalityCharacters(this._format(dateTimeFormat, new Date(2017, 0, i + 1))));\n    }\n    /** Get day of week names */\n    getDayOfWeekNames(style) {\n      const dateTimeFormat = new Intl.DateTimeFormat(this.locale, {\n        weekday: style,\n        timeZone: 'utc'\n      });\n      return range(7, i => this._stripDirectionalityCharacters(this._format(dateTimeFormat, new Date(2017, 0, i + 1))));\n    }\n    /** Get year name */\n    getYearName(date) {\n      const dateTimeFormat = new Intl.DateTimeFormat(this.locale, {\n        year: 'numeric',\n        timeZone: 'utc'\n      });\n      const dateInstance = this._createDateInstanceByFdDate(date);\n      return this._stripDirectionalityCharacters(this._format(dateTimeFormat, dateInstance));\n    }\n    /** Get week name */\n    getWeekName(date) {\n      const weekNumber = this.getWeekNumber(date);\n      return weekNumber.toLocaleString(this.locale);\n    }\n    /** Get hour names */\n    getHourNames({\n      meridian,\n      twoDigit\n    }) {\n      return range(24, hour => {\n        if (meridian) {\n          hour = hour === 0 || hour === 12 ? 12 : hour % 12;\n        }\n        return hour.toLocaleString(this.locale, {\n          minimumIntegerDigits: twoDigit ? 2 : 1\n        });\n      });\n    }\n    /** Get minute names */\n    getMinuteNames({\n      twoDigit\n    }) {\n      return range(60, minute => minute.toLocaleString(this.locale, {\n        minimumIntegerDigits: twoDigit ? 2 : 1\n      }));\n    }\n    /** Get second names */\n    getSecondNames({\n      twoDigit\n    }) {\n      return range(60, second => second.toLocaleString(this.locale, {\n        minimumIntegerDigits: twoDigit ? 2 : 1\n      }));\n    }\n    /** Get day period names */\n    getDayPeriodNames() {\n      const DEFAULT_PERIODS = [AM_DAY_PERIOD_DEFAULT, PM_DAY_PERIOD_DEFAULT];\n      const formatter = new Intl.DateTimeFormat(this.locale, {\n        hour: 'numeric',\n        minute: 'numeric',\n        hour12: true\n      });\n      try {\n        const am = formatter.formatToParts(new Date(2020, 0, 1, 6)).find(({\n          type\n        }) => type === 'dayPeriod')?.value;\n        const pm = formatter.formatToParts(new Date(2020, 0, 1, 16)).find(({\n          type\n        }) => type === 'dayPeriod')?.value;\n        return am && pm ? [am, pm] : DEFAULT_PERIODS;\n      } catch (e) {\n        const dayPeriodRegexp = new RegExp(`(${LETTERS_UNICODE_RANGE}+\\\\.*)+`, 'g');\n        const amRegExpMatch = formatter.format(new Date(2020, 0, 1, 6)).match(dayPeriodRegexp);\n        const pmRegExpMatch = formatter.format(new Date(2020, 0, 1, 16)).match(dayPeriodRegexp);\n        return amRegExpMatch && pmRegExpMatch ? [amRegExpMatch[0], pmRegExpMatch[0]] : [AM_DAY_PERIOD_DEFAULT, PM_DAY_PERIOD_DEFAULT];\n      }\n    }\n    /** Set hours */\n    setHours(date, hours) {\n      const dateInstance = this._createDateInstanceByFdDate(date);\n      dateInstance.setHours(hours);\n      return this._createFdDateFromDateInstance(dateInstance);\n    }\n    /** Set minutes */\n    setMinutes(date, hours) {\n      const dateInstance = this._createDateInstanceByFdDate(date);\n      dateInstance.setMinutes(hours);\n      return this._createFdDateFromDateInstance(dateInstance);\n    }\n    /** Set seconds */\n    setSeconds(date, hours) {\n      const dateInstance = this._createDateInstanceByFdDate(date);\n      dateInstance.setSeconds(hours);\n      return this._createFdDateFromDateInstance(dateInstance);\n    }\n    /** Get first day of week */\n    getFirstDayOfWeek() {\n      // can't retrieve this info from Intl object or Date object, default to Sunday.\n      return 0;\n    }\n    /** Get number of days in a month */\n    getNumDaysInMonth(fdDate) {\n      const date = this._createDateInstanceByFdDate(fdDate);\n      date.setMonth(date.getMonth() + 1);\n      date.setDate(0);\n      return date.getDate();\n    }\n    /** Create a date object */\n    createDate(year, month = 1, date = 1) {\n      return new FdDate(year, month, date);\n    }\n    /** Get a today date object */\n    today() {\n      return FdDate.getToday();\n    }\n    /** Get a now date object */\n    now() {\n      return FdDate.getNow();\n    }\n    /** Parse any value to date object */\n    parse(value, parseFormat = {}) {\n      if (!value && value !== 0) {\n        return null;\n      }\n      if (value instanceof FdDate) {\n        return this.clone(value);\n      }\n      /**\n       * We have no way using the native JS Date to set the parse format or locale,\n       * so we ignore these parameters.\n       */\n      let date = new Date(Date.parse(value));\n      if (typeof value === 'number') {\n        date = new Date(value);\n      }\n      // Check if we are dealing with a time string\n      if (Number.isNaN(date.valueOf()) && typeof value === 'string' && !parseFormat.year && !parseFormat.day && !parseFormat.month && parseFormat.hour) {\n        date = this._parseTimeString(value);\n      }\n      return this._createFdDateFromDateInstance(date);\n    }\n    /** Format date object to string */\n    format(date, displayFormat) {\n      if (!this.isValid(date)) {\n        return INVALID_DATE_ERROR;\n      }\n      // On IE and Edge the i18n API will throw a hard error that can crash the entire app\n      // if we attempt to format a date whose year is less than 1 or greater than 9999.\n      if (this._fixYearsRangeIssue && (date.year < 1 || date.year > 9999)) {\n        date = this.clone(date);\n        date.year = Math.max(1, Math.min(9999, date.year));\n      }\n      displayFormat = {\n        ...displayFormat,\n        timeZone: 'utc'\n      };\n      const dateTimeFormatter = new Intl.DateTimeFormat(this.locale, displayFormat);\n      const dateInstance = this._createDateInstanceByFdDate(date);\n      return this._stripDirectionalityCharacters(this._format(dateTimeFormatter, dateInstance));\n    }\n    /** Add years to a date */\n    addCalendarYears(date, years) {\n      return this.addCalendarMonths(date, years * 12);\n    }\n    /** Add months to a date */\n    addCalendarMonths(fdDate, months) {\n      const date = this._createDateInstanceByFdDate(fdDate);\n      date.setMonth(date.getMonth() + months);\n      // It's possible to wind up in the wrong month if the original month has more days than the new\n      // month. In this case we want to go to the last day of the desired month.\n      if (date.getDate() !== fdDate.day) {\n        date.setDate(0);\n      }\n      return this._createFdDateFromDateInstance(date);\n    }\n    /** Add days to a date */\n    addCalendarDays(fdDate, days) {\n      const date = this._createDateInstanceByFdDate(fdDate);\n      date.setDate(date.getDate() + days);\n      return this._createFdDateFromDateInstance(date);\n    }\n    /** Clone a date object */\n    clone(date) {\n      return new FdDate(date.year, date.month, date.day, date.hour, date.minute, date.second);\n    }\n    /** Check if date object is valid */\n    isValid(date) {\n      if (!(date instanceof FdDate)) {\n        return false;\n      }\n      return date.isDateValid();\n    }\n    /** Check if date between given dates */\n    isBetween(dateToCheck, startDate, endDate) {\n      const date = this._createDateInstanceByFdDate(dateToCheck);\n      const start = this._createDateInstanceByFdDate(startDate);\n      const end = this._createDateInstanceByFdDate(endDate);\n      return date.getTime() > start.getTime() && date.getTime() < end.getTime();\n    }\n    /** Check if dates are equal */\n    datesEqual(date1, date2) {\n      if (!date1 || !date2) {\n        return false;\n      }\n      // skip time value\n      const date1Str = this.toIso8601(date1).split('T')[0];\n      const date2Str = this.toIso8601(date2).split('T')[0];\n      return date1Str === date2Str;\n    }\n    /** Check if dates and time are equal */\n    dateTimesEqual(date1, date2) {\n      if (!date1 || !date2) {\n        return false;\n      }\n      return this.toIso8601(date1) === this.toIso8601(date2);\n    }\n    /** Format date object to ISO8601 string */\n    toIso8601(fdDate) {\n      return toIso8601(fdDate);\n    }\n    /** Check if a time format includes a day period */\n    isTimeFormatIncludesDayPeriod(displayFormat) {\n      if (typeof displayFormat?.hour12 === 'boolean') {\n        return displayFormat.hour12;\n      }\n      const formattedDateNoPeriodOption = this.format(this.createDate(2020), displayFormat);\n      const formattedDateWithPeriodOption = this.format(this.createDate(2020), {\n        ...displayFormat,\n        hour12: true\n      });\n      return formattedDateWithPeriodOption === formattedDateNoPeriodOption;\n    }\n    /** Check if a time format includes hours */\n    isTimeFormatIncludesHours(displayFormat) {\n      return typeof displayFormat?.hour === 'string';\n    }\n    /** Check if a time format includes minutes */\n    isTimeFormatIncludesMinutes(displayFormat) {\n      return typeof displayFormat?.minute === 'string';\n    }\n    /** Check if a time format includes seconds */\n    isTimeFormatIncludesSeconds(displayFormat) {\n      return typeof displayFormat?.second === 'string';\n    }\n    /**\n     * @hidden\n     * Strip out unicode LTR and RTL characters. Edge and IE insert these into formatted dates while\n     * other browsers do not. We remove them to make output consistent and because they interfere with\n     * date parsing.\n     * @param str The string to strip direction characters from.\n     * @returns The stripped string.\n     */\n    _stripDirectionalityCharacters(str) {\n      return str.replace(/[\\u200e\\u200f]/g, '').replace(/\\u202f/g, ' ');\n    }\n    /** @hidden */\n    _format(formatter, date) {\n      if (Number.isNaN(date.valueOf())) {\n        return INVALID_DATE_ERROR;\n      }\n      date = this._createUTCDateInstance(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds());\n      return formatter.format(date);\n    }\n    /**\n     * @hidden\n     * Create native Date instance from FdDate\n     * @param date FdDate instance\n     * @returns date Native date instance\n     */\n    _createDateInstanceByFdDate(fdDate) {\n      const {\n        year,\n        month,\n        day,\n        hour,\n        minute,\n        second\n      } = fdDate;\n      // We have stricter validation rules than Date object.\n      // For example, Date allows values for month=100 or for day=100.\n      // Therefore, we need to do this trick for the consistency of the validation status\n      if (!this.isValid(fdDate)) {\n        return new Date(NaN);\n      }\n      const date = new Date();\n      date.setFullYear(year, month - 1, day);\n      date.setHours(hour, minute, second, 0);\n      return date;\n    }\n    /**\n     * @hidden\n     * Create native Date instance in UTC\n     * @param year The year\n     * @param month The month as a number between 0 and 11\n     * @param day The date as a number between 1 and 31.\n     * @param hours The hours as a number between 0 - 24\n     * @param minutes The minutes as a number between 0 - 59\n     * @param seconds The seconds as a number between 0 - 59\n     * @param milliseconds The milliseconds as a number between 0 - 59\n     */\n    _createUTCDateInstance(year, month, day, hours = 0, minutes = 0, seconds = 0, milliseconds = 0) {\n      const utcDate = new Date();\n      utcDate.setUTCFullYear(year, month, day);\n      utcDate.setUTCHours(hours, minutes, seconds, milliseconds);\n      return utcDate;\n    }\n    /** @hidden */\n    _createFdDateFromDateInstance(date) {\n      return new FdDate(date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());\n    }\n    /**\n     * @hidden\n     *\n     * Since FdDatetimeAdapter can parse only \"en-US\" locale\n     * there is no reason to create comprehensive time parse\n     * that can understand plenty of locales.\n     *\n     * @param timeStr Time string to parse (E.g. '10:30 PM')\n     * @returns date Native date instance\n     *\n     */\n    _parseTimeString(timeStr) {\n      /**\n       * Date.parse('10:30 AM') doesn't work so we need do a trick\n       * and prepend it by a date string.\n       */\n      const dateStr = this.format(this.now(), {\n        year: 'numeric',\n        month: 'numeric',\n        day: 'numeric'\n      });\n      const dateTimeString = `${dateStr} ${timeStr}`;\n      return new Date(Date.parse(dateTimeString));\n    }\n  }\n  FdDatetimeAdapter.ɵfac = function FdDatetimeAdapter_Factory(t) {\n    return new (t || FdDatetimeAdapter)(i0.ɵɵinject(LOCALE_ID, 8), i0.ɵɵinject(i1.Platform));\n  };\n  FdDatetimeAdapter.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: FdDatetimeAdapter,\n    factory: FdDatetimeAdapter.ɵfac\n  });\n  return FdDatetimeAdapter;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DateFormatPipe = /*#__PURE__*/(() => {\n  class DateFormatPipe {\n    /** @hidden */\n    constructor(_dateTimeAdapter, _dateTimeFormats) {\n      this._dateTimeAdapter = _dateTimeAdapter;\n      this._dateTimeFormats = _dateTimeFormats;\n    }\n    /** Format date object */\n    transform(date, noDateMessage = '') {\n      if (date) {\n        return this._dateTimeAdapter.format(date, this._dateTimeFormats.display.dateInput);\n      } else {\n        return noDateMessage;\n      }\n    }\n  }\n  DateFormatPipe.ɵfac = function DateFormatPipe_Factory(t) {\n    return new (t || DateFormatPipe)(i0.ɵɵdirectiveInject(DatetimeAdapter, 16), i0.ɵɵdirectiveInject(DATE_TIME_FORMATS, 24));\n  };\n  DateFormatPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"dateFormat\",\n    type: DateFormatPipe,\n    pure: true\n  });\n  return DateFormatPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DateTimeFormatPipe = /*#__PURE__*/(() => {\n  class DateTimeFormatPipe {\n    /** @hidden */\n    constructor(_dateTimeAdapter, _dateTimeFormats) {\n      this._dateTimeAdapter = _dateTimeAdapter;\n      this._dateTimeFormats = _dateTimeFormats;\n    }\n    /** Format date object */\n    transform(date, noDateMessage = '') {\n      if (date) {\n        return this._dateTimeAdapter.format(date, this._dateTimeFormats.display.dateTimeInput);\n      } else {\n        return noDateMessage;\n      }\n    }\n  }\n  DateTimeFormatPipe.ɵfac = function DateTimeFormatPipe_Factory(t) {\n    return new (t || DateTimeFormatPipe)(i0.ɵɵdirectiveInject(DatetimeAdapter, 16), i0.ɵɵdirectiveInject(DATE_TIME_FORMATS, 24));\n  };\n  DateTimeFormatPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"dateTimeFormat\",\n    type: DateTimeFormatPipe,\n    pure: true\n  });\n  return DateTimeFormatPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DateFromNowPipe = /*#__PURE__*/(() => {\n  class DateFromNowPipe {\n    /** @hidden */\n    constructor(_dateTimeAdapter) {\n      this._dateTimeAdapter = _dateTimeAdapter;\n    }\n    /** Format date object */\n    transform(date, noDateMessage = '') {\n      if (this._dateTimeAdapter.fromNow && typeof this._dateTimeAdapter.fromNow === 'function') {\n        if (date) {\n          return this._dateTimeAdapter.fromNow(date);\n        } else {\n          return noDateMessage;\n        }\n      } else {\n        console.warn('No fromNow function provided to the DatetimeAdapter');\n        return '';\n      }\n    }\n  }\n  DateFromNowPipe.ɵfac = function DateFromNowPipe_Factory(t) {\n    return new (t || DateFromNowPipe)(i0.ɵɵdirectiveInject(DatetimeAdapter, 16));\n  };\n  DateFromNowPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n    name: \"dateFromNow\",\n    type: DateFromNowPipe,\n    pure: true\n  });\n  return DateFromNowPipe;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst PIPES = [DateFormatPipe, DateTimeFormatPipe, DateFromNowPipe];\nlet FdDatetimePipesModule = /*#__PURE__*/(() => {\n  class FdDatetimePipesModule {}\n  FdDatetimePipesModule.ɵfac = function FdDatetimePipesModule_Factory(t) {\n    return new (t || FdDatetimePipesModule)();\n  };\n  FdDatetimePipesModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FdDatetimePipesModule\n  });\n  FdDatetimePipesModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [CommonModule]\n  });\n  return FdDatetimePipesModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FdDatetimeAdapterModule = /*#__PURE__*/(() => {\n  class FdDatetimeAdapterModule {}\n  FdDatetimeAdapterModule.ɵfac = function FdDatetimeAdapterModule_Factory(t) {\n    return new (t || FdDatetimeAdapterModule)();\n  };\n  FdDatetimeAdapterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FdDatetimeAdapterModule\n  });\n  FdDatetimeAdapterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: DatetimeAdapter,\n      useClass: FdDatetimeAdapter\n    }],\n    imports: [PlatformModule]\n  });\n  return FdDatetimeAdapterModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FdDatetimeModule = /*#__PURE__*/(() => {\n  class FdDatetimeModule {}\n  FdDatetimeModule.ɵfac = function FdDatetimeModule_Factory(t) {\n    return new (t || FdDatetimeModule)();\n  };\n  FdDatetimeModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FdDatetimeModule\n  });\n  FdDatetimeModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [{\n      provide: DATE_TIME_FORMATS,\n      useValue: FD_DATETIME_FORMATS\n    }],\n    imports: [FdDatetimeAdapterModule, FdDatetimePipesModule, FdDatetimePipesModule]\n  });\n  return FdDatetimeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DATE_TIME_FORMATS, DateFormatPipe, DateFromNowPipe, DateTimeFormatPipe, DatetimeAdapter, FD_DATETIME_FORMATS, FdDate, FdDatetimeAdapter, FdDatetimeAdapterModule, FdDatetimeModule, FdDatetimePipesModule, _leftPad, isValidByParams, range, toIso8601 };\n//# sourceMappingURL=fundamental-ngx-core-datetime.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}