{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Directive, Input, HostBinding, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, HostListener, EventEmitter, Output, ContentChild, Inject, ContentChildren, forwardRef, ViewChild, NgModule } from '@angular/core';\nimport * as i5 from 'rxjs';\nimport { Subject, of, Subscription, combineLatest, startWith } from 'rxjs';\nimport { map, takeUntil, filter } from 'rxjs/operators';\nimport * as i2 from '@fundamental-ngx/cdk/utils';\nimport { KeyUtil } from '@fundamental-ngx/cdk/utils';\nimport * as i3 from '@fundamental-ngx/core/icon';\nimport { IconComponent, IconModule } from '@fundamental-ngx/core/icon';\nimport * as i1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i1$1 from '@fundamental-ngx/core/menu';\nimport { MenuKeyboardService } from '@fundamental-ngx/core/menu';\nimport { RIGHT_ARROW, LEFT_ARROW, ENTER, SPACE } from '@angular/cdk/keycodes';\nimport { TranslationResolver, FD_LANGUAGE } from '@fundamental-ngx/i18n';\nimport * as i4 from '@fundamental-ngx/core/content-density';\nimport { contentDensityObserverProviders, DeprecatedCompactDirective, CONTENT_DENSITY_DIRECTIVE, ContentDensityModule } from '@fundamental-ngx/core/content-density';\nimport * as i4$1 from '@fundamental-ngx/core/popover';\nimport { PopoverComponent, PopoverModule } from '@fundamental-ngx/core/popover';\nimport * as i2$1 from '@angular/router';\nimport { RouterModule } from '@angular/router';\nconst _c0 = [\"fdNestedDirectivesIcon\", \"\"];\nconst _c1 = [\"*\"];\nconst _c2 = [\"fdNestedListExpandIcon\", \"\"];\nconst _c3 = [[[\"\", \"fd-nested-list-link\", \"\"]], [[\"\", \"fd-nested-list-content\", \"\"]], [[\"\", \"fd-nested-list\", \"\"]], [[\"fd-prepared-nested-list\"]]];\nconst _c4 = function () {\n  return [\"click\"];\n};\nconst _c5 = [\"[fd-nested-list-link]\", \"[fd-nested-list-content]\", \"[fd-nested-list]\", \"fd-prepared-nested-list\"];\nfunction PreparedNestedListComponent_ng_container_1_li_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"li\", 4);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", item_r1.headerTitle, \" \");\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_li_2_fd_nested_list_popover_1_fd_prepared_nested_list_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"fd-prepared-nested-list\", 14);\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext(3).$implicit;\n    i0.ɵɵproperty(\"first\", false)(\"list\", item_r1.list);\n  }\n}\nconst _c6 = function (a0) {\n  return {\n    item: a0\n  };\n};\nfunction PreparedNestedListComponent_ng_container_1_li_2_fd_nested_list_popover_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"fd-nested-list-popover\", 9)(1, \"div\", 10);\n    i0.ɵɵelementContainer(2, 11);\n    i0.ɵɵelement(3, \"button\", 12);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, PreparedNestedListComponent_ng_container_1_li_2_fd_nested_list_popover_1_fd_prepared_nested_list_4_Template, 1, 2, \"fd-prepared-nested-list\", 13);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r8 = i0.ɵɵreference(5);\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵproperty(\"title\", (item_r1.link == null ? null : item_r1.link.title) || \"\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"selected\", !!(item_r1.link == null ? null : item_r1.link.selected));\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(5, _c6, item_r1));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", item_r1.list);\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_li_2_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementContainer(1, 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r8 = i0.ɵɵreference(5);\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(2, _c6, item_r1));\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_li_2_ng_container_3_fd_prepared_nested_list_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"fd-prepared-nested-list\", 14);\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext(3).$implicit;\n    i0.ɵɵproperty(\"first\", false)(\"list\", item_r1.list);\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_li_2_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 15);\n    i0.ɵɵelementContainer(2, 11);\n    i0.ɵɵelement(3, \"button\", 12);\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(4, PreparedNestedListComponent_ng_container_1_li_2_ng_container_3_fd_prepared_nested_list_4_Template, 1, 2, \"fd-prepared-nested-list\", 13);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r8 = i0.ɵɵreference(5);\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8)(\"ngTemplateOutletContext\", i0.ɵɵpureFunction1(3, _c6, item_r1));\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", item_r1.list);\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_li_2_ng_template_4_a_0_span_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 20);\n  }\n  if (rf & 2) {\n    const item_r17 = i0.ɵɵnextContext(2).item;\n    i0.ɵɵproperty(\"glyph\", item_r17.link.icon);\n  }\n}\nconst _c7 = function () {\n  return [];\n};\nfunction PreparedNestedListComponent_ng_container_1_li_2_ng_template_4_a_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r23 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"a\", 17);\n    i0.ɵɵlistener(\"selectedChange\", function PreparedNestedListComponent_ng_container_1_li_2_ng_template_4_a_0_Template_a_selectedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r23);\n      const item_r17 = i0.ɵɵnextContext().item;\n      return i0.ɵɵresetView(!item_r17.list && (item_r17.link.selected = $event));\n    });\n    i0.ɵɵtemplate(1, PreparedNestedListComponent_ng_container_1_li_2_ng_template_4_a_0_span_1_Template, 1, 1, \"span\", 18);\n    i0.ɵɵelementStart(2, \"span\", 19);\n    i0.ɵɵtext(3);\n    i0.ɵɵelementEnd()();\n  }\n  if (rf & 2) {\n    const item_r17 = i0.ɵɵnextContext().item;\n    i0.ɵɵproperty(\"onClickCallback\", item_r17.link.callback)(\"selected\", !item_r17.list && item_r17.link.selected)(\"routerLink\", item_r17.link.routerLink ? item_r17.link.routerLink : i0.ɵɵpureFunction0(6, _c7));\n    i0.ɵɵattribute(\"href\", item_r17.link.href ? item_r17.link.href : null, i0.ɵɵsanitizeUrl);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r17.link.icon);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate(item_r17.link.title);\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_li_2_ng_template_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, PreparedNestedListComponent_ng_container_1_li_2_ng_template_4_a_0_Template, 4, 7, \"a\", 16);\n  }\n  if (rf & 2) {\n    const item_r17 = ctx.item;\n    i0.ɵɵproperty(\"ngIf\", item_r17.link);\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_li_2_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r27 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"li\", 5);\n    i0.ɵɵlistener(\"expandedChange\", function PreparedNestedListComponent_ng_container_1_li_2_Template_li_expandedChange_0_listener($event) {\n      i0.ɵɵrestoreView(_r27);\n      const item_r1 = i0.ɵɵnextContext().$implicit;\n      const ctx_r25 = i0.ɵɵnextContext();\n      return i0.ɵɵresetView(ctx_r25._expandedChange($event, item_r1));\n    });\n    i0.ɵɵtemplate(1, PreparedNestedListComponent_ng_container_1_li_2_fd_nested_list_popover_1_Template, 5, 7, \"fd-nested-list-popover\", 6);\n    i0.ɵɵtemplate(2, PreparedNestedListComponent_ng_container_1_li_2_ng_container_2_Template, 2, 4, \"ng-container\", 7);\n    i0.ɵɵtemplate(3, PreparedNestedListComponent_ng_container_1_li_2_ng_container_3_Template, 5, 5, \"ng-container\", 7);\n    i0.ɵɵtemplate(4, PreparedNestedListComponent_ng_container_1_li_2_ng_template_4_Template, 1, 1, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const item_r1 = i0.ɵɵnextContext().$implicit;\n    const ctx_r3 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"expanded\", !!item_r1.expanded);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r3.condensed && ctx_r3.first && item_r1.list);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r1.list);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", (!ctx_r3.condensed || !ctx_r3.first) && item_r1.list);\n  }\n}\nfunction PreparedNestedListComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, PreparedNestedListComponent_ng_container_1_li_1_Template, 2, 1, \"li\", 2);\n    i0.ɵɵtemplate(2, PreparedNestedListComponent_ng_container_1_li_2_Template, 6, 4, \"li\", 3);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", item_r1.headerTitle);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !item_r1.headerTitle);\n  }\n}\nlet NestedListStateService = /*#__PURE__*/(() => {\n  class NestedListStateService {\n    constructor() {\n      /**\n       * @hidden\n       * The condensed state is modified by the parent and read by nested lists.\n       */\n      this.condensed = false;\n      /**\n       * @hidden\n       */\n      this.selectable = true;\n      /** @hidden */\n      this.onSelected = new Subject();\n    }\n  }\n  NestedListStateService.ɵfac = function NestedListStateService_Factory(t) {\n    return new (t || NestedListStateService)();\n  };\n  NestedListStateService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NestedListStateService,\n    factory: NestedListStateService.ɵfac\n  });\n  return NestedListStateService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/** Contains references to popover or list nested components, that are placed as direct children of item component */\nclass NestedItemService {\n  constructor() {\n    /** Subject fired when expand icon is clicked */\n    this.toggle = new Subject();\n    /** Subject fired, when child elements are focused */\n    this.focus = new Subject();\n    /** Subject fired, when content or link is clicked */\n    this.click = new Subject();\n    /** KeyDown handler, it is triggered from link, content and item elements */\n    this.keyDown = new Subject();\n  }\n}\nlet uniqueId = 0;\nlet NestedListHeaderDirective = /*#__PURE__*/(() => {\n  class NestedListHeaderDirective {\n    /** @hidden */\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n      /** Id of the element. */\n      this.id = `fd-nested-list-group-header-${++uniqueId}`;\n      /** @hidden */\n      this.fdNestedListHeaderClass = true;\n    }\n    /** Get the header title */\n    get title() {\n      return this._elementRef.nativeElement.textContent;\n    }\n  }\n  NestedListHeaderDirective.ɵfac = function NestedListHeaderDirective_Factory(t) {\n    return new (t || NestedListHeaderDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  NestedListHeaderDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NestedListHeaderDirective,\n    selectors: [[\"\", \"fdNestedDirectivesHeader\", \"\"], [\"\", \"fd-nested-list-header\", \"\"]],\n    hostVars: 3,\n    hostBindings: function NestedListHeaderDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵclassProp(\"fd-nested-list__group-header\", ctx.fdNestedListHeaderClass);\n      }\n    },\n    inputs: {\n      id: \"id\"\n    }\n  });\n  return NestedListHeaderDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedListIconComponent = /*#__PURE__*/(() => {\n  class NestedListIconComponent extends IconComponent {\n    constructor() {\n      super(...arguments);\n      /** Role attribute */\n      this.role = 'presentation';\n      /** @hidden */\n      this.fdNestedListIconClass = true;\n    }\n  }\n  NestedListIconComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵNestedListIconComponent_BaseFactory;\n    return function NestedListIconComponent_Factory(t) {\n      return (ɵNestedListIconComponent_BaseFactory || (ɵNestedListIconComponent_BaseFactory = i0.ɵɵgetInheritedFactory(NestedListIconComponent)))(t || NestedListIconComponent);\n    };\n  }();\n  NestedListIconComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NestedListIconComponent,\n    selectors: [[\"\", \"fdNestedDirectivesIcon\", \"\"], [\"\", \"fd-nested-list-icon\", \"\"]],\n    hostVars: 3,\n    hostBindings: function NestedListIconComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"fd-nested-list__icon\", ctx.fdNestedListIconClass);\n      }\n    },\n    inputs: {\n      role: \"role\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    attrs: _c0,\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function NestedListIconComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2\n  });\n  return NestedListIconComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedListTitleDirective = /*#__PURE__*/(() => {\n  class NestedListTitleDirective {\n    /** @hidden */\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n      /** @hidden */\n      this.fdNestedListTitleClass = true;\n    }\n    /** Returns element's InnerText */\n    getInnerText() {\n      return this.elementRef && this.elementRef.nativeElement.textContent;\n    }\n  }\n  NestedListTitleDirective.ɵfac = function NestedListTitleDirective_Factory(t) {\n    return new (t || NestedListTitleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  NestedListTitleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NestedListTitleDirective,\n    selectors: [[\"\", \"fdNestedDirectivesTitle\", \"\"], [\"\", \"fd-nested-list-title\", \"\"]],\n    hostVars: 2,\n    hostBindings: function NestedListTitleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"fd-nested-list__title\", ctx.fdNestedListTitleClass);\n      }\n    }\n  });\n  return NestedListTitleDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedListExpandIconComponent = /*#__PURE__*/(() => {\n  class NestedListExpandIconComponent {\n    /** @hidden */\n    constructor(_itemService, _changeDetRef, _rtlService) {\n      this._itemService = _itemService;\n      this._changeDetRef = _changeDetRef;\n      this._rtlService = _rtlService;\n      /** @hidden */\n      this.fdNestedListTitleClass = true;\n      /** @hidden */\n      this.fdButtonClass = true;\n      /**\n       * @hidden\n       * Attribute controlled by the parent `NestedItemDirective`\n       */\n      this.expanded = false;\n      /** @hidden */\n      this.ariaHidden = true;\n      this._listenOnTextDirection();\n    }\n    /** Mouse event handler */\n    onClick(event) {\n      this.expanded = !this.expanded;\n      this._itemService.toggle.next(this.expanded);\n      event.stopPropagation();\n    }\n    /** Handler for focus events */\n    onFocus() {\n      this._itemService.focus.next();\n    }\n    /** @hidden */\n    changeExpandedState(expanded) {\n      this.expanded = expanded;\n      this._changeDetRef.detectChanges();\n    }\n    /** @hidden Sets expand arrow depending on text direction */\n    _listenOnTextDirection() {\n      this.sideArrowIcon$ = this._rtlService ? this._rtlService.rtl.pipe(map(isRtl => isRtl ? 'navigation-left-arrow' : 'navigation-right-arrow')) : of('navigation-right-arrow');\n    }\n  }\n  NestedListExpandIconComponent.ɵfac = function NestedListExpandIconComponent_Factory(t) {\n    return new (t || NestedListExpandIconComponent)(i0.ɵɵdirectiveInject(NestedItemService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i2.RtlService, 8));\n  };\n  NestedListExpandIconComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NestedListExpandIconComponent,\n    selectors: [[\"\", \"fdNestedListExpandIcon\", \"\"], [\"\", \"fd-nested-list-expand-icon\", \"\"]],\n    hostAttrs: [\"aria-haspopup\", \"true\", \"tabindex\", \"-1\"],\n    hostVars: 8,\n    hostBindings: function NestedListExpandIconComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function NestedListExpandIconComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"focus\", function NestedListExpandIconComponent_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-expanded\", ctx.expanded)(\"aria-hidden\", ctx.ariaHidden);\n        i0.ɵɵclassProp(\"fd-nested-list__button\", ctx.fdNestedListTitleClass)(\"fd-button\", ctx.fdButtonClass)(\"is-expanded\", ctx.expanded);\n      }\n    },\n    attrs: _c2,\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 3,\n    consts: [[3, \"glyph\"]],\n    template: function NestedListExpandIconComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n        i0.ɵɵelement(1, \"fd-icon\", 0);\n        i0.ɵɵpipe(2, \"async\");\n      }\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"glyph\", ctx.expanded ? \"navigation-down-arrow\" : i0.ɵɵpipeBind1(2, 1, ctx.sideArrowIcon$));\n      }\n    },\n    dependencies: [i3.IconComponent, i1.AsyncPipe],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NestedListExpandIconComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedLinkDirective = /*#__PURE__*/(() => {\n  class NestedLinkDirective {\n    /** @hidden */\n    constructor(changeDetRef, _renderer, _elementRef, _itemService) {\n      this.changeDetRef = changeDetRef;\n      this._renderer = _renderer;\n      this._elementRef = _elementRef;\n      this._itemService = _itemService;\n      /** Whether this element is selected*/\n      this.selected = false;\n      /** Event thrown, when selected state is changed */\n      this.selectedChange = new EventEmitter();\n      /** @hidden */\n      this.fdNestedListItemClass = true;\n      /** @hidden */\n      this.tabIndex = 0;\n      /** @hidden */\n      this.role = 'treeitem';\n    }\n    /** Handler for keyboard events */\n    onKeyDown(event) {\n      this._itemService.keyDown.next(event);\n    }\n    /** Handler for mouse events */\n    onClick() {\n      this._itemService.click.next();\n      if (this.onClickCallback) {\n        this.onClickCallback();\n      }\n    }\n    /** Handler for focus events */\n    onFocus() {\n      this._itemService.focus.next();\n    }\n    /** Method to trigger selected state change */\n    changeSelected(selected) {\n      this.selected = selected;\n      this.selectedChange.emit(selected);\n    }\n    /** Set focus on the element. */\n    focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /** Dispatches the click event on the element */\n    click() {\n      this._elementRef.nativeElement.click();\n    }\n    /** Returns the title value of the title directive */\n    getTitle() {\n      return this.title && this.title.getInnerText();\n    }\n  }\n  NestedLinkDirective.ɵfac = function NestedLinkDirective_Factory(t) {\n    return new (t || NestedLinkDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NestedItemService));\n  };\n  NestedLinkDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NestedLinkDirective,\n    selectors: [[\"\", \"fdNestedLink\", \"\"], [\"\", \"fd-nested-list-link\", \"\"]],\n    contentQueries: function NestedLinkDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NestedListTitleDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.title = _t.first);\n      }\n    },\n    hostVars: 8,\n    hostBindings: function NestedLinkDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function NestedLinkDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        })(\"click\", function NestedLinkDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        })(\"focus\", function NestedLinkDirective_focus_HostBindingHandler() {\n          return ctx.onFocus();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-label\", ctx._ariaLabel)(\"aria-describedby\", ctx.ariaDescribedby)(\"tabindex\", ctx.tabIndex)(\"role\", ctx.role);\n        i0.ɵɵclassProp(\"is-selected\", ctx.selected)(\"fd-nested-list__link\", ctx.fdNestedListItemClass);\n      }\n    },\n    inputs: {\n      onClickCallback: \"onClickCallback\",\n      selected: \"selected\",\n      ariaDescribedby: \"ariaDescribedby\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\"\n    }\n  });\n  return NestedLinkDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Nested list keyboard service, which uses MenuKeyboardService, to deal with ArrowUp, ArrowDown, Space, Enter.\n * Also has own handling of ArrowLeft and ArrowRight, to open/close the menu if it has any children.\n */\nlet NestedListKeyboardService = /*#__PURE__*/(() => {\n  class NestedListKeyboardService {\n    /** @hidden */\n    constructor(keyboardService) {\n      this.keyboardService = keyboardService;\n      /**\n       * Event, that is thrown always, when the open/close i being called on item components.\n       * Also triggers changing of elements, to remove closed/hidden elements\n       */\n      this.refresh$ = new Subject();\n    }\n    /**\n     * Function called after refresh$ event is triggered.\n     * Refresh the list of NestedItems, that the keyboard support should be provided for\n     */\n    refreshItems(lists) {\n      const items = [];\n      /** Gathering all of the items */\n      lists.forEach(list => items.push(...this._getAllListItems(list)));\n      /** Putting the keyboard support function to each of the items */\n      items.forEach((item, index) => {\n        item.keyboardTriggered.pipe(takeUntil(this.refresh$)).subscribe(keyboardEvent => this._handleKeyDown(keyboardEvent, index, items));\n      });\n    }\n    /** Recursive function to get all of the NestedItem elements in correct order. */\n    _getItems(item) {\n      const childrenItems = item.expanded ? item.allChildrenItems : [];\n      return childrenItems.reduce((actualArray, nextItem) => [...actualArray, ...this._getItems(nextItem)], [item]);\n    }\n    /** Method that calls the recursive function, getItems() and gathers all of the items in the NestedList */\n    _getAllListItems(list) {\n      const _items = [];\n      if (list && list.nestedItems && list.nestedItems.length > 0) {\n        list.nestedItems.forEach(item => {\n          _items.push(...this._getItems(item));\n        });\n      }\n      return _items;\n    }\n    /**\n     * Keyboard handle function. Uses keyboard support service from MenuComponent, to deal with ArrowUp, ArrowDown, Space, Enter.\n     * For ArrowRight, if item is not expanded and has children (list or popup), the open function is triggered.\n     * Otherwise it follows ArrowDown functionality.\n     * For ArrowLeft, if item is expanded and has children (list or popup), the close function is triggered.\n     * Otherwise it follows ArrowUp functionality\n     */\n    _handleKeyDown(keyboardEvent, index, items) {\n      const item = items[index];\n      if (KeyUtil.isKeyCode(keyboardEvent, RIGHT_ARROW)) {\n        if (!item.expanded && item.hasChildren) {\n          item.triggerOpen();\n        }\n        keyboardEvent.preventDefault();\n      }\n      if (KeyUtil.isKeyCode(keyboardEvent, LEFT_ARROW)) {\n        if (item.expanded && item.hasChildren) {\n          item.triggerClose();\n        }\n        keyboardEvent.preventDefault();\n      }\n      if (KeyUtil.isKeyCode(keyboardEvent, [ENTER, SPACE])) {\n        if (item.hasChildren) {\n          items[index].click();\n        }\n        keyboardEvent.preventDefault();\n      }\n      this.keyboardService.keyDownHandler(keyboardEvent, index, items);\n    }\n  }\n  NestedListKeyboardService.ɵfac = function NestedListKeyboardService_Factory(t) {\n    return new (t || NestedListKeyboardService)(i0.ɵɵinject(MenuKeyboardService));\n  };\n  NestedListKeyboardService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NestedListKeyboardService,\n    factory: NestedListKeyboardService.ɵfac\n  });\n  return NestedListKeyboardService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedListContentDirective = /*#__PURE__*/(() => {\n  class NestedListContentDirective {\n    /** @hidden */\n    constructor(changeDetRef, _renderer, _elementRef, _itemService) {\n      this.changeDetRef = changeDetRef;\n      this._renderer = _renderer;\n      this._elementRef = _elementRef;\n      this._itemService = _itemService;\n      /** Whether this element is selected*/\n      this.selected = false;\n      /** @hidden */\n      this.role = 'treeitem';\n      /** @hidden */\n      this.ariaExpanded = false;\n      /** Event thrown, when selected state is changed */\n      this.selectedChange = new EventEmitter();\n      /** Event that is thrown, when any keyboard event is dispatched on this element */\n      this.keyboardTriggered = new EventEmitter();\n      /** Event that is thrown, when this element is clicked */\n      this.clicked = new EventEmitter();\n      /** @hidden */\n      this.fdNestedListContentClass = true;\n      /**\n       * @hidden\n       * Attribute controlled by the parent `NestedItemDirective`\n       */\n      this.hasChildren = false;\n      /** An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)  */\n      this.onDestroy$ = new Subject();\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      this._makeLinkUnFocusable();\n      this._setFocusSubscription();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this.onDestroy$.next();\n      this.onDestroy$.complete();\n    }\n    /** Keyboard Event Handler */\n    onKeyDown(event) {\n      this.keyboardTriggered.emit(event);\n      this._itemService.keyDown.next(event);\n    }\n    /** Handler for mouse events */\n    onClick() {\n      this._itemService.click.next();\n    }\n    /** Method to trigger selected state change */\n    changeSelected(selected) {\n      this.selected = selected;\n      this.selectedChange.emit(selected);\n    }\n    /** Expanded state change propagation method */\n    changeExpandedState(expanded) {\n      if (this.nestedExpandIcon) {\n        this.nestedExpandIcon.changeExpandedState(expanded);\n      }\n    }\n    /** Set focus on the element. */\n    focus() {\n      this._elementRef.nativeElement.focus();\n    }\n    /** Dispatches the click event on the element */\n    click() {\n      this.focus();\n      if (this.nestedLink) {\n        this.nestedLink.click();\n      }\n    }\n    /** Add subscription for child focusing */\n    _setFocusSubscription() {\n      this._itemService.focus.pipe(takeUntil(this.onDestroy$)).subscribe(() => this.focus());\n    }\n    /** Hide link child element from tab key */\n    _makeLinkUnFocusable() {\n      if (this.nestedLink) {\n        this.nestedLink.tabIndex = -1;\n        this.changeDetRef.detectChanges();\n      }\n    }\n  }\n  NestedListContentDirective.ɵfac = function NestedListContentDirective_Factory(t) {\n    return new (t || NestedListContentDirective)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NestedItemService));\n  };\n  NestedListContentDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NestedListContentDirective,\n    selectors: [[\"\", \"fdNestedListContent\", \"\"], [\"\", \"fd-nested-list-content\", \"\"]],\n    contentQueries: function NestedListContentDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NestedLinkDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NestedListExpandIconComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nestedLink = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nestedExpandIcon = _t.first);\n      }\n    },\n    hostAttrs: [\"tabindex\", \"0\"],\n    hostVars: 8,\n    hostBindings: function NestedListContentDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown\", function NestedListContentDirective_keydown_HostBindingHandler($event) {\n          return ctx.onKeyDown($event);\n        })(\"click\", function NestedListContentDirective_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"role\", ctx.role)(\"aria-expanded\", ctx.ariaExpanded);\n        i0.ɵɵclassProp(\"is-selected\", ctx.selected)(\"fd-nested-list__content\", ctx.fdNestedListContentClass)(\"has-child\", ctx.hasChildren);\n      }\n    },\n    inputs: {\n      selected: \"selected\"\n    },\n    outputs: {\n      selectedChange: \"selectedChange\",\n      keyboardTriggered: \"keyboardTriggered\",\n      clicked: \"clicked\"\n    }\n  });\n  return NestedListContentDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet sideNavigationItemUniqueId = 0;\nlet NestedItemDirective = /*#__PURE__*/(() => {\n  class NestedItemDirective {\n    /** Whether item should be expanded */\n    set expanded(expanded) {\n      if (expanded !== this._expanded) {\n        this.propagateOpenChange(expanded);\n      }\n    }\n    /** @hidden */\n    get expanded() {\n      return this._expanded;\n    }\n    /** @hidden */\n    constructor(_itemService, _keyboardService, _stateService) {\n      this._itemService = _itemService;\n      this._keyboardService = _keyboardService;\n      this._stateService = _stateService;\n      /** Event thrown, when expanded state is changed */\n      this.expandedChange = new EventEmitter();\n      /** Event thrown, when any keyboard event is dispatched on this, or link element */\n      this.keyboardTriggered = new EventEmitter();\n      /** @hidden */\n      this.fdNestedListItemClass = true;\n      /** @hidden */\n      this._ariaLevel = null;\n      /** @hidden */\n      this._expanded = false;\n      /** @hidden */\n      this._ariaExpanded = null;\n      /** @hidden */\n      this._ariaSelected = null;\n      /** @hidden */\n      this._ariaDisabled = false;\n      /** @hidden */\n      this._ariaHidden = true;\n      /** An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)  */\n      this._onDestroy$ = new Subject();\n      /** Unique element ID */\n      this._elementId = 'fdNestedItem' + sideNavigationItemUniqueId++;\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      this._setUpSubscriptions();\n      this._propagateHasChildrenProperty();\n      this._passItemReferences();\n      /** Propagate initial open state to children */\n      this.propagateOpenChange(this._expanded);\n      if (this.linkItem) {\n        this._ariaSelected = this.linkItem.selected;\n        this._ariaDisabled = !this._stateService.selectable && !this.linkItem.selected;\n        this._title = this.linkItem.getTitle();\n      }\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n    }\n    /** Check if the item element has any child */\n    get hasChildren() {\n      return !!this._itemService?.list;\n    }\n    /** Get all of the children item elements */\n    get allChildrenItems() {\n      if (this._itemService?.list) {\n        return this._itemService.list.nestedItems.toArray();\n      }\n      return [];\n    }\n    /** Method that expand the item and propagate it to children */\n    triggerOpen() {\n      if (!this.expanded) {\n        /** Propagate initial open state to children */\n        this.propagateOpenChange(true);\n      }\n    }\n    /** Method that close the item and propagate it to children */\n    triggerClose() {\n      if (this.expanded) {\n        /** Propagate initial open state to children */\n        this.propagateOpenChange(false);\n      }\n    }\n    /** Method that toggle the item and propagate it to children */\n    toggle() {\n      /** Propagate initial open state to children */\n      this.propagateOpenChange(!this._expanded);\n    }\n    /** Method that dispatches `click` event on link item*/\n    click() {\n      if (this.contentItem) {\n        this.contentItem.click();\n      } else if (this.linkItem) {\n        this.linkItem.click();\n      }\n    }\n    /** Method that focuses link item*/\n    focus() {\n      if (this.contentItem) {\n        this.contentItem.focus();\n      } else if (this.linkItem) {\n        this.linkItem.focus();\n      }\n    }\n    /** Method that provides information if element, or children of this element has passed id */\n    containsId(id) {\n      if (this._elementId === id) {\n        return true;\n      }\n      if (this._itemService.list) {\n        return !!this._itemService.list.nestedItems.find(item => item.containsId(id));\n      }\n      return false;\n    }\n    /**\n     * @hidden\n     * Propagate open state to all of the children\n     */\n    propagateOpenChange(open) {\n      this._expanded = open;\n      if (this.hasChildren) {\n        this._ariaExpanded = this._expanded;\n      }\n      /**\n       * Propagate to child content directive, which contains icon and link\n       */\n      if (this.contentItem) {\n        this.contentItem.changeExpandedState(open);\n        this.contentItem.ariaExpanded = this._expanded;\n      }\n      /** Propagate hidden flag to list component, that is passed from child */\n      if (this._itemService.list) {\n        this._itemService.list.hidden = !open;\n        this._itemService.list.detectChanges();\n      }\n      /** Propagate open flag to popover list component, that is passed from child */\n      if (this._itemService.popover) {\n        this._itemService.popover.open = open;\n      }\n      /**\n       * If there are any list below\n       * Trigger event to provide keyboard support to new list of opened item element.\n       * */\n      if (this._shouldRefreshKeyboardService()) {\n        this._keyboardService.refresh$.next();\n      }\n      this.expandedChange.emit(open);\n    }\n    /** @hidden */\n    _shouldRefreshKeyboardService() {\n      return !!(this._itemService.popover || this._itemService.list || this.contentItem);\n    }\n    /** @hidden */\n    _setUpSubscriptions() {\n      if (this._stateService.condensed) {\n        this._role = 'menuitemradio';\n      }\n      /** Subscribe to mouse click event, thrown by link item */\n      this._itemService.toggle.pipe(takeUntil(this._onDestroy$)).subscribe(() => this.toggle());\n      /** Subscribe to mouse click event, thrown by link item */\n      this._itemService.click.pipe(takeUntil(this._onDestroy$)).subscribe(() => this._stateService.onSelected.next(this._elementId));\n      /** Subscribe to keyboard event and throw it farther */\n      this._itemService.keyDown.pipe(takeUntil(this._onDestroy$)).subscribe(keyboardEvent => this.keyboardTriggered.emit(keyboardEvent));\n      /** Subscribe to selected state change, it's not triggered, when selectable flag is disabled*/\n      this._stateService.onSelected.pipe(takeUntil(this._onDestroy$), filter(() => this._stateService.selectable)).subscribe(id => this._selectedChange(id));\n    }\n    /** @hidden */\n    _propagateHasChildrenProperty() {\n      if (this.contentItem && this.hasChildren) {\n        this._ariaExpanded = false;\n        this.contentItem.hasChildren = true;\n        this.contentItem.changeDetRef.detectChanges();\n      }\n    }\n    /** Pass this element to popover child item, to allow control `expanded` value */\n    _passItemReferences() {\n      if (this._itemService.popover) {\n        this._itemService.popover.parentItemElement = this;\n      }\n    }\n    /** Change of selected state of content or link, if there is any children with I */\n    _selectedChange(id) {\n      const selected = this.containsId(id);\n      this._ariaSelected = selected;\n      if (this.contentItem) {\n        this.contentItem.changeSelected(selected);\n      } else if (this.linkItem) {\n        this.linkItem.changeSelected(selected);\n      }\n    }\n  }\n  NestedItemDirective.ɵfac = function NestedItemDirective_Factory(t) {\n    return new (t || NestedItemDirective)(i0.ɵɵdirectiveInject(NestedItemService), i0.ɵɵdirectiveInject(NestedListKeyboardService), i0.ɵɵdirectiveInject(NestedListStateService));\n  };\n  NestedItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NestedItemDirective,\n    selectors: [[\"\", \"fdNestedItem\", \"\"], [\"\", \"fd-nested-list-item\", \"\"]],\n    contentQueries: function NestedItemDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NestedLinkDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NestedListContentDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkItem = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentItem = _t.first);\n      }\n    },\n    hostVars: 10,\n    hostBindings: function NestedItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-level\", ctx._ariaLevel)(\"title\", ctx._title)(\"role\", ctx._role)(\"aria-expanded\", ctx._ariaExpanded)(\"aria-selected\", ctx._ariaSelected)(\"aria-disabled\", ctx._ariaDisabled)(\"aria-label\", ctx._ariaLabel)(\"aria-hidden\", ctx._ariaHidden);\n        i0.ɵɵclassProp(\"fd-nested-list__item\", ctx.fdNestedListItemClass);\n      }\n    },\n    inputs: {\n      expanded: \"expanded\"\n    },\n    outputs: {\n      expandedChange: \"expandedChange\",\n      keyboardTriggered: \"keyboardTriggered\"\n    },\n    features: [i0.ɵɵProvidersFeature([NestedItemService])]\n  });\n  return NestedItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedListDirective = /*#__PURE__*/(() => {\n  class NestedListDirective {\n    /** @hidden */\n    constructor(_nestedItemService, _nestedListStateService, _nestedListKeyboardService, _elementRef, _changeDetectionRef, _language$, _contentDensityObserver) {\n      this._nestedItemService = _nestedItemService;\n      this._nestedListStateService = _nestedListStateService;\n      this._nestedListKeyboardService = _nestedListKeyboardService;\n      this._elementRef = _elementRef;\n      this._changeDetectionRef = _changeDetectionRef;\n      this._language$ = _language$;\n      this._contentDensityObserver = _contentDensityObserver;\n      /** In case the user wants to no use icons for items in this list */\n      this.textOnly = false;\n      /** Aria defines role description for the Nested List Tree. */\n      this.ariaRoledescriptionTree = 'Navigation List Tree';\n      /** Aria defines role description for the Nested List MenuBar. */\n      this.ariaRoledescriptionMenuBar = 'Navigation List Menu Bar';\n      /** Aria defines aria label for the selected item when the list with disabled selection. */\n      this.ariaLabelSelected = 'Selected';\n      /** @hidden */\n      this.fdNestedListItemClass = true;\n      /** @hidden */\n      this.hidden = false;\n      /** @hidden */\n      this._subscriptions = new Subscription();\n      /** @hidden */\n      this._role = 'tree';\n      /** @hidden */\n      this._ariaRoledescription = this.ariaRoledescriptionTree;\n      /** @hidden */\n      this._ariaHaspopup = null;\n      /** @hidden */\n      this._tabindex = '-1';\n      /** @hidden */\n      this._translationResolver = new TranslationResolver();\n      if (this._nestedItemService) {\n        this._nestedItemService.list = this;\n      }\n      _contentDensityObserver.subscribe();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscriptions.unsubscribe();\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      let nestedLevel = this._getNestedLevel();\n      /** If there is condensed mode, maximum 2nd level class of nest can be added */\n      if (this._nestedListStateService.condensed) {\n        nestedLevel = Math.min(...[nestedLevel, 2]);\n      }\n      this._setAccessibilityProperties(nestedLevel);\n      const sub = combineLatest([this._language$, this.nestedItems.changes.pipe(startWith(undefined))]).subscribe(([lang]) => {\n        this._nestedListKeyboardService.refresh$.next();\n        this._setAriaAttributes(nestedLevel, lang);\n      });\n      this._subscriptions.add(sub);\n      this._handleNestedLevel(nestedLevel);\n    }\n    /** @hidden */\n    detectChanges() {\n      this._changeDetectionRef.markForCheck();\n    }\n    /** @hidden */\n    _handleNestedLevel(level) {\n      /** Adding class with the nested level */\n      this._elementRef.nativeElement.classList.add('level-' + level);\n    }\n    /**\n     * @hidden\n     * Method, that checks how deep is the list element\n     */\n    _getNestedLevel() {\n      let element = this._elementRef.nativeElement;\n      const parentElements = [];\n      /** Method that gathers all of the parentNode elements of current NestedListDirective element */\n      while (element.parentNode) {\n        parentElements.unshift(element);\n        element = element.parentNode;\n      }\n      /** Filter only elements, that has `fd-nested-list` directive attribute */\n      const filteredParentElements = parentElements.filter(_element => _element.hasAttribute('fd-nested-list'));\n      return filteredParentElements.length;\n    }\n    /** @hidden */\n    _setAriaAttributes(level, lang) {\n      this.nestedItems.forEach((item, i) => {\n        item._ariaLevel = level;\n        if (!item.linkItem) {\n          return;\n        } else {\n          item.linkItem.ariaDescribedby = this._nestedListHeader?.id || null;\n          item.linkItem._ariaLabel = this._translationResolver.resolve(lang, 'coreNestedList.linkItemAriaLabel', {\n            itemDetails: item.linkItem.getTitle(),\n            index: i + 1,\n            total: this.nestedItems.length,\n            selectedDescription: !this._nestedListStateService.selectable && item.linkItem.selected ? ', ' + this.ariaLabelSelected : ''\n          });\n        }\n      });\n      this._changeDetectionRef.detectChanges();\n    }\n    /** @hidden */\n    _setAccessibilityProperties(level) {\n      if (this._nestedListStateService.condensed && level === 1) {\n        this._ariaRoledescription = this.ariaRoledescriptionMenuBar;\n      }\n      if (level > 1 || this._nestedItemService?.popover && !this._nestedListStateService.condensed) {\n        this._role = 'group';\n        this._ariaRoledescription = null;\n      }\n      if (this._nestedItemService?.popover) {\n        this._ariaHaspopup = 'tree';\n      }\n    }\n  }\n  NestedListDirective.ɵfac = function NestedListDirective_Factory(t) {\n    return new (t || NestedListDirective)(i0.ɵɵdirectiveInject(NestedItemService, 8), i0.ɵɵdirectiveInject(NestedListStateService), i0.ɵɵdirectiveInject(NestedListKeyboardService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(FD_LANGUAGE), i0.ɵɵdirectiveInject(i4.ContentDensityObserver));\n  };\n  NestedListDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NestedListDirective,\n    selectors: [[\"\", \"fdNestedList\", \"\"], [\"\", \"fd-nested-list\", \"\"]],\n    contentQueries: function NestedListDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NestedListHeaderDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NestedItemDirective, 4);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nestedListHeader = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nestedItems = _t);\n      }\n    },\n    hostVars: 9,\n    hostBindings: function NestedListDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-hidden\", ctx.hidden)(\"role\", ctx._role)(\"aria-roledescription\", ctx._ariaRoledescription)(\"aria-haspopup\", ctx._ariaHaspopup)(\"tabindex\", ctx._tabindex);\n        i0.ɵɵclassProp(\"fd-nested-list--text-only\", ctx.textOnly)(\"fd-nested-list\", ctx.fdNestedListItemClass);\n      }\n    },\n    inputs: {\n      textOnly: \"textOnly\",\n      ariaRoledescriptionTree: \"ariaRoledescriptionTree\",\n      ariaRoledescriptionMenuBar: \"ariaRoledescriptionMenuBar\",\n      ariaLabelSelected: \"ariaLabelSelected\"\n    },\n    features: [i0.ɵɵProvidersFeature([contentDensityObserverProviders()])]\n  });\n  return NestedListDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedListPopoverComponent = /*#__PURE__*/(() => {\n  class NestedListPopoverComponent {\n    /** @hidden */\n    constructor(_keyboardNestService, _itemService, _rtlService) {\n      this._keyboardNestService = _keyboardNestService;\n      this._itemService = _itemService;\n      this._rtlService = _rtlService;\n      /** @hidden\n       * For Internal Usage - Gets information about title, which should be displayed inside popover\n       */\n      this.title = '';\n      /** @hidden */\n      this.popoverClass = true;\n      /** @hidden */\n      this.open = false;\n      this._listenOnKeyboardRefresh();\n      this._createRtlObservable();\n      if (this._itemService) {\n        this._itemService.popover = this;\n      }\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      if (!this.title) {\n        this.title = this._getTitle();\n      }\n    }\n    /**\n     * Method called, when open state is changed, from popover component (escape key, outside click).\n     */\n    handleOpenChange(open) {\n      this.open = open;\n      if (this.parentItemElement) {\n        if (open) {\n          this.parentItemElement.triggerOpen();\n        } else {\n          this.parentItemElement.triggerClose();\n        }\n      }\n    }\n    /** Returns title of nested link element inside content directive */\n    _getTitle() {\n      if (this.contentDirective && this.contentDirective.nestedLink) {\n        return this.contentDirective.nestedLink.getTitle();\n      } else {\n        return '';\n      }\n    }\n    /** @hidden */\n    _listenOnKeyboardRefresh() {\n      this._keyboardNestService.refresh$.subscribe(() => {\n        /** Update popover position, on list of hidden items change */\n        if (this.popoverComponent) {\n          this.popoverComponent.refreshPosition();\n        }\n      });\n    }\n    /** @hidden */\n    _createRtlObservable() {\n      this.placement$ = this._rtlService ? this._rtlService.rtl.pipe(map(isRtl => isRtl ? 'left-start' : 'right-start')) : of('right-start');\n    }\n  }\n  NestedListPopoverComponent.ɵfac = function NestedListPopoverComponent_Factory(t) {\n    return new (t || NestedListPopoverComponent)(i0.ɵɵdirectiveInject(NestedListKeyboardService), i0.ɵɵdirectiveInject(NestedItemService, 8), i0.ɵɵdirectiveInject(i2.RtlService, 8));\n  };\n  NestedListPopoverComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NestedListPopoverComponent,\n    selectors: [[\"fd-nested-list-popover\"]],\n    contentQueries: function NestedListPopoverComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NestedLinkDirective, 5);\n        i0.ɵɵcontentQuery(dirIndex, NestedListContentDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.linkDirective = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.contentDirective = _t.first);\n      }\n    },\n    viewQuery: function NestedListPopoverComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(PopoverComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.popoverComponent = _t.first);\n      }\n    },\n    hostVars: 2,\n    hostBindings: function NestedListPopoverComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"fd-nested-list__popover\", ctx.popoverClass);\n      }\n    },\n    inputs: {\n      title: \"title\"\n    },\n    ngContentSelectors: _c5,\n    decls: 11,\n    vars: 8,\n    consts: [[3, \"placement\", \"triggers\", \"noArrow\", \"isOpen\", \"isOpenChange\"], [1, \"fd-nested-list--text-only\"], [\"fd-nested-list-link\", \"\", 1, \"fd-nested-list__popover-header\"], [\"fd-nested-list-title\", \"\"]],\n    template: function NestedListPopoverComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c3);\n        i0.ɵɵelementStart(0, \"fd-popover\", 0);\n        i0.ɵɵlistener(\"isOpenChange\", function NestedListPopoverComponent_Template_fd_popover_isOpenChange_0_listener($event) {\n          return ctx.handleOpenChange($event);\n        });\n        i0.ɵɵpipe(1, \"async\");\n        i0.ɵɵelementStart(2, \"fd-popover-control\");\n        i0.ɵɵprojection(3);\n        i0.ɵɵprojection(4, 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(5, \"fd-popover-body\", 1)(6, \"a\", 2)(7, \"span\", 3);\n        i0.ɵɵtext(8);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵprojection(9, 2);\n        i0.ɵɵprojection(10, 3);\n        i0.ɵɵelementEnd()();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"placement\", i0.ɵɵpipeBind1(1, 5, ctx.placement$))(\"triggers\", i0.ɵɵpureFunction0(7, _c4))(\"noArrow\", false)(\"isOpen\", ctx.open);\n        i0.ɵɵadvance(8);\n        i0.ɵɵtextInterpolate(ctx.title);\n      }\n    },\n    dependencies: [i4$1.PopoverControlComponent, i4$1.PopoverBodyComponent, i4$1.PopoverComponent, NestedLinkDirective, NestedListTitleDirective, i1.AsyncPipe],\n    styles: [\".fd-side-nav--condensed .fd-popover-container-custom .fd-nested-list__title{display:inline-flex}.fd-side-nav--condensed .fd-nested-list__popover-header{box-shadow:0 0 .25rem #00000026,inset 0 -.0625rem #d9d9d9}.fd-side-nav--condensed .fd-popover-custom{display:block}[dir=rtl] .fd-side-nav--condensed .fd-popover-container-custom .fd-nested-list__link,.fd-side-nav--condensed[dir=rtl] .fd-popover-container-custom .fd-nested-list__link{padding-left:1rem}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NestedListPopoverComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Component for internal usage, allows to generate the nested list from defined object.\n */\nlet PreparedNestedListComponent = /*#__PURE__*/(() => {\n  class PreparedNestedListComponent {\n    constructor() {\n      /**\n       * @hidden\n       * For internal usage.\n       * Defines if the component is first\n       */\n      this.first = true;\n      /** Defines if list should be displayed in condensed mode */\n      this.condensed = false;\n    }\n    /**\n     * In prepared nested list, nested items should be taken as reference of View, not Content.\n     * There is direct reference to these directives here.\n     */\n    get nestedListDirective() {\n      return this._nestedListDirective;\n    }\n    /** @hidden */\n    _expandedChange(expanded, item) {\n      item.expanded = expanded;\n    }\n  }\n  PreparedNestedListComponent.ɵfac = function PreparedNestedListComponent_Factory(t) {\n    return new (t || PreparedNestedListComponent)();\n  };\n  PreparedNestedListComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: PreparedNestedListComponent,\n    selectors: [[\"fd-prepared-nested-list\"]],\n    viewQuery: function PreparedNestedListComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(NestedListDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._nestedListDirective = _t.first);\n      }\n    },\n    inputs: {\n      first: \"first\",\n      condensed: \"condensed\",\n      list: \"list\"\n    },\n    decls: 2,\n    vars: 2,\n    consts: [[\"fd-nested-list\", \"\", 3, \"textOnly\"], [4, \"ngFor\", \"ngForOf\"], [\"fd-nested-list-header\", \"\", 4, \"ngIf\"], [\"fd-nested-list-item\", \"\", 3, \"expanded\", \"expandedChange\", 4, \"ngIf\"], [\"fd-nested-list-header\", \"\"], [\"fd-nested-list-item\", \"\", 3, \"expanded\", \"expandedChange\"], [3, \"title\", 4, \"ngIf\"], [4, \"ngIf\"], [\"link\", \"\"], [3, \"title\"], [\"fd-nested-list-content\", \"\", 3, \"selected\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [\"fd-nested-list-expand-icon\", \"\"], [3, \"first\", \"list\", 4, \"ngIf\"], [3, \"first\", \"list\"], [\"fd-nested-list-content\", \"\"], [\"fd-nested-list-link\", \"\", 3, \"onClickCallback\", \"selected\", \"routerLink\", \"selectedChange\", 4, \"ngIf\"], [\"fd-nested-list-link\", \"\", 3, \"onClickCallback\", \"selected\", \"routerLink\", \"selectedChange\"], [\"fd-nested-list-icon\", \"\", 3, \"glyph\", 4, \"ngIf\"], [\"fd-nested-list-title\", \"\"], [\"fd-nested-list-icon\", \"\", 3, \"glyph\"]],\n    template: function PreparedNestedListComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"ul\", 0);\n        i0.ɵɵtemplate(1, PreparedNestedListComponent_ng_container_1_Template, 3, 2, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"textOnly\", !!(ctx.list == null ? null : ctx.list.textOnly));\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.list == null ? null : ctx.list.items);\n      }\n    },\n    dependencies: [i1.NgForOf, i1.NgIf, i1.NgTemplateOutlet, i2$1.RouterLink, NestedListDirective, NestedLinkDirective, NestedItemDirective, NestedListIconComponent, NestedListTitleDirective, NestedListHeaderDirective, NestedListPopoverComponent, PreparedNestedListComponent, NestedListExpandIconComponent, NestedListContentDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return PreparedNestedListComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet DeprecatedNestedListCompactDirective = /*#__PURE__*/(() => {\n  class DeprecatedNestedListCompactDirective extends DeprecatedCompactDirective {\n    /** @hidden */\n    constructor() {\n      super('[fdNestedList][compact], [fd-nested-list]');\n    }\n  }\n  DeprecatedNestedListCompactDirective.ɵfac = function DeprecatedNestedListCompactDirective_Factory(t) {\n    return new (t || DeprecatedNestedListCompactDirective)();\n  };\n  DeprecatedNestedListCompactDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: DeprecatedNestedListCompactDirective,\n    selectors: [[\"\", \"fdNestedList\", \"\", \"compact\", \"\"], [\"\", \"fd-nested-list\", \"\", \"compact\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CONTENT_DENSITY_DIRECTIVE,\n      useExisting: forwardRef(() => DeprecatedNestedListCompactDirective)\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return DeprecatedNestedListCompactDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet NestedListModule = /*#__PURE__*/(() => {\n  class NestedListModule {}\n  NestedListModule.ɵfac = function NestedListModule_Factory(t) {\n    return new (t || NestedListModule)();\n  };\n  NestedListModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NestedListModule\n  });\n  NestedListModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [MenuKeyboardService, NestedListKeyboardService, NestedListStateService],\n    imports: [CommonModule, PopoverModule, RouterModule, IconModule, ContentDensityModule, ContentDensityModule]\n  });\n  return NestedListModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { DeprecatedNestedListCompactDirective, NestedItemDirective, NestedItemService, NestedLinkDirective, NestedListContentDirective, NestedListDirective, NestedListExpandIconComponent, NestedListHeaderDirective, NestedListIconComponent, NestedListKeyboardService, NestedListModule, NestedListPopoverComponent, NestedListStateService, NestedListTitleDirective, PreparedNestedListComponent };\n//# sourceMappingURL=fundamental-ngx-core-nested-list.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}