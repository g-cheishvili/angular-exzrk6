{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, inject, ElementRef, EventEmitter, isDevMode, Directive, Input, Output, ViewChild, NgModule, ChangeDetectorRef, Injectable } from '@angular/core';\nimport { NgControl, ControlContainer, NgForm } from '@angular/forms';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { Subject, Subscription, takeUntil } from 'rxjs';\nimport { DestroyedService } from '@fundamental-ngx/cdk/utils';\nconst _c0 = [\"inputElementRef\"];\nconst stateSet = new Set(['success', 'error', 'warning', 'default', 'information']);\n/** Checks if the given state is a valid control state. */\nfunction isValidControlState(value) {\n  return stateSet.has(value);\n}\nconst FD_FORM_FIELD = new InjectionToken('FdFormField');\nlet randomId = 0;\nlet CvaDirective = /*#__PURE__*/(() => {\n  class CvaDirective {\n    /** @hidden */\n    constructor() {\n      /**\n       * NgControl instance.\n       */\n      this.ngControl = inject(NgControl, {\n        optional: true\n      });\n      /**\n       * Form container instance. Usually ngForm or FormGroup directives.\n       */\n      this.controlContainer = inject(ControlContainer, {\n        optional: true,\n        skipSelf: true\n      });\n      /**\n       * Separate NgForm instance. For cases when formGroup is used with the form itself.\n       */\n      this.ngForm = inject(NgForm, {\n        optional: true,\n        skipSelf: true\n      });\n      /**\n       * Element reference.\n       */\n      this.elementRef = inject(ElementRef);\n      /** @hidden */\n      this._defaultId = `fd-input-id-${randomId++}`;\n      /** @hidden */\n      this._editable = true;\n      /** @hidden */\n      this._destroyed = new Subject();\n      /** ID for the Element */\n      this.id = this._defaultId;\n      /**\n       * Emits when change detection is needed.\n       */\n      this.detectChanges = new EventEmitter();\n      /**\n       * Emits when mark for changes detection is needed.\n       */\n      this.markForCheck = new EventEmitter();\n      /** @hidden */\n      this._subscriptions = new Subscription();\n      /**\n       * See @FormFieldControl\n       */\n      this.focused = false;\n      /**\n       * @hidden\n       */\n      this._controlInvalid = false;\n      /**\n       * See @FormFieldControl\n       */\n      this.stateChanges = new Subject();\n      /** @hidden */\n      this.formField = inject(FD_FORM_FIELD, {\n        skipSelf: true,\n        optional: true\n      });\n      /** @hidden */\n      this.onChange = () => {};\n      /** @hidden */\n      this.onTouched = () => {};\n      if (this.ngControl) {\n        this.ngControl.valueAccessor = this;\n      }\n    }\n    /**\n     *  The state of the form control - applies css classes.\n     *  Can be 'success', 'error', 'warning', 'default', 'information'.\n     *\n     * @default 'default'\n     */\n    set state(state) {\n      if (!state || isValidControlState(state)) {\n        this._state = state;\n      } else if (isDevMode()) {\n        console.warn(`Provided value \"${state}\" is not a valid option for FormStates type`);\n      }\n    }\n    get state() {\n      if (this._state) {\n        return this._state;\n      }\n      if (!this.controlInvalid) {\n        return 'default';\n      }\n      return this.formField?.getPriorityState() || 'error';\n    }\n    /** Whether the input is disabled */\n    set disabled(value) {\n      this.setDisabledState(value);\n    }\n    get disabled() {\n      if (this.ngControl && this.ngControl.disabled !== null) {\n        return this.ngControl.disabled;\n      }\n      return this._disabled;\n    }\n    /**\n     * Tell the component if we are in editing mode.\n     */\n    set editable(value) {\n      const newVal = coerceBooleanProperty(value);\n      if (this._editable !== newVal) {\n        this._editable = newVal;\n        this._markForCheck();\n        this.stateChanges.next('editable');\n      }\n    }\n    get editable() {\n      return this._editable;\n    }\n    /** Whether control has errors */\n    get controlInvalid() {\n      return this._controlInvalid;\n    }\n    /** @hidden */\n    ngOnInit() {\n      this.formField?.registerFormFieldControl(this);\n    }\n    /**\n     * Re-validate and emit event to parent container on every CD cycle as they are some errors\n     * that we can't subscribe to.\n     */\n    ngDoCheck() {\n      if (this.ngControl) {\n        this.updateErrorState();\n      }\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      if (this.ngControl) {\n        this._subscriptions.add(this.ngControl.statusChanges?.subscribe(() => {\n          this._markForCheck();\n        }));\n      }\n      const labelAndHelpId = `fdp-form-label-content-${this.id}`;\n      // if not specified, associate label and inline help ids with the input,\n      // else add these ids to the specified ones\n      if (!this.ariaLabelledBy) {\n        this.ariaLabelledBy = labelAndHelpId;\n      } else {\n        this.ariaLabelledBy += ' ' + labelAndHelpId;\n      }\n      this._markForCheck();\n    }\n    /** @hidden */\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    /** @hidden */\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._subscriptions.unsubscribe();\n      this.stateChanges.complete();\n      this._destroyed.next();\n      this._destroyed.complete();\n      this.formField?.unregisterFormFieldControl(this);\n    }\n    /** @hidden */\n    setDisabledState(isDisabled) {\n      const newState = coerceBooleanProperty(isDisabled);\n      this._markForCheck();\n      if (newState !== this._disabled) {\n        this._disabled = newState;\n        this.stateChanges.next('setDisabledState');\n      }\n    }\n    /**\n     * Method for setting the value\n     * @param value\n     */\n    writeValue(value) {\n      this.value = value;\n      this.stateChanges.next('writeValue');\n      this._markForCheck();\n    }\n    /**\n     *\n     * Keeps track of element focus\n     */\n    _onFocusChanged(isFocused) {\n      if (isFocused !== this.focused && (!this.disabled || !isFocused)) {\n        this.focused = isFocused;\n        this.stateChanges.next('_onFocusChanged');\n      }\n      if (!isFocused) {\n        this.onTouched();\n      }\n    }\n    /**\n     * Handles even when we click on parent container which is the FormField Wrapping this\n     * control\n     */\n    onContainerClick(event) {\n      this.focus(event);\n    }\n    /**\n     * In most of the cases when working with input element directly you should be just find to assign\n     * variable to this element\n     *\n     * ```\n     * <input #inputElementRef fd-form-control ...>\n     * ```\n     *\n     * and this default behavior used. For other cases implement focus.\n     *\n     */\n    focus(event) {\n      if (this._elementRef && !this.focused) {\n        this._elementRef.nativeElement.focus(event);\n      }\n    }\n    /**\n     *  Need re-validates errors on every CD iteration to make sure we are also\n     *  covering non-control errors, errors that happens outside of this control\n     */\n    updateErrorState() {\n      const parent = this.ngForm;\n      const parentControlContainer = this.controlContainer;\n      const control = this.ngControl ? this.ngControl.control : null;\n      const newStatusIsError = !!(control?.invalid && (control.dirty || control.touched || parent?.submitted || parentControlContainer?.submitted));\n      if (newStatusIsError !== this.controlInvalid) {\n        this._controlInvalid = newStatusIsError;\n        this.stateChanges.next('updateErrorState');\n        this._markForCheck();\n      }\n    }\n    /**\n     * Used to change the value of a control.\n     * @param value the value to be applied\n     * @param emitOnChange whether to emit \"onChange\" event.\n     * Should be \"false\", if the change is made programmatically (internally) by the control, \"true\" otherwise\n     */\n    setValue(value, emitOnChange = true) {\n      if (value !== this.value) {\n        this.writeValue(value);\n        if (emitOnChange) {\n          this.onChange(value);\n        }\n        this._markForCheck();\n      }\n    }\n    /** @hidden */\n    _markForCheck() {\n      this.markForCheck.emit();\n    }\n    /** @hidden */\n    _detectChanges() {\n      this.detectChanges.emit();\n    }\n  }\n  CvaDirective.ɵfac = function CvaDirective_Factory(t) {\n    return new (t || CvaDirective)();\n  };\n  CvaDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CvaDirective,\n    selectors: [[\"\", \"fdkCva\", \"\"]],\n    viewQuery: function CvaDirective_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7, ElementRef);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx._elementRef = _t.first);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      placeholder: \"placeholder\",\n      state: \"state\",\n      stateMessage: \"stateMessage\",\n      disabled: \"disabled\",\n      readonly: \"readonly\",\n      ariaLabelledBy: \"ariaLabelledBy\",\n      ariaLabel: \"ariaLabel\",\n      editable: \"editable\",\n      name: \"name\"\n    },\n    outputs: {\n      detectChanges: \"detectChanges\",\n      markForCheck: \"markForCheck\"\n    },\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([DestroyedService])]\n  });\n  return CvaDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet FormsModule = /*#__PURE__*/(() => {\n  class FormsModule {}\n  FormsModule.ɵfac = function FormsModule_Factory(t) {\n    return new (t || FormsModule)();\n  };\n  FormsModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: FormsModule\n  });\n  FormsModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return FormsModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Base ControlValueAccessor control class.\n * Used in conjunction with CvaDirective.\n *\n * This class performs generic change detection based on `CvaDirective` outputs.\n */\nlet CvaControl = /*#__PURE__*/(() => {\n  class CvaControl {\n    constructor() {\n      /**\n       * Control value accessor directive instance.\n       */\n      this.cvaDirective = inject(CvaDirective, {\n        self: true,\n        optional: true\n      });\n      /**\n       * Change detector instance.\n       */\n      this._changeDetector = inject(ChangeDetectorRef);\n      /** @Hidden */\n      this._destroy$ = inject(DestroyedService);\n    }\n    /** @hidden */\n    listenToChanges() {\n      this.cvaDirective?.markForCheck.pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this._changeDetector.detectChanges();\n      });\n      this.cvaDirective?.detectChanges.pipe(takeUntil(this._destroy$)).subscribe(() => {\n        this._changeDetector.detectChanges();\n      });\n    }\n  }\n  CvaControl.ɵfac = function CvaControl_Factory(t) {\n    return new (t || CvaControl)();\n  };\n  CvaControl.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CvaControl,\n    factory: CvaControl.ɵfac\n  });\n  return CvaControl;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * FormField base class.\n *\n * This class is used to create form field components.\n *\n */\nclass FormField {}\n\n/** @hidden */\nfunction isSelectableItem(item) {\n  return item && item.label !== undefined && item.value !== undefined && Object.prototype.hasOwnProperty.call(item, 'selected');\n}\n/** @hidden */\nfunction isSelectItem(item) {\n  return item && item.label !== undefined && item.value !== undefined;\n}\nconst isOptionItem = isSelectItem;\nconst isSelectableOptionItem = isSelectableItem;\nconst FD_FORM_FIELD_CONTROL = new InjectionToken('FdFormFieldControl');\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CvaControl, CvaDirective, FD_FORM_FIELD, FD_FORM_FIELD_CONTROL, FormField, FormsModule, isOptionItem, isSelectItem, isSelectableItem, isSelectableOptionItem, isValidControlState };\n//# sourceMappingURL=fundamental-ngx-cdk-forms.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}