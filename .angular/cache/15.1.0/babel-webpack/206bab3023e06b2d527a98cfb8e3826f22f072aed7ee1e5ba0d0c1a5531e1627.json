{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, Input, HostBinding, EventEmitter, Injectable, Inject, Output, ContentChildren, Component, ChangeDetectionStrategy, ViewEncapsulation, Optional, ViewChild, HostListener, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { Subject, merge, fromEvent } from 'rxjs';\nimport { takeUntil, take, debounceTime } from 'rxjs/operators';\nimport * as i2 from '@fundamental-ngx/cdk/utils';\nimport { resizeObservable } from '@fundamental-ngx/cdk/utils';\nimport * as i1 from '@fundamental-ngx/core/busy-indicator';\nimport { BusyIndicatorModule } from '@fundamental-ngx/core/busy-indicator';\nimport * as i4 from '@fundamental-ngx/core/button';\nimport { ButtonModule } from '@fundamental-ngx/core/button';\nimport * as i5 from '@fundamental-ngx/i18n';\nimport { I18nModule } from '@fundamental-ngx/i18n';\nconst _c0 = [\"*\"];\nconst _c1 = [\"slideContainer\"];\nconst _c2 = [\"carouselContainer\"];\nfunction CarouselComponent_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction CarouselComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_container_2_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r6 = i0.ɵɵreference(13);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n  }\n}\nfunction CarouselComponent_ng_container_4_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction CarouselComponent_ng_container_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_container_4_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r10 = i0.ɵɵreference(17);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n  }\n}\nfunction CarouselComponent_ng_container_8_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction CarouselComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_container_8_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r12 = i0.ɵɵreference(19);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n  }\n}\nfunction CarouselComponent_ng_container_9_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction CarouselComponent_ng_container_9_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_container_9_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext();\n    const _r6 = i0.ɵɵreference(13);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r6);\n  }\n}\nfunction CarouselComponent_ng_template_12_ng_container_1_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction CarouselComponent_ng_template_12_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_template_12_ng_container_1_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n    const _r10 = i0.ɵɵreference(17);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r10);\n  }\n}\nfunction CarouselComponent_ng_template_12_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction CarouselComponent_ng_template_12_ng_container_3_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainer(0);\n  }\n}\nfunction CarouselComponent_ng_template_12_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_template_12_ng_container_3_ng_container_1_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    i0.ɵɵnextContext(2);\n    const _r12 = i0.ɵɵreference(19);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r12);\n  }\n}\nfunction CarouselComponent_ng_template_12_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 12);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_template_12_ng_container_1_Template, 2, 1, \"ng-container\", 2);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_template_12_ng_container_2_Template, 1, 0, \"ng-container\", 11);\n    i0.ɵɵtemplate(3, CarouselComponent_ng_template_12_ng_container_3_Template, 2, 1, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r7 = i0.ɵɵnextContext();\n    const _r8 = i0.ɵɵreference(15);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7._showNavigationButtonInPageIndicatorContainer);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", _r8);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r7._showNavigationButtonInPageIndicatorContainer);\n  }\n}\nfunction CarouselComponent_ng_template_14_ng_container_0_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 14);\n    i0.ɵɵtext(2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r25 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(2);\n    i0.ɵɵtextInterpolate1(\" \", ctx_r25.getPageIndicatorLabel, \" \");\n  }\n}\nfunction CarouselComponent_ng_template_14_ng_container_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 13);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_template_14_ng_container_0_ng_container_2_Template, 3, 1, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r23 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(2);\n    i0.ɵɵproperty(\"ngIf\", ctx_r23.pageIndicator);\n  }\n}\nfunction CarouselComponent_ng_template_14_ng_container_1_ng_container_2_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelement(1, \"li\", 16);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const i_r29 = ctx.index;\n    const ctx_r27 = i0.ɵɵnextContext(4);\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"fd-carousel__page-indicator--active\", i_r29 === ctx_r27.currentActiveSlidesStartIndex);\n    i0.ɵɵattribute(\"data-slide-to\", i_r29 + 1);\n  }\n}\nfunction CarouselComponent_ng_template_14_ng_container_1_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_template_14_ng_container_1_ng_container_2_ng_container_1_Template, 2, 3, \"ng-container\", 15);\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r26 = i0.ɵɵnextContext(3);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r26.pageIndicatorsCountArray);\n  }\n}\nfunction CarouselComponent_ng_template_14_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"ol\", 13);\n    i0.ɵɵtemplate(2, CarouselComponent_ng_template_14_ng_container_1_ng_container_2_Template, 2, 1, \"ng-container\", 2);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n  if (rf & 2) {\n    const ctx_r24 = i0.ɵɵnextContext(2);\n    i0.ɵɵadvance(1);\n    i0.ɵɵattribute(\"dir\", ctx_r24.dir);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r24.pageIndicator);\n  }\n}\nfunction CarouselComponent_ng_template_14_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, CarouselComponent_ng_template_14_ng_container_0_Template, 3, 1, \"ng-container\", 2);\n    i0.ɵɵtemplate(1, CarouselComponent_ng_template_14_ng_container_1_Template, 3, 2, \"ng-container\", 2);\n  }\n  if (rf & 2) {\n    const ctx_r9 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"ngIf\", ctx_r9.numericIndicator);\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", !ctx_r9.numericIndicator && ctx_r9._showNavigationButtonInPageIndicatorContainer);\n  }\n}\nfunction CarouselComponent_ng_template_16_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r31 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 17);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_template_16_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r31);\n      const ctx_r30 = i0.ɵɵnextContext();\n      ctx_r30.previous();\n      return i0.ɵɵresetView($event.stopPropagation());\n    });\n    i0.ɵɵpipe(1, \"fdTranslate\");\n    i0.ɵɵpipe(2, \"fdTranslate\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r11 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"z-index\", 1);\n    i0.ɵɵproperty(\"disabled\", ctx_r11.leftButtonDisabled);\n    i0.ɵɵattribute(\"aria-label\", ctx_r11.leftNavigationBtnLabel || i0.ɵɵpipeBind1(1, 5, \"coreCarousel.leftNavigationBtnLabel\"))(\"title\", ctx_r11.leftNavigationBtnLabel || i0.ɵɵpipeBind1(2, 7, \"coreCarousel.leftNavigationBtnLabel\"));\n  }\n}\nfunction CarouselComponent_ng_template_18_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r33 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"button\", 18);\n    i0.ɵɵlistener(\"click\", function CarouselComponent_ng_template_18_Template_button_click_0_listener($event) {\n      i0.ɵɵrestoreView(_r33);\n      const ctx_r32 = i0.ɵɵnextContext();\n      ctx_r32.next();\n      return i0.ɵɵresetView($event.stopPropagation());\n    });\n    i0.ɵɵpipe(1, \"fdTranslate\");\n    i0.ɵɵpipe(2, \"fdTranslate\");\n    i0.ɵɵelementEnd();\n  }\n  if (rf & 2) {\n    const ctx_r13 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"z-index\", 1);\n    i0.ɵɵproperty(\"disabled\", ctx_r13.rightButtonDisabled);\n    i0.ɵɵattribute(\"aria-label\", ctx_r13.rightNavigationBtnLabel || i0.ɵɵpipeBind1(1, 5, \"coreCarousel.rightNavigationBtnLabel\"))(\"title\", ctx_r13.rightNavigationBtnLabel || i0.ɵɵpipeBind1(2, 7, \"coreCarousel.rightNavigationBtnLabel\"));\n  }\n}\nlet carouselItemCounter$1 = 0;\nlet CarouselItemDirective = /*#__PURE__*/(() => {\n  class CarouselItemDirective {\n    /** @hidden */\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n      /** Carousel Id, it has some default value if not set,  */\n      this.id = 'carousel-item-id-' + carouselItemCounter$1++;\n    }\n    /** Native element  */\n    get element() {\n      return this._elementRef.nativeElement;\n    }\n    /** Width of element */\n    getWidth() {\n      return this.element.getBoundingClientRect().width || this.initialWidth;\n    }\n    /** Height of element */\n    getHeight() {\n      return this.element.getBoundingClientRect().height || this.initialHeight;\n    }\n  }\n  CarouselItemDirective.ɵfac = function CarouselItemDirective_Factory(t) {\n    return new (t || CarouselItemDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  CarouselItemDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CarouselItemDirective,\n    selectors: [[\"\", \"fd-carousel-item\", \"\"], [\"\", \"fdCarouselItem\", \"\"]],\n    hostVars: 1,\n    hostBindings: function CarouselItemDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n      }\n    },\n    inputs: {\n      value: \"value\",\n      initialHeight: \"initialHeight\",\n      initialWidth: \"initialWidth\",\n      id: \"id\"\n    },\n    exportAs: [\"fdCarouselItem\"]\n  });\n  return CarouselItemDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst DEFAULT_TRANSITION_DURATION = '150ms';\n/** @dynamic */\nlet CarouselService = /*#__PURE__*/(() => {\n  class CarouselService {\n    /** Current transition value in px */\n    set currentTransitionPx(currentTransitionPx) {\n      this._currentTransitionPx = currentTransitionPx;\n    }\n    get currentTransitionPx() {\n      return this._currentTransitionPx;\n    }\n    /** @hidden */\n    get elementsAtOnce() {\n      const num = this.config?.elementsAtOnce ?? 1;\n      return Math.max(1, num);\n    }\n    /** @hidden */\n    constructor(_document) {\n      this._document = _document;\n      /** Event thrown when element is dragged. Emits \"true\" when drag starts and \"false\" when drag ends. */\n      this.dragStateChange$ = new EventEmitter();\n      /** Event thrown, when active element is changed */\n      this.activeChange$ = new EventEmitter();\n      /** Set to true for rtl mode */\n      this.isRtl = false;\n      /** @hidden */\n      this._lastDistance = 0;\n      /** @hidden */\n      this._currentTransitionPx = 0;\n      /** @hidden */\n      this._initialDragPosition = 0;\n      /** @hidden */\n      this._lastDragPosition = 0;\n      /** @hidden */\n      this._listenToMouseMove = false;\n      /** @hidden */\n      this._dragStarted = false;\n      /**\n       * @hidden\n       * An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing)\n       */\n      this._onDestroy$ = new Subject();\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n      this.activeChange$.complete();\n      this.dragStateChange$.complete();\n    }\n    /** set initial values for the service */\n    initialise(config, items, listElementReference) {\n      this.config = config;\n      this.setElement(listElementReference);\n      this.setItems(items);\n      if (this.config.gestureSupport) {\n        this._setupGestures();\n      }\n    }\n    /** update config value for the service */\n    updateConfig(config) {\n      this.config = config;\n    }\n    /** set element ref */\n    setElement(elementRef) {\n      this._element = elementRef.nativeElement;\n    }\n    /** set items and assign active item, if not already there */\n    setItems(items) {\n      this.items = items;\n      if (!this.active) {\n        this.active = this.items.first;\n      }\n    }\n    /** Change active element */\n    goToItem(item, smooth) {\n      let index = this._getIndexOfItem(item);\n      if (this.config.infinite) {\n        this._centerActive(index);\n        index = this._getIndexOfItem(item);\n      }\n      this._transitionToIndex(index, smooth);\n    }\n    /** pick next element and set it active */\n    pickNext() {\n      if (!this.active) {\n        this.active = this.items.first;\n      }\n      const activeItemIndex = this._getIndexOfItem(this.active);\n      const itemToActivate = this.items.get(activeItemIndex + 1) ?? this.items.first;\n      this.goToItem(itemToActivate, true);\n      this.active = itemToActivate;\n    }\n    /** pick previous element and set it active */\n    pickPrevious() {\n      if (!this.active) {\n        this.active = this.items.get(2);\n      }\n      const activeItemIndex = this._getIndexOfItem(this.active);\n      let itemToActivate = this.items.get(activeItemIndex - 1);\n      // case where slides can move infinitely in one direction\n      // handle case where on-load activeItemIndex = 0 and activeItemIndex - 1 returns undefined item from item array.\n      if (!itemToActivate) {\n        itemToActivate = this.items.last;\n      }\n      this.goToItem(itemToActivate, true);\n      this.active = itemToActivate;\n    }\n    /** @hidden */\n    _centerActive(index) {\n      const middleIndex = Math.ceil(this.items.length / 2);\n      const offset = Math.ceil(this.elementsAtOnce / 2);\n      const missingItems = index + offset - middleIndex;\n      const array = this.items.toArray();\n      if (missingItems > 0) {\n        for (let i = 0; i < missingItems; i++) {\n          const item = array.shift();\n          item && array.push(item);\n        }\n      } else {\n        for (let i = 0; i < Math.abs(missingItems); i++) {\n          const item = array.pop();\n          item && array.unshift(item);\n        }\n      }\n      /** Changing order of elements in QueryList and Native HTML */\n      this.items.reset(array);\n      this.items.forEach(item => item.element.parentNode?.appendChild(item.element));\n      /**\n       * For proper animation it's needed to transform elements,\n       * by changing transition by amount of elements placed at top/bottom\n       */\n      this._element.style.transitionDuration = '0s';\n      this._transitionCarousel(this._currentTransitionPx + this._getSize(this.items.first) * missingItems);\n    }\n    /** @hidden */\n    _transitionToIndex(index, smooth) {\n      let transitionPx = this._getSize(this.items.first) * index;\n      this._element.style.transitionDuration = smooth ? this._getTransition() : '0s';\n      if (!this.isRtl || this.config.vertical && this.isRtl) {\n        transitionPx = -transitionPx;\n      }\n      this._transitionCarousel(transitionPx);\n    }\n    /** @hidden Get closes element, based on current transition */\n    _getClosest() {\n      /** If transition is positive, it should go to first element */\n      if (!this.config.infinite && (!this.config.vertical && (!this.isRtl && this._currentTransitionPx > 0 || this.isRtl && this._currentTransitionPx < 0) || this.config.vertical && this._currentTransitionPx > 0)) {\n        return this.items.first;\n      }\n      const size = this._getSize(this.items.first);\n      /** When scroll is after half of element, then ext one should be active */\n      const halfApproached = Math.abs(this._currentTransitionPx % size) > size / 2;\n      /**\n       * Index based on transition px divided by size of elements,\n       * every element should have same width, otherwise it should be looped through all elements,\n       * which is not good for performance\n       */\n      let index = Math.ceil(Math.abs(this._currentTransitionPx / size));\n      // When elementsAtOnce > 1, swiping should stop at last index - elementsAtOnce\n      const elementsAtOnce = this.elementsAtOnce;\n      if (!this.config.infinite && elementsAtOnce > 1) {\n        // When there're less items in the carousel than the area might display, it should stop to first\n        if (this.items.length < elementsAtOnce) {\n          return this.items.first;\n        }\n        if (index + elementsAtOnce >= this.items.length) {\n          return this.items.get(this.items.length - elementsAtOnce) ?? this.items.first;\n        }\n      }\n      index = index + (halfApproached ? 0 : -1);\n      const item = this.items.get(index);\n      /** Checking if transition went out of scope of array */\n      return item || this.items.last;\n    }\n    /** @hidden */\n    _getIndexOfItem(item) {\n      if (!item) {\n        return -1;\n      }\n      return this.items.toArray().findIndex(_item => _item === item);\n    }\n    /** @hidden Getting size of carousel, width for horizontal, height for vertical */\n    _getSize(item) {\n      if (this.config.vertical) {\n        return item.getHeight();\n      }\n      return item.getWidth();\n    }\n    /** @hidden */\n    _handlePan(delta) {\n      const distance = delta - this._lastDistance;\n      this._lastDistance = delta;\n      this._transitionCarousel(this._currentTransitionPx + distance);\n    }\n    /** @hidden */\n    _handlePanEnd(delta) {\n      this._handlePan(delta);\n      const closestItem = this._getClosest();\n      this.goToItem(closestItem, true);\n      if (!this.active) {\n        this.active = closestItem;\n        this.activeChange$.emit({\n          item: closestItem,\n          after: delta < 0\n        });\n      } else if (this.active !== closestItem) {\n        this.active = closestItem;\n        this.activeChange$.emit({\n          item: closestItem,\n          after: delta < 0\n        });\n      }\n      this.dragStateChange$.emit(false);\n      this._lastDistance = 0;\n    }\n    /**\n     * @hidden Animates the carousel to the currently selected slide.\n     */\n    _transitionCarousel(transitionPx) {\n      this._currentTransitionPx = transitionPx;\n      const axis = this.config.vertical ? 'Y' : 'X';\n      this._element.style.transform = `translate${axis}(${this._currentTransitionPx}px)`;\n    }\n    /** @hidden Pam Start handler, removes transition duration, */\n    _handlePanStart() {\n      this._element.style.transitionDuration = '0s';\n      this.dragStateChange$.emit(true);\n    }\n    /** @hidden */\n    _setupGestures() {\n      this._setupDragStart();\n      this._setupDrag();\n      this._setupDragEnd();\n    }\n    /** @hidden */\n    _subscribeToEvents(events, element, callback) {\n      merge(events.map(e => fromEvent(element, e, {\n        passive: true\n      }))).forEach(evt => {\n        evt.pipe(takeUntil(this._onDestroy$)).subscribe(event => {\n          callback(event);\n        });\n      });\n    }\n    /** @hidden */\n    _setupDragStart() {\n      const events = ['mousedown', 'touchstart'];\n      this._subscribeToEvents(events, this._element, event => {\n        this._listenToMouseMove = true;\n        this._lastDragPosition = this._initialDragPosition = this._getDragCoordinate(event);\n        this._handlePanStart();\n      });\n    }\n    /** @hidden */\n    _setupDrag() {\n      const events = ['mousemove', 'touchmove'];\n      if (!this._document) {\n        throw new Error(`Could not setup drag event subscription. Expected to get document ref, got ${this._document} instead`);\n      }\n      this._subscribeToEvents(events, this._document, event => {\n        const coordinate = this._getDragCoordinate(event);\n        if (!this._listenToMouseMove || coordinate === this._lastDragPosition) {\n          return;\n        }\n        this._dragStarted = true;\n        this._handlePan(this._getDraggedDelta(coordinate));\n      });\n    }\n    /** @hidden */\n    _setupDragEnd() {\n      const events = ['mouseup', 'touchend'];\n      if (!this._document) {\n        throw new Error(`Could not setup drag event subscription. Expected to get document ref, got ${this._document} instead`);\n      }\n      this._subscribeToEvents(events, this._document, event => {\n        if (!this._listenToMouseMove) {\n          return;\n        }\n        if (this._dragStarted) {\n          this._handlePanEnd(this._getDraggedDelta(this._getDragCoordinate(event)));\n        } else {\n          this.dragStateChange$.emit(false);\n        }\n        this._listenToMouseMove = false;\n        this._dragStarted = false;\n      });\n    }\n    /** @hidden */\n    _getTransition() {\n      return this.config?.transition ?? DEFAULT_TRANSITION_DURATION;\n    }\n    /** @hidden */\n    _getDraggedDelta(offset) {\n      this._lastDragPosition = offset;\n      return offset - this._initialDragPosition;\n    }\n    /** @hidden */\n    _getDragCoordinate(event) {\n      let coordinates;\n      if (this._isTouchEvent(event)) {\n        coordinates = event.touches[0] || event.changedTouches[0];\n      } else {\n        coordinates = event;\n      }\n      return this.config.vertical ? coordinates.pageY : coordinates.pageX;\n    }\n    /** @hidden */\n    _isTouchEvent(event) {\n      return window.TouchEvent && event instanceof TouchEvent;\n    }\n  }\n  CarouselService.ɵfac = function CarouselService_Factory(t) {\n    return new (t || CarouselService)(i0.ɵɵinject(DOCUMENT));\n  };\n  CarouselService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: CarouselService,\n    factory: CarouselService.ɵfac,\n    providedIn: 'root'\n  });\n  return CarouselService;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselDirective = /*#__PURE__*/(() => {\n  class CarouselDirective {\n    /** @hidden */\n    get carouselService() {\n      return this._carouselService;\n    }\n    /** @hidden */\n    constructor(_elementRef, _carouselService) {\n      this._elementRef = _elementRef;\n      this._carouselService = _carouselService;\n      /** Event thrown, when active element is changed */\n      this.activeChange = new EventEmitter();\n      /** Event thrown when element is dragged. Emits \"true\" when drag starts and \"false\" when drag ends. */\n      this.dragStateChange = new EventEmitter();\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      this._carouselService.initialise(this.config, this.items, this._elementRef);\n      this._carouselService.activeChange$.subscribe(event => this.activeChange.emit(event));\n      this._carouselService.dragStateChange$.subscribe(event => this.dragStateChange.emit(event));\n    }\n    /** Change active element */\n    goToItem(item, smooth) {\n      this._carouselService.goToItem(item, smooth);\n    }\n    /** Pick previous carousel item */\n    pickPrevious() {\n      this._carouselService.pickPrevious();\n    }\n    /** Pick next carousel item */\n    pickNext() {\n      this._carouselService.pickNext();\n    }\n  }\n  CarouselDirective.ɵfac = function CarouselDirective_Factory(t) {\n    return new (t || CarouselDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(CarouselService));\n  };\n  CarouselDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CarouselDirective,\n    selectors: [[\"\", \"fdCarousel\", \"\"]],\n    contentQueries: function CarouselDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CarouselItemDirective, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.items = _t);\n      }\n    },\n    hostAttrs: [1, \"fd-carousel_\"],\n    inputs: {\n      config: \"config\",\n      active: \"active\"\n    },\n    outputs: {\n      activeChange: \"activeChange\",\n      dragStateChange: \"dragStateChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([CarouselService])]\n  });\n  return CarouselDirective;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet carouselItemCounter = 0;\nlet CarouselItemComponent = /*#__PURE__*/(() => {\n  class CarouselItemComponent {\n    /** @hidden */\n    set visibility(visibility) {\n      this._visibility = visibility;\n    }\n    get visibility() {\n      return this._visibility;\n    }\n    /** @hidden */\n    constructor(_elementRef) {\n      this._elementRef = _elementRef;\n      /** Id of the Carousel items. */\n      this.id = `fd-carousel-item-${carouselItemCounter++}`;\n      /**\n       * Loading indicator when item is not yet loaded\n       */\n      this.loading = false;\n      /** Sets tooltip for carousel item */\n      this.title = null;\n      /** @hidden */\n      this.carouselItem = true;\n      /** @hidden */\n      this.carouselItemActive = true;\n      /** @hidden Hide/show slide, useful for managing tab order */\n      this._visibility = 'visible';\n    }\n    /** Native element  */\n    get element() {\n      return this._elementRef.nativeElement;\n    }\n    /** Width of element */\n    getWidth() {\n      return this.element.getBoundingClientRect().width || this.initialWidth;\n    }\n    /** Height of element */\n    getHeight() {\n      return this.element.getBoundingClientRect().height || this.initialHeight;\n    }\n  }\n  CarouselItemComponent.ɵfac = function CarouselItemComponent_Factory(t) {\n    return new (t || CarouselItemComponent)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n  CarouselItemComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselItemComponent,\n    selectors: [[\"fd-carousel-item\"]],\n    hostVars: 11,\n    hostBindings: function CarouselItemComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id)(\"aria-label\", ctx.ariaLabel)(\"aria-labelledby\", ctx.ariaLabelledBy)(\"aria-describedby\", ctx.ariaDescribedBy)(\"title\", ctx.title);\n        i0.ɵɵstyleProp(\"visibility\", ctx._visibility);\n        i0.ɵɵclassProp(\"fd-carousel__item\", ctx.carouselItem)(\"fd-carousel__item--active\", ctx.carouselItemActive);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      ariaLabel: \"ariaLabel\",\n      ariaLabelledBy: \"ariaLabelledBy\",\n      ariaDescribedBy: \"ariaDescribedBy\",\n      loading: \"loading\",\n      title: \"title\",\n      initialHeight: \"initialHeight\",\n      initialWidth: \"initialWidth\",\n      value: \"value\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 1,\n    consts: [[3, \"loading\"]],\n    template: function CarouselItemComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"fd-busy-indicator\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n      if (rf & 2) {\n        i0.ɵɵproperty(\"loading\", ctx.loading);\n      }\n    },\n    dependencies: [i1.BusyIndicatorComponent],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return CarouselItemComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst CarouselResourceStringsEN = {\n  fd_carousel_of: 'of',\n  fd_carousel_reader: 'Displaying item'\n};\n\n/** Page limit to switch to numerical indicator */\nconst ICON_PAGE_INDICATOR_LIMIT = 8;\nvar SlideDirection = /*#__PURE__*/(() => {\n  (function (SlideDirection) {\n    SlideDirection[SlideDirection[\"None\"] = 0] = \"None\";\n    SlideDirection[SlideDirection[\"NEXT\"] = 1] = \"NEXT\";\n    SlideDirection[SlideDirection[\"PREVIOUS\"] = 2] = \"PREVIOUS\";\n  })(SlideDirection || (SlideDirection = {}));\n  return SlideDirection;\n})();\nlet carouselCounter = 0;\nclass CarouselActiveSlides {\n  constructor(activeItems, slideDirection) {\n    this.activeItems = activeItems;\n    this.slideDirection = slideDirection;\n  }\n}\nlet CarouselComponent = /*#__PURE__*/(() => {\n  class CarouselComponent {\n    /**\n     * An accessor that sets the resource strings.\n     * By default it uses EN resources.\n     */\n    set resourceStrings(value) {\n      this._resourceStrings = Object.assign({}, this._resourceStrings, value);\n    }\n    /**\n     * An accessor that returns the resource strings.\n     */\n    get resourceStrings() {\n      return this._resourceStrings;\n    }\n    /** Number of items to be visible at a time */\n    set visibleSlidesCount(value) {\n      this._visibleSlidesCount = value;\n      this._visibleSlidesNumericCount = this._getVisibleSlidesCount();\n    }\n    get visibleSlidesCount() {\n      return this._visibleSlidesCount;\n    }\n    /** @hidden */\n    get _contentSizePx() {\n      return this._slidesWrapperSize ? `${this._slidesWrapperSize}px` : this.width;\n    }\n    /** @hidden */\n    constructor(_elementRef, _renderer, _changeDetectorRef, _carouselService, _zone, _rtlService) {\n      this._elementRef = _elementRef;\n      this._renderer = _renderer;\n      this._changeDetectorRef = _changeDetectorRef;\n      this._carouselService = _carouselService;\n      this._zone = _zone;\n      this._rtlService = _rtlService;\n      /** ID for the Carousel. */\n      this.id = `fd-carousel-${carouselCounter++}`;\n      /** Sets aria-label attribute for carousel */\n      this.ariaLabel = null;\n      /** Sets position of page indicator container. Default position is bottom. */\n      this.pageIndicatorsOrientation = 'bottom';\n      /** Width for carousel container */\n      this.width = '100%';\n      /** If carousel is in circular loop */\n      this.loop = false;\n      /** Shows/hides optional navigation button */\n      this.navigation = true;\n      /** Show navigation button in page indicator container or inside content. Default is page indicator container on true value */\n      this.navigatorInPageIndicator = true;\n      /** Convert to Numeric page indicator */\n      this.numericIndicator = false;\n      /** Shows/hides optional page indicator container  */\n      this.pageIndicatorContainer = true;\n      /** Shows/hides optional page indicator */\n      this.pageIndicator = true;\n      /** Sets sliding duration in millie seconds. Default is 150 */\n      this.slideTransitionDuration = 150;\n      /** Is swipe enabled */\n      this.swipeEnabled = true;\n      /** Is carousel is vertical. Default value is false. */\n      this.vertical = false;\n      /** An event that is emitted after a slide transition has happened */\n      this.slideChange = new EventEmitter();\n      /** @hidden Start index of currently active items */\n      this.currentActiveSlidesStartIndex = 0;\n      /** @hidden handles rtl service */\n      this.dir = 'ltr';\n      /** @hidden Make left navigation button disabled */\n      this.leftButtonDisabled = false;\n      /** @hidden Make right navigation button disabled */\n      this.rightButtonDisabled = false;\n      /** @hidden Fake array for counting number of page indicator */\n      this.pageIndicatorsCountArray = [];\n      /** @hidden */\n      this._slidesWrapperSize = 0;\n      /** @hidden */\n      this._visibleSlidesCount = 1;\n      /** @hidden */\n      this._visibleSlidesNumericCount = 1;\n      /** @hidden */\n      this._resourceStrings = CarouselResourceStringsEN;\n      /** @hidden */\n      this._config = {};\n      /** @hidden */\n      this._slidesCopy = [];\n      /** @hidden */\n      this._slideSwiped = false;\n      /** @hidden An RxJS Subject that will kill the data stream upon component’s destruction (for unsubscribing) */\n      this._onDestroy$ = new Subject();\n    }\n    /** @hidden */\n    ngOnInit() {\n      this._subscribeToRtl();\n    }\n    /** @hidden */\n    ngAfterContentInit() {\n      // On carousel load, display first slide + number of slide visible\n      this.currentActiveSlidesStartIndex = 0;\n      // Change pagination display to numeric, if item count is more than 8\n      if (this.slides.length > ICON_PAGE_INDICATOR_LIMIT) {\n        this.numericIndicator = true;\n      }\n      if (this.slides.length > 0) {\n        this._initializeCarousel();\n      } else {\n        this.leftButtonDisabled = true;\n        this.rightButtonDisabled = true;\n        // Disable swipe when there is no carousel item\n        this.swipeEnabled = false;\n        this.navigation = false;\n      }\n      // Keep copy of original slide array, for indicator purpose.\n      // In case of looped carousel, original slides array changes.\n      this._slidesCopy = this.slides.toArray();\n      this._subscribeServiceEvents();\n      // Subscribe to dynamic update of slides\n      this.slides.changes.pipe(takeUntil(this._onDestroy$)).subscribe(() => this._onSlideUpdates());\n      this._changeDetectorRef.markForCheck();\n    }\n    /** @hidden */\n    ngAfterViewInit() {\n      this._initializeServiceConfig();\n      this._carouselService.initialise(this._config, this.slides, this.slideContainer);\n      this._previousVisibleSlidesCount = this._visibleSlidesNumericCount;\n      this._resizeContentContainer();\n    }\n    /** @hidden */\n    ngAfterViewChecked() {\n      if (this._previousVisibleSlidesCount && this._previousVisibleSlidesCount !== this._visibleSlidesNumericCount) {\n        this._initializeCarousel();\n        this._initializeServiceConfig();\n        this._carouselService.updateConfig(this._config);\n        this._previousVisibleSlidesCount = this._visibleSlidesNumericCount;\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /** @hidden */\n    ngOnDestroy() {\n      this._onDestroy$.next();\n      this._onDestroy$.complete();\n    }\n    /** @hidden */\n    get _showNavigationButtonInPageIndicatorContainer() {\n      return this.navigatorInPageIndicator && this.pageIndicatorsCountArray.length > 1;\n    }\n    /** @hidden */\n    get _showNavigationButtonInContent() {\n      return !this.navigatorInPageIndicator && this.pageIndicatorsCountArray.length > 1;\n    }\n    /** @hidden */\n    get _showPageIndicatorContainer() {\n      return this.pageIndicatorContainer && (this.pageIndicatorsCountArray.length > 0 || this.numericIndicator);\n    }\n    /** @hidden */\n    get getPageIndicatorLabel() {\n      return `${this.currentActiveSlidesStartIndex + 1} ${this.resourceStrings.fd_carousel_of} ${this.pageIndicatorsCountArray.length}`;\n    }\n    /** @hidden */\n    get screenReaderLabel() {\n      return `${this.resourceStrings.fd_carousel_reader} ${this.currentActiveSlidesStartIndex + 1} ${this.resourceStrings.fd_carousel_of} ${this.pageIndicatorsCountArray.length}`;\n    }\n    /** @hidden */\n    _focus() {\n      const el = this._elementRef.nativeElement;\n      if (el !== document.activeElement) {\n        el.focus({\n          preventScroll: true\n        });\n      }\n    }\n    /** get value for rtl */\n    _isRtl() {\n      return this._rtlService?.rtl.getValue();\n    }\n    /** @hidden */\n    onKeydownArrowRight(event) {\n      event.preventDefault();\n      this._isRtl() ? this.previous() : this.next();\n    }\n    /** @hidden */\n    onKeydownArrowLeft(event) {\n      event.preventDefault();\n      this._isRtl() ? this.next() : this.previous();\n    }\n    /** Transitions to the previous slide in the carousel. */\n    previous() {\n      if (!this.loop && this.currentActiveSlidesStartIndex <= 0) {\n        return;\n      }\n      this.rightButtonDisabled = false;\n      this._adjustActiveItemPosition(SlideDirection.PREVIOUS);\n      this._preventDefaultBtnFocus();\n      this._carouselService.pickPrevious();\n      this._notifySlideChange(SlideDirection.PREVIOUS);\n      this._changeDetectorRef.detectChanges();\n    }\n    /** Transitions to the next slide in the carousel. */\n    next() {\n      if (!this.loop && this.currentActiveSlidesStartIndex >= this.pageIndicatorsCountArray.length - 1) {\n        return;\n      }\n      // Moving to next slide\n      this.leftButtonDisabled = false;\n      this._adjustActiveItemPosition(SlideDirection.NEXT);\n      this._preventDefaultBtnFocus();\n      this._carouselService.pickNext();\n      this._notifySlideChange(SlideDirection.NEXT);\n      this._changeDetectorRef.detectChanges();\n    }\n    /** @hidden Subscribe to carousel service events */\n    _subscribeServiceEvents() {\n      this._carouselService.activeChange$.subscribe(event => this._onSlideSwipe(event));\n      this._carouselService.dragStateChange$.subscribe(event => this._onSlideDrag(event));\n    }\n    /**\n     * @hidden Prevent native focus flow related to button, if button will be disable on focus state.\n     * It works only if carousel is not in circular loop.\n     */\n    _preventDefaultBtnFocus() {\n      if (this.loop) {\n        return;\n      }\n      const isFirst = this.currentActiveSlidesStartIndex === 0;\n      const isLast = this.currentActiveSlidesStartIndex === this.pageIndicatorsCountArray.length - 1;\n      if (isFirst || isLast) {\n        this._elementRef.nativeElement.focus({\n          preventScroll: true\n        });\n      }\n    }\n    /** @hidden Adjust position of active item, based on slide direction */\n    _adjustActiveItemPosition(slideDirection, step = 1) {\n      // Move one step in the direction\n      const positionAdjustment = slideDirection === SlideDirection.NEXT ? step : -step;\n      this.currentActiveSlidesStartIndex = this.currentActiveSlidesStartIndex + positionAdjustment;\n      // If carousel set to loop\n      if (this.loop) {\n        if (this.currentActiveSlidesStartIndex < 0) {\n          this.currentActiveSlidesStartIndex = this.slides.length + this.currentActiveSlidesStartIndex;\n        } else if (this.currentActiveSlidesStartIndex >= this.slides.length) {\n          this.currentActiveSlidesStartIndex = this.currentActiveSlidesStartIndex % this.slides.length;\n        }\n      } else {\n        this._buttonVisibility();\n      }\n    }\n    /** @hidden Handles navigation button visibility */\n    _buttonVisibility() {\n      if (!this.loop) {\n        // Need to disable navigation button if either direction limit has reached.\n        if (this.currentActiveSlidesStartIndex === 0) {\n          this.leftButtonDisabled = true;\n          this.rightButtonDisabled = false;\n        } else if (this.slides.length - 1 === this.currentActiveSlidesStartIndex) {\n          this.rightButtonDisabled = true;\n          this.leftButtonDisabled = false;\n        } else if (this._visibleSlidesNumericCount > 1 && this.currentActiveSlidesStartIndex + this._visibleSlidesNumericCount >= this.slides.length) {\n          this.rightButtonDisabled = true;\n        } else {\n          this.leftButtonDisabled = false;\n          this.rightButtonDisabled = false;\n        }\n        if (this.slides.length === 1) {\n          this.leftButtonDisabled = true;\n          this.rightButtonDisabled = true;\n        }\n      }\n    }\n    /** @hidden Handle when slide is added or removed */\n    _onSlideUpdates() {\n      this._slidesCopy = this.slides.toArray();\n      this.currentActiveSlidesStartIndex = 0;\n      this._carouselService.initialise(this._config, this.slides, this.slideContainer);\n      this._carouselService.active = null;\n      if (this.vertical) {\n        this._renderer.setStyle(this.slideContainer?.nativeElement, 'transform', 'translateY(0px)');\n      } else {\n        this._renderer.setStyle(this.slideContainer?.nativeElement, 'transform', 'translateX(0px)');\n      }\n      this._initializeCarousel();\n      this._changeDetectorRef.detectChanges();\n    }\n    /** @hidden Initialize carousel with visible items */\n    _initializeCarousel() {\n      this._zone.onMicrotaskEmpty.pipe(take(1)).subscribe(() => {\n        // Handles navigator button enabled/disabled state\n        this._buttonVisibility();\n        let arrayLength;\n        // set page indicator count with fake array, to use in template\n        if (this.loop && this._visibleSlidesNumericCount > 1) {\n          // If loop with multi item visible.\n          arrayLength = this.slides.length;\n        } else {\n          arrayLength = this.slides.length - this._visibleSlidesNumericCount + 1;\n        }\n        const pageIndicatorsIfZeroCount = this.slides.length === 0 ? 0 : 1;\n        this.pageIndicatorsCountArray = new Array(arrayLength > 0 ? arrayLength : pageIndicatorsIfZeroCount);\n        this._goToFirstItem();\n        this.slides.forEach((_slide, index) => {\n          if (index >= this.currentActiveSlidesStartIndex && index < this.currentActiveSlidesStartIndex + this._visibleSlidesNumericCount) {\n            _slide.visibility = 'visible';\n          } else {\n            _slide.visibility = 'hidden';\n          }\n        });\n        this._changeDetectorRef.detectChanges();\n      });\n    }\n    /** @hidden */\n    _goToFirstItem() {\n      if (this.pageIndicatorsCountArray.length === 0 && this._carouselService.currentTransitionPx !== 0 && this.slides.length > 1) {\n        this.currentActiveSlidesStartIndex = 0;\n        this._carouselService.goToItem(this.slides.first);\n      }\n    }\n    /** @hidden Initialize config for Carousel service */\n    _initializeServiceConfig() {\n      this._config.vertical = this.vertical;\n      this._config.elementsAtOnce = this._visibleSlidesNumericCount;\n      this._config.gestureSupport = this.swipeEnabled;\n      this._config.infinite = this.loop;\n      this._config.transition = String(this.slideTransitionDuration) + 'ms';\n      // Carousel service expects transition in string format with unit.\n    }\n    /**\n     * @hidden Returns the slide swapping steps\n     */\n    _getStepTaken(event, actualActiveSlideIndex) {\n      let stepsCalculated;\n      if (!this._isRtl() && event.after || this._isRtl() && !event.after && !this.vertical || this.vertical && event.after) {\n        if (actualActiveSlideIndex === 0 && this.currentActiveSlidesStartIndex === 0) {\n          stepsCalculated = 0;\n        } else if (actualActiveSlideIndex > this.currentActiveSlidesStartIndex) {\n          stepsCalculated = actualActiveSlideIndex - this.currentActiveSlidesStartIndex;\n        } else {\n          stepsCalculated = this.slides.length - this.currentActiveSlidesStartIndex + actualActiveSlideIndex;\n        }\n      } else {\n        // Special case, when first left swipe before slides are rotated in carousel service\n        if (actualActiveSlideIndex === 0 && this.currentActiveSlidesStartIndex === 0) {\n          stepsCalculated = 0;\n        } else if (actualActiveSlideIndex < this.currentActiveSlidesStartIndex) {\n          stepsCalculated = this.currentActiveSlidesStartIndex - actualActiveSlideIndex;\n        } else {\n          stepsCalculated = this.currentActiveSlidesStartIndex + this.slides.length - actualActiveSlideIndex;\n        }\n      }\n      return stepsCalculated;\n    }\n    /** @hidden Handles notification on visible slide change */\n    _notifySlideChange(slideDirection, firstActiveSlide) {\n      const activeSlides = [];\n      let firstActiveSlideIndex;\n      if (this.loop) {\n        firstActiveSlide = this._carouselService.active;\n      }\n      if (firstActiveSlide) {\n        firstActiveSlideIndex = this.slides.toArray().findIndex(_item => _item === firstActiveSlide);\n      } else {\n        firstActiveSlideIndex = this.currentActiveSlidesStartIndex;\n      }\n      for (let activeSlideIndex = 0; activeSlideIndex < this._visibleSlidesNumericCount; activeSlideIndex++) {\n        const index = firstActiveSlideIndex + activeSlideIndex;\n        const slide = this.slides.get(index);\n        if (slide) {\n          activeSlides.push(slide);\n          slide.visibility = 'visible';\n        }\n      }\n      this._manageSlideVisibility(firstActiveSlideIndex);\n      const direction = slideDirection === SlideDirection.NEXT ? 'Next' : 'Previous';\n      this.slideChange.emit(new CarouselActiveSlides(activeSlides, direction));\n    }\n    /** @hidden Manages visibility for slides. Useful in managing tab order */\n    _manageSlideVisibility(firstActiveSlideIndex) {\n      setTimeout(() => {\n        this.slides.forEach((_slides, index) => {\n          if (index >= firstActiveSlideIndex && index < firstActiveSlideIndex + this._visibleSlidesNumericCount) {\n            if (_slides.visibility === 'hidden') {\n              _slides.visibility = 'visible';\n            }\n          } else {\n            if (_slides.visibility === 'visible') {\n              _slides.visibility = 'hidden';\n            }\n          }\n        });\n        this._changeDetectorRef.markForCheck();\n      }, this.slideTransitionDuration);\n    }\n    /** @hidden Rtl change subscription */\n    _subscribeToRtl() {\n      const refreshDirection = () => {\n        this.dir = this._isRtl() ? 'rtl' : 'ltr';\n        this._carouselService.isRtl = this.dir === 'rtl';\n        if (this._carouselService.items && this._carouselService.active) {\n          this._carouselService.goToItem(this._carouselService.active, false);\n        }\n        this._changeDetectorRef.detectChanges();\n      };\n      refreshDirection();\n      this._rtlService?.rtl.pipe(takeUntil(this._onDestroy$)).subscribe(() => refreshDirection());\n    }\n    /** @hidden On Swiping of slide, manage page indicator */\n    _onSlideSwipe(event) {\n      this._slideSwiped = true;\n      const firstActiveSlide = event.item;\n      const actualActiveSlideIndex = this._slidesCopy.findIndex(_slide => _slide === firstActiveSlide);\n      const stepTaken = this._getStepTaken(event, actualActiveSlideIndex);\n      if (stepTaken > 0) {\n        let slideDirection;\n        if (!this._isRtl()) {\n          slideDirection = event.after ? SlideDirection.NEXT : SlideDirection.PREVIOUS;\n        } else {\n          // vertical carousel slide direction is same in ltr and rtl\n          if (this.vertical) {\n            slideDirection = event.after ? SlideDirection.NEXT : SlideDirection.PREVIOUS;\n          } else {\n            slideDirection = event.after ? SlideDirection.PREVIOUS : SlideDirection.NEXT;\n          }\n        }\n        this._adjustActiveItemPosition(slideDirection, stepTaken);\n        this._notifySlideChange(slideDirection, firstActiveSlide);\n        this._changeDetectorRef.detectChanges();\n      }\n    }\n    /**\n     * @hidden Making slides visible when slides are dragged. Otherwise, it looses the effect.\n     */\n    _onSlideDrag(isDragging) {\n      if (isDragging) {\n        this.slides.forEach(_slide => {\n          _slide.visibility = 'visible';\n        });\n        this._slideSwiped = false;\n        this._changeDetectorRef.markForCheck();\n      } else {\n        // After slide limit reached, if dragging starts then revert visibility\n        if (!this._slideSwiped && !this.loop) {\n          this._manageSlideVisibility(this.currentActiveSlidesStartIndex);\n        }\n      }\n    }\n    /**\n     * @hidden\n     * Resizes inner carousel container to fit all items in the viewport and hide those which are not fully in it.\n     */\n    _resizeContentContainer() {\n      merge(resizeObservable(this.slideContainer.nativeElement), resizeObservable(this.carouselContainer.nativeElement)).pipe(debounceTime(100), takeUntil(this._onDestroy$)).subscribe(() => {\n        const {\n          width,\n          slides\n        } = this._getFittingSlidesAndWidth();\n        if (this.visibleSlidesCount === 'auto') {\n          this._visibleSlidesNumericCount = slides;\n          const totalSlides = this.slides.length;\n          let needleSlideIndex = this.currentActiveSlidesStartIndex;\n          // If amount of slides insufficient to fill whole carousel, slide back a bit.\n          if (this.currentActiveSlidesStartIndex + slides > totalSlides) {\n            needleSlideIndex = this.currentActiveSlidesStartIndex - (this.currentActiveSlidesStartIndex + slides - totalSlides);\n          }\n          const needleSlide = this.slides.get(needleSlideIndex);\n          this.currentActiveSlidesStartIndex = needleSlideIndex;\n          this._carouselService.active = needleSlide;\n          // Refresh carousel config and transition to the current slide.\n          this._initializeCarousel();\n          needleSlide && this._carouselService.goToItem(needleSlide);\n          this._notifySlideChange(SlideDirection.None);\n        }\n        if (this._slidesWrapperSize !== width) {\n          this._slidesWrapperSize = width;\n        }\n        this._changeDetectorRef.detectChanges();\n      });\n    }\n    /**\n     * @hidden\n     * Calculates how many slides can be shown within current carousel viewport.\n     * @returns Object containing fitting slides count and total width of those slides.\n     */\n    _getFittingSlidesAndWidth() {\n      if (!this.carouselContainer) {\n        return {\n          width: 0,\n          slides: 1\n        };\n      }\n      const {\n        width\n      } = this.carouselContainer.nativeElement.getBoundingClientRect();\n      let maxSize = 0;\n      let slidesCount = 0;\n      const carouselSlides = this.slides.toArray();\n      const previousSlides = carouselSlides.splice(0, this.currentActiveSlidesStartIndex);\n      const getSlides = slides => {\n        for (const slide of slides) {\n          const slideWidth = slide.getWidth();\n          if (!slideWidth) {\n            break;\n          }\n          const newSize = maxSize + slideWidth;\n          if (newSize > width) {\n            break;\n          }\n          maxSize = newSize;\n          slidesCount++;\n        }\n      };\n      getSlides(carouselSlides);\n      // If with of the rest of the slides is lesser than carouse's viewport, add previous slides to it.\n      if (maxSize < width) {\n        getSlides(previousSlides);\n      }\n      return {\n        width: maxSize,\n        slides: slidesCount\n      };\n    }\n    /** @hidden */\n    _getVisibleSlidesCount() {\n      if (this._visibleSlidesCount !== 'auto') {\n        return this._visibleSlidesCount;\n      }\n      const {\n        slides\n      } = this._getFittingSlidesAndWidth();\n      return slides;\n    }\n  }\n  CarouselComponent.ɵfac = function CarouselComponent_Factory(t) {\n    return new (t || CarouselComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(CarouselService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i2.RtlService, 8));\n  };\n  CarouselComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: CarouselComponent,\n    selectors: [[\"fd-carousel\"]],\n    contentQueries: function CarouselComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CarouselItemComponent, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slides = _t);\n      }\n    },\n    viewQuery: function CarouselComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c1, 5);\n        i0.ɵɵviewQuery(_c2, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.slideContainer = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.carouselContainer = _t.first);\n      }\n    },\n    hostVars: 3,\n    hostBindings: function CarouselComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"keydown.arrowright\", function CarouselComponent_keydown_arrowright_HostBindingHandler($event) {\n          return ctx.onKeydownArrowRight($event);\n        })(\"keydown.arrowleft\", function CarouselComponent_keydown_arrowleft_HostBindingHandler($event) {\n          return ctx.onKeydownArrowLeft($event);\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵattribute(\"id\", ctx.id);\n        i0.ɵɵstyleProp(\"width\", ctx.width);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      ariaLabel: \"ariaLabel\",\n      ariaLabelledBy: \"ariaLabelledBy\",\n      ariaDescribedBy: \"ariaDescribedBy\",\n      pageIndicatorsOrientation: \"pageIndicatorsOrientation\",\n      height: \"height\",\n      width: \"width\",\n      loop: \"loop\",\n      leftNavigationBtnLabel: \"leftNavigationBtnLabel\",\n      rightNavigationBtnLabel: \"rightNavigationBtnLabel\",\n      navigation: \"navigation\",\n      navigatorInPageIndicator: \"navigatorInPageIndicator\",\n      numericIndicator: \"numericIndicator\",\n      pageIndicatorContainer: \"pageIndicatorContainer\",\n      pageIndicator: \"pageIndicator\",\n      resourceStrings: \"resourceStrings\",\n      slideTransitionDuration: \"slideTransitionDuration\",\n      swipeEnabled: \"swipeEnabled\",\n      vertical: \"vertical\",\n      visibleSlidesCount: \"visibleSlidesCount\"\n    },\n    outputs: {\n      slideChange: \"slideChange\"\n    },\n    features: [i0.ɵɵProvidersFeature([CarouselService])],\n    ngContentSelectors: _c0,\n    decls: 20,\n    vars: 17,\n    consts: [[\"data-ride\", \"carousel\", \"tabindex\", \"0\", \"role\", \"region\", 1, \"fd-carousel\", 3, \"click\"], [\"carouselContainer\", \"\"], [4, \"ngIf\"], [1, \"fd-carousel__content\"], [1, \"fd-carousel__slides\"], [\"slideContainer\", \"\"], [\"role\", \"region\", \"aria-live\", \"polite\", \"dir\", \"ltr\", 2, \"display\", \"none\"], [\"pageIndicatorContainer\", \"\"], [\"pageIndicators\", \"\"], [\"buttonLeft\", \"\"], [\"buttonRight\", \"\"], [4, \"ngTemplateOutlet\"], [1, \"fd-carousel__page-indicator-container\"], [1, \"fd-carousel__page-indicators\"], [\"dir\", \"ltr\", 1, \"fd-carousel__text\"], [4, \"ngFor\", \"ngForOf\"], [1, \"fd-carousel__page-indicator\"], [\"fd-button\", \"\", \"data-slide\", \"previous\", \"glyph\", \"slim-arrow-left\", 1, \"fd-carousel__button\", \"fd-carousel__button--left\", 3, \"disabled\", \"click\"], [\"fd-button\", \"\", \"data-slide\", \"next\", \"glyph\", \"slim-arrow-right\", 1, \"fd-carousel__button\", \"fd-carousel__button--right\", 3, \"disabled\", \"click\"]],\n    template: function CarouselComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0, 1);\n        i0.ɵɵlistener(\"click\", function CarouselComponent_Template_div_click_0_listener() {\n          return ctx._focus();\n        });\n        i0.ɵɵtemplate(2, CarouselComponent_ng_container_2_Template, 2, 1, \"ng-container\", 2);\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵtemplate(4, CarouselComponent_ng_container_4_Template, 2, 1, \"ng-container\", 2);\n        i0.ɵɵelementStart(5, \"div\", 4, 5);\n        i0.ɵɵprojection(7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, CarouselComponent_ng_container_8_Template, 2, 1, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(9, CarouselComponent_ng_container_9_Template, 2, 1, \"ng-container\", 2);\n        i0.ɵɵelementStart(10, \"div\", 6);\n        i0.ɵɵtext(11);\n        i0.ɵɵelementEnd()();\n        i0.ɵɵtemplate(12, CarouselComponent_ng_template_12_Template, 4, 3, \"ng-template\", null, 7, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(14, CarouselComponent_ng_template_14_Template, 2, 2, \"ng-template\", null, 8, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(16, CarouselComponent_ng_template_16_Template, 3, 9, \"ng-template\", null, 9, i0.ɵɵtemplateRefExtractor);\n        i0.ɵɵtemplate(18, CarouselComponent_ng_template_18_Template, 3, 9, \"ng-template\", null, 10, i0.ɵɵtemplateRefExtractor);\n      }\n      if (rf & 2) {\n        i0.ɵɵstyleProp(\"height\", ctx.height)(\"width\", ctx.width);\n        i0.ɵɵclassProp(\"fd-carousel--no-navigation\", !ctx.navigation);\n        i0.ɵɵattribute(\"dir\", ctx.dir);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx._showPageIndicatorContainer && ctx.pageIndicatorsOrientation === \"top\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"width\", ctx._contentSizePx);\n        i0.ɵɵclassProp(\"fd-carousel__content--horizontal\", !ctx.vertical);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx._showNavigationButtonInContent);\n        i0.ɵɵadvance(4);\n        i0.ɵɵproperty(\"ngIf\", ctx._showNavigationButtonInContent);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx._showPageIndicatorContainer && ctx.pageIndicatorsOrientation === \"bottom\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵattribute(\"id\", ctx.id + \"-accessibility\");\n        i0.ɵɵadvance(1);\n        i0.ɵɵtextInterpolate1(\" \", ctx.screenReaderLabel, \" \");\n      }\n    },\n    dependencies: [i3.NgForOf, i3.NgIf, i3.NgTemplateOutlet, i4.ButtonComponent, i5.FdTranslatePipe],\n    styles: [\"/*!\\n * Fundamental Library Styles v0.28.3\\n * Copyright (c) 2023 SAP SE or an SAP affiliate company.\\n * Licensed under Apache License 2.0 (https://github.com/SAP/fundamental-styles/blob/main/LICENSE)\\n */.fd-carousel{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);display:flex;flex-direction:column;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:100%;line-height:var(--sapContent_LineHeight);margin:0;max-width:100%;min-width:15.5rem;padding:0;width:100%}.fd-carousel:after,.fd-carousel:before{box-sizing:inherit;font-size:inherit}.fd-carousel.is-focus,.fd-carousel:focus{outline-color:var(--sapContent_FocusColor);outline-style:var(--sapContent_FocusStyle);outline-width:var(--sapContent_FocusWidth)}.fd-carousel.is-hover .fd-carousel__content .fd-carousel__button,.fd-carousel:hover .fd-carousel__content .fd-carousel__button{display:block}.fd-carousel .fd-carousel__content{-webkit-box-sizing:border-box;-ms-flex-preferred-size:100%;background:var(--fdCarousel_Content_Background);border:0;box-sizing:border-box;color:var(--sapTextColor);flex-basis:100%;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;overflow:hidden;padding:0;position:relative}.fd-carousel .fd-carousel__content:after,.fd-carousel .fd-carousel__content:before{box-sizing:inherit;font-size:inherit}.fd-carousel .fd-carousel__content .fd-carousel__button{-webkit-box-shadow:var(--sapContent_Shadow1);-webkit-transform:translateY(-50%);box-shadow:var(--sapContent_Shadow1);display:none;margin:0;position:absolute;top:50%;transform:translateY(-50%)}.fd-carousel .fd-carousel__content .fd-carousel__button--left{left:.5rem}.fd-carousel .fd-carousel__content .fd-carousel__button--left[dir=rtl],[dir=rtl] .fd-carousel .fd-carousel__content .fd-carousel__button--left{left:auto;right:.5rem}.fd-carousel .fd-carousel__content .fd-carousel__button--right{right:.5rem}.fd-carousel .fd-carousel__content .fd-carousel__button--right[dir=rtl],[dir=rtl] .fd-carousel .fd-carousel__content .fd-carousel__button--right{left:.5rem;right:auto}.fd-carousel .fd-carousel__content .fd-carousel__item img{height:auto;min-width:100%}.fd-carousel .fd-carousel__content--horizontal .fd-carousel__slides{-ms-touch-action:pan-y;display:flex;flex-direction:row;min-width:-moz-fit-content;min-width:fit-content;touch-action:pan-y;width:100%}.fd-carousel .fd-carousel__content--horizontal .fd-carousel__item img{min-height:100%;min-width:auto;width:auto}.fd-carousel__slides{-webkit-box-sizing:border-box;-ms-touch-action:pan-x;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-webkit-user-drag:none;-webkit-tap-highlight-color:rgba(0,0,0,0);border:0;box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:100%;line-height:var(--sapContent_LineHeight);margin:0;min-height:-moz-fit-content;min-height:fit-content;padding:0;touch-action:pan-x;user-select:none}.fd-carousel__slides:after,.fd-carousel__slides:before{box-sizing:inherit;font-size:inherit}.fd-carousel__item{-webkit-box-sizing:border-box;-webkit-box-pack:center;-ms-flex-pack:center;align-items:center;border:0;box-sizing:border-box;color:var(--sapTextColor);display:flex;display:none;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:100%;justify-content:center;line-height:var(--sapContent_LineHeight);line-height:0;margin:0;padding:0}.fd-carousel__item:after,.fd-carousel__item:before{box-sizing:inherit;font-size:inherit}.fd-carousel__item--active{display:block}.fd-carousel__item img{pointer-events:none}.fd-carousel__page-indicator-container{-webkit-box-sizing:border-box;-webkit-box-pack:center;-ms-flex-pack:center;align-items:center;background:var(--sapPageFooter_Background);border:0;border-top:var(--fdCarousel_Pagination_Border);box-sizing:border-box;color:var(--sapTextColor);display:flex;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;justify-content:center;line-height:var(--sapContent_LineHeight);margin:0;max-height:3.5rem;min-height:2.75rem;padding:.375rem .5rem}.fd-carousel__page-indicator-container:after,.fd-carousel__page-indicator-container:before{box-sizing:inherit;font-size:inherit}.fd-carousel__page-indicator-container:first-child{border-bottom:var(--fdCarousel_Pagination_Border);border-top:none}.fd-carousel__page-indicators{-webkit-box-sizing:border-box;-webkit-box-pack:center;-ms-flex-pack:center;-webkit-box-align:center;-ms-flex-align:center;-ms-flex-wrap:wrap;align-items:center;border:0;box-sizing:border-box;color:var(--sapTextColor);display:flex;flex-wrap:wrap;font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;justify-content:center;line-height:var(--sapContent_LineHeight);margin:0;min-width:9rem;padding:.5rem}.fd-carousel__page-indicators:after,.fd-carousel__page-indicators:before{box-sizing:inherit;font-size:inherit}.fd-carousel__page-indicator{-webkit-box-sizing:border-box;background-color:var(--fdCarousel_Dot_Background);border:0;border:var(--fdCarousel_Dot_Border);border-radius:50%;box-sizing:border-box;color:var(--sapTextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;height:var(--fdCarousel_Dot_Size);line-height:var(--sapContent_LineHeight);list-style-type:none;margin:0;margin:var(--fdCarousel_Dot_Margin);padding:0;width:var(--fdCarousel_Dot_Size)}.fd-carousel__page-indicator:after,.fd-carousel__page-indicator:before{box-sizing:inherit;font-size:inherit}.fd-carousel__page-indicator--active{background-color:var(--fdCarousel_Dot_Selected_Background);border:var(--fdCarousel_Dot_Selected_Border);height:.5rem;margin:0 .25rem;width:.5rem}.fd-carousel__text{-webkit-box-sizing:border-box;border:0;box-sizing:border-box;color:var(--sapTextColor);color:var(--sapPageFooter_TextColor);font-family:var(--sapFontFamily);font-size:var(--sapFontSize);font-weight:400;forced-color-adjust:none;line-height:var(--sapContent_LineHeight);margin:0;overflow:hidden;padding:0;text-align:center;text-overflow:ellipsis;white-space:nowrap}.fd-carousel__text:after,.fd-carousel__text:before{box-sizing:inherit;font-size:inherit}.fd-carousel .fd-carousel__button{-webkit-box-pack:center;-ms-flex-pack:center;align-items:center;border-radius:50%;display:flex;height:2.125rem;justify-content:center;margin:.25rem;max-height:2.125rem;max-width:2.125rem;min-height:2.125rem;min-width:2.125rem;padding:0;width:2.125rem}.fd-carousel .fd-carousel__button:before{inset:-.25rem;width:auto}.fd-carousel .fd-carousel__button[dir=rtl]>[class*=sap-icon],[dir=rtl] .fd-carousel .fd-carousel__button>[class*=sap-icon]{transform:rotate(180deg)}.fd-carousel .fd-carousel__button.is-hover,.fd-carousel .fd-carousel__button:hover{box-shadow:var(--sapContent_Shadow1)}.fd-carousel--no-navigation .fd-carousel__button,.fd-carousel--no-navigation.is-hover .fd-carousel__content .fd-carousel__button,.fd-carousel--no-navigation:hover .fd-carousel__content .fd-carousel__button{display:none}.fd-carousel__item fd-busy-indicator{display:block;height:100%}\\n\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return CarouselComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CarouselModule = /*#__PURE__*/(() => {\n  class CarouselModule {}\n  CarouselModule.ɵfac = function CarouselModule_Factory(t) {\n    return new (t || CarouselModule)();\n  };\n  CarouselModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CarouselModule\n  });\n  CarouselModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [CarouselService],\n    imports: [CommonModule, BusyIndicatorModule, ButtonModule, I18nModule]\n  });\n  return CarouselModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CarouselComponent, CarouselDirective, CarouselItemComponent, CarouselItemDirective, CarouselModule, CarouselService, DEFAULT_TRANSITION_DURATION, SlideDirection };\n//# sourceMappingURL=fundamental-ngx-core-carousel.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}